[TOC]



# 1.绪论

## 1.3数据库系统的结构

**应用开发人员角度:**三级模式

**最终用户角度:**

- 单用户结构
- 主从式结构
- 分布式结构
- 客户-服务器  (选课系统)(趋势:减少)
- 浏览器-应用服务器/数据库服务器多层结构  (趋势:增多)

#### 1.3.1数据库系统模式的概念

- **型**Type:对某一类数据的结构和属性的说明
- **值**Value:具体赋值

**模式**Schema:

- 数据库逻辑结构和特征的描述
- 型的描述,不涉及具体值
- 翻译数据结构和联系
- 模式相对稳定

**实例**Instance:

- 模式的具体指
- 反映数据库某一时刻的状态
- 同一个模式有很多实例
- 实随数据库中数据更新而变动

#### 1.3.2三级模式结构(模块化)

- #### 模式

   定义：模式也称为逻辑模式（Logic Schema），它是由数据库设计者综合所有的数据需求，从全局的角度对数据库中全部数据的**逻辑结构和特征**的总体描述，是所有用户的**公共数据视图即全局视图**。

   它是数据库模式结构的中间层，既不涉及数据的**物理**存储细节和硬件环境，也与具体的**应用**程序、所使用的应用开发工具及高级程序设计语言无关。

  - 模式通过模式DDL定义。定义模式时不仅要定义数据的逻辑结构（如数据的型、数据类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。
  - 以逻辑模式为框架的数据库称为概念数据库。

- #### 外模式

  - 定义：外模式也称为子模式（Subschema）或用户模式（User Schema），是程序员和最终用户能看见和使用的**局部**数据的逻辑结构和特征的描述，是与**某一应用**有关的数据的逻辑表示。

  - 外模式通常是模式的子集。

  - 由于外模式是面向程序员和最终用户的，因此又称为**用户数据视图**。可以有多个外模式。另一方面，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。

  - 外模式主要通过外模式DDL定义，也有一些外模式通过DML描述。

  - 以用户模式为框架的数据库称为用户数据库。

  - 使用外模式可以带来几点好处

    > - 数据库设计者和用户不必关心整个数据库的数据，而只关心与自己的局部应用有关的一部分数据，并且不需了解它们的**物理存储结构**，这就使得程序设计和数据使用工作都得到了简化。
    > - 由于使用外模式，用户只能操作与其有关的数据，而不能操作与其无关的数据，这有利于数据的**安全保密**。
    > - 由于同一模式可以派生出多个外模式，故有利于**数据独立性和数据共享**

- #### 内模式

  - 定义：内模式也称为**存储模式**（Storage Schema）或**物理模式**（Physical Schema），它是数据**物理结构和存储方式**(顺序存储/hash/Binary Tree)的底层描述，包括记录的存储方式、索引组织方式、数据是否压缩和加密。
  - 一个数据库只有一个内模式，内模式通过内模式DDL定义。
  - 以物理模式为框架的数据库称为物理数据库

![image-20210923105253806](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109231052889.png/)

> 优点:存储介质改变时,无需改变模式,只需要改变**模式映象**

#### 1.3.3二级映像

- 定义：数据库的二级映像技术是指外模式与模式映像、模式与内模式映像技术。二级映像技术不仅在三级模式之间建立联系，同时保证了**数据独立性**。

- 外模式/模式映像：外模式/模式映像定义并保证了外模式与模式之间的对应关系。外模式/模式映像定义通常保存在外模式中。外模式/模式映像保证了数据的**逻辑独立性**。

  > 外模式/模式映像保证了数据的逻辑独立性。即当模式改变时，DBA可以通过修改外模式/模式映像的手段使外模式不变。由于应用程序是根据外模式设计的，即使模式改变了，只要外模式不变，应用程序不必修改仍可照常运行。因此外模式/模式映像保证了数据与应用程序的逻辑独立性。

- 模式/内模式映像：模式/内模式映像定义并保证了模式与内模式之间的对应关系。它描述了数据的记录、数据项在计算机内部是如何组织和表示的。

  > 模式/内模式映像保证了数据的**物理独立性**。即当数据库的物理模式改变了，通过修改模式/内模式映像的手段使模式不变。由于应用程序和用户是根据模式访问数据的，即使物理模式改变了，只要模式不变，应用程序或用户的访问方式不必修改仍可照常**访问数据**。因此模式/内模式映像保证了数据与应用程序的物理独立性。

**数据与程序间的独立性:**

使得数据的定义和描述从程序分离出去

**数据的存取由数据库管理系统管理:**

- 简化应用程序编制
- 大大减少应用程序的维护和修改

### 1.4数据库系统的组成

- 数据库
- 数据库管理系统(&开发工具)
- 应用程序     (QQ)
- 数据库管理员

**1.硬件平台和数据库**

> 足够大的内存(>=32GB)
>
> 足够大的磁盘或磁盘阵列等设备(大量数据)
>
> 较高通道能力,提高书记传送率

**2.软件**

> 数据库管理系统
>
> 支持数据库管理系统的操作系统
>
> 与数据库接口的高级语言和编译系统
>
> 应用开发工具
>
> 应用系统工具

**3.人员**

> 数据库管理员
>
> 设计和系统分析人员
>
> 应用程序人员
>
> 用户

**数据库管理员职责:**

1. 决定信息内容和结构
2. 决定数据库存储结构和存取策略
3. 监控数据库的使用和运行
   - 周期性转储数据库
     - 数据文件
     - 日志文件
   - 系统故障恢复
   - 介质故障恢复
   - 监视审计文件(挑出非法用户)
4. 数据库的改建和重组
   - 性能监控和调优
   - 定期对数据库进行重组织,提高性能
   - 需求改变时,数据库进行重构造

### 1.5小结

**数据库系统概述**

- 数据库的基本概念
- 数据管理发展过程
- 数据库系统特点

**数据模型**

- 数据模型三要素
- 三种数据库模型

**数据库系统内部系统结构**

- 三级模型
- 两层映像

# 2. 关系数据库

### 2.1关系数据结构和形式化定义

#### 2.1.1关系

- 单一的数据结构  关系

- 逻辑解耦股  而未变

- 集合为基础

  **域: 具有相同数据类型的值的集合**

  > 整数
  >
  > 实数
  >
  > 字符串集合
  >
  > {'男','女'}

  **笛卡尔积**:

  > 定义:
  >
  > 元祖:
  >
  > 分量:
  >
  > 基数:
  >
  > 笛卡尔积的表示方法:
  >
  > 一张二维表
  >
  > 每行对应一个元组,每列对应一个域

  ![如何快速理解笛卡尔积的概念](https://exp-picture.cdn.bcebos.com/05aae8a75f0f822bf41b5581c018512c8df14d48.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80)

  

  ![如何快速理解笛卡尔积的概念](https://exp-picture.cdn.bcebos.com/506d92f1d8a72633cf718450c02c56ee7a7f4448.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80)

  ![如何快速理解笛卡尔积的概念](https://exp-picture.cdn.bcebos.com/874f6275e5f4fcf57ef8737d21d7726b0de2bd48.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fquality%2Cq_80)

  

  **关系**:

  > 定义:笛卡尔积的子集
  >
  > 关系的表示:
  >
  > 属性:
  >
  > 码:
  >
  > - 候选码
  >
  >   若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何真子集都不能再标识，则称该属性组为（超级码）候选码。(最少一个属性)
  >
  > - 全码
  >
  >   当所有的属性共同构成一个候选码时，这时该候选码为全码。（教师，课程，学生）假如一个教师可以讲授多门课程，某门课程可以有多个教师讲授，学生可以听不同教师讲授的不同课程，那么，要区分关系中的每一个元组，这个关系模式R的候选码应为全部属性构成 （教师、课程、学生），即主码。
  >
  > - **主键=主码**：**某个**能够**唯一标识**一条记录的**最小属性集（是从候选码里人为挑选的一条）**
  >
  >   唯一性：一个数据表只能有一个主键
  >
  >   标识性：一个数据表的所有记录都具有不同的主键取值
  >
  >   非空性：不能为空
  >
  >   人为的选取某个候选码为主码
  >
  > - 主属性
  >
  >   **主属性** 包含在任一候选码中的属性称主属性。简单来说，主属性是候选码所有属性的并集 
  >
  >   **非主属性** 不包含在候选码中的属性称为非主属性。 非主属性是相对于主属性来定义的。
  >
  > - 三类关系
  >
  >   - 基本关系(基本表)
  >
  >     实际存储数据的表
  >
  >   - 查询表
  >
  >     查询结果对应的表
  >
  >   - 视图表
  >
  >     虚表,不对应实际存储的数据
  >
  > - 基本关系的性质
  >
  >   1.  
  >   2.  
  >   3.  
  >   4.  
  >   5. 

#### 2.1.2关系模式

### 2.2关系操作

### 2.3关系完整性

### ~~2.4关系代数~~

~~是一种抽象的查询语言,用对关系的运算来表达查询~~

- ~~运算对象是关系~~
- ~~运算结果也为关系~~
- ~~关系代数运算符有两类:集合运算符和专门的关系运算符~~

~~//~~

~~//~~

~~**集合运算符**~~

| ~~运算符~~ | ~~含义~~     | ~~英文~~              |
| :--------- | :----------- | :-------------------- |
| ~~∪~~      | ~~并~~       | ~~Union~~             |
| ~~−~~      | ~~差~~       | ~~Difference~~        |
| ~~∩~~      | ~~交~~       | ~~Intersection~~      |
| ~~×~~      | ~~笛卡尔积~~ | ~~Cartesian Product~~ |

~~**专门的关系运算符**~~

| ~~运算符~~ | ~~含义~~ | ~~英文~~       |
| :--------- | :------- | :------------- |
| ~~σ~~      | ~~选择~~ | ~~Selection~~  |
| ~~π~~      | ~~投影~~ | ~~Projection~~ |
| ~~⋈~~      | ~~链接~~ | ~~Join~~       |
| ~~÷~~      | ~~除~~   | Division       |

#### 2.4.2专门的关系运算

//

1. **选择**

   ### 选择操作

   选择操作就是从关系中选出符合条件的元组,选出某一些行来进行操作

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/15573.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123146248-1885053784.png/)

   举例

   > 选择A2值为a或b的元祖

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/80915807.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123147092-1239226119.png/)[![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/0915875.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123147795-1052230714.png/)

2. **投影**

   ### 投影操作

   投影操作是从关系R中选出某些列。

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/087.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123148529-321250163.png/)

   举例

   > 将A1和A3进行投影，如果投影中有重复的元组则需要去掉

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/0915315.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123149592-667325936.png/)

3. **连接**

   **连接操作**

   连接操作是先对两个关系做笛卡儿积生成一个新的关系，然后在新的关系上做选择操作

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/918540.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123150685-139278719.png/)

   Ɵ是比较运算符，如>,<,=等

   举例

   > 下图中先将R和S进行笛卡尔积运算，然后在选出B<=H的元组来。

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/22.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123152388-1505543506.png/)

   > 下图中使用了自连接操作

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/80918934.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123155638-2053638103.png/)

   **自然连接**

   自然连接是一种特殊的**等值链接**，他要求关系R和关系S具有相同的属性组B(b1,b2,b3……),这些属性组的取值是相等的，在最后生成的关系中**去掉属性重复的列**。

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/36.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123158107-129462527.png/)

   举例

   > 下图中属性相同的只有一项B

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/918050.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123159326-1680313204.png/)

4. 除

   ![image-20210928235004171](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109282350277.png/)

5. **悬浮元祖**

   悬浮元组：在R与S做自然连接的时候，被舍弃的元组称作悬浮元组。
   举个栗子：
   左表R:

   | 姓名 | 住址   | 年龄 |
   | ---- | ------ | ---- |
   | 张三 | 河大   | 22   |
   | 李四 | 苹果园 | 23   |
   | 王五 | 堌门村 | 21   |
   | 赵六 | 幸福里 | 23   |

   右表S:

   | 姓名   | 单位 | 薪酬 |
   | ------ | ---- | ---- |
   | 张三   | 腾讯 | 2000 |
   | 李四   | 阿里 | 2300 |
   | 朱小明 | 网易 | 1900 |
   | 赵六   | 滴滴 | 2900 |

   外连接：（保留两个表上的悬浮元组）

   | 姓名   | 住址   | 年龄 | 单位 | 薪酬 |
   | ------ | ------ | ---- | ---- | ---- |
   | 张三   | 河大   | 22   | 腾讯 | 2000 |
   | 李四   | 苹果园 | 23   | 阿里 | 2300 |
   | 赵六   | 幸福里 | 23   | 滴滴 | 2900 |
   | 王五   | 堌门村 | 21   | NULL | NULL |
   | 朱小明 | NULL   | NULL | 网易 | 1900 |

   **左**外连接：（保留左表的悬浮元组）

   | 姓名 | 住址   | 年龄 | 单位 | 薪酬 |
   | ---- | ------ | ---- | ---- | ---- |
   | 张三 | 河大   | 22   | 腾讯 | 2000 |
   | 李四 | 苹果园 | 23   | 阿里 | 2300 |
   | 赵六 | 幸福里 | 23   | 滴滴 | 2900 |
   | 王五 | 堌门村 | 21   | NULL | NULL |

   **右**外连接：（保留右表的悬浮元组）

   | 姓名   | 住址   | 年龄 | 单位 | 薪酬 |
   | ------ | ------ | ---- | ---- | ---- |
   | 张三   | 河大   | 22   | 腾讯 | 2000 |
   | 李四   | 苹果园 | 23   | 阿里 | 2300 |
   | 赵六   | 幸福里 | 23   | 滴滴 | 2900 |
   | 朱小明 | NULL   | NULL | 网易 | 1900 |

6. **除运算**

   ### 除操作

   除操作比较复杂，它是一种全包含操作，通过下面的例子来解释除操作

   [![image](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109280930230.png/)](http://images2015.cnblogs.com/blog/872539/201610/872539-20161020123201232-564347070.png/)

   **R.A1,R.A2的象集必须都包括S.A3的所有元素,结果为符合条件的的R.A1和R.A2的元祖们**

   在(1)中计算R除以S操作，首先生成的关系中没有R和S的公共属性A3。其次生成的关系中每个元组与S中的元组进行组合都能出现在R中。

   在(3)中只有(a,e)的原因是只有(a,e)与S中的每个元组组合才能出现在R中，而像(d,b)这种元组如果如S中每个元组组合的话不能全部出现在R中。

   在(2)中我们可以这样来理解除法运算，找出即出现c又出现f的元组，并且这些元组的其余属性值是相等的。如包含c和f的元组有【(a,b,c)】,【(d,b,c),(d,b,f)】【(a,e,c),(a,e,f)】,其余属性值相等的有(a,e),(d,b)。

   > Eg:查询至少选修1号和3号课程的学生号码.
   >
   > 1.建立一个临时关系
   >
   > | Cno  |
   > | ---- |
   > | 1    |
   > | 3    |
   >
   > 2.求π(Sno,Cno)(SC)÷K

### ~~2.5*关系演算~~

### 2.6小结

- 关系数据库系统是目前使用最广泛的数据系统.
- 关系数据库系统和非关系数据库系统区别:
  - 关系系统只有表
  - 非关系还有其他数据结构
- 关系数据结构
  - 关系
    - 域
    - 笛卡尔积
    - 关系
  - 关系模式
  - ////
  - ////
- 关系操作
  - 查询
  - 数据更新
- 关系完整性约束

- 关系数据语言
  - 关系代数
  - 关系演算*

# 3关系数据库标准语言SQL

### 3.1SQL概述

- 结构化查询语言,关系数据库标准语言
- 通用,功能极强

1. 综合统一

2. 高度非过程化

3. 面向集合操作

4. 可独立可嵌入(c,java)

5. 易学,不易用

   <img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109281023549.png/" alt="image-20210928102307407" style="zoom: 33%;" />

   **数据库的三级模式:**

   <img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109301044498.png/" alt="image-20210930104457245" style="zoom:50%;" />

### 3.2学生-课程数据库

3.3数据定义

- 模式(不适用所有DBMS)
  - 创建
  - 删除
- 表
  - 创建
  - 删除
  - 修改
- 视图
  - 创建
  - 删除
- 索引(用于实现快速查找)
  - 创建
  - 删除
  - 修改

### 3.3.2基本表的定义删除修改

![image-20210930110257732](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109301102969.png/)

```sql
[例3.5]  建立“学生”表Student。学号是主码，姓名取值唯一。

CREATE TABLE Student          
   (Sno   CHAR(9) PRIMARY KEY,                                          /* 列级完整性约束条件,Sno是主码*/                  
     Sname CHAR(20) UNIQUE,   //unique约束      /* Sname取唯一值*/
     Ssex    CHAR(2),
     Sage   SMALLINT,
     Sdept  CHAR(20)
   ); 
```

```sql
[例3.6 ] 建立一个“课程”表Course
	CREATE TABLE  Course
       (Cno       CHAR(4) PRIMARY KEY,
     	 Cname  CHAR(40),            
      	 Cpno     CHAR(4),               	                      
         Ccredit  SMALLINT，
         FOREIGN KEY (Cpno) REFERENCES  Course(Cno) //只能取已有值
       ); 
```

```sql
[例3.7]  建立一个学生选课表SC

	CREATE TABLE  SC
       (Sno  CHAR(9), //列
        Cno  CHAR(4),  //列
        Grade  SMALLINT，//列
        PRIMARY KEY (Sno,Cno),  
                       /* 主码由两个属性构成，必须作为表级完整性进行定义*/
        FOREIGN KEY (Sno) REFERENCES Student(Sno),
                      /* 表级完整性约束条件，Sno是外码，被参照表是Student */
        FOREIGN KEY (Cno)REFERENCES Course(Cno)
                       /* 表级完整性约束条件， Cno是外码，被参照表是Course*/
     ); 
```

**数据类型表:**

**由运算复杂程度决定**

| 数据类型                             | 含义                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| **CHAR(n),CHARACTER(n)**             | 长度为n的定长字符串                                          |
| **VARCHAR**(n),  CHARACTERVARYING(n) | 最大长度为n的变长字符串                                      |
| CLOB                                 | 字符串大对象                                                 |
| BLOB                                 | 二进制大对象                                                 |
| **INT，INTEGER**                     | 长整数（4字节）                                              |
| SMALLINT                             | 短整数（2字节）                                              |
| BIGINT                               | 大整数（8字节）                                              |
| NUMERIC(p，d)                        | 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 |
| DECIMAL(p, d), DEC(p, d)             | 同NUMERIC                                                    |
| REAL                                 | 取决于机器精度的单精度浮点数                                 |
| DOUBLE PRECISION                     | 取决于机器精度的双精度浮点数                                 |
| FLOAT(n)                             | 可选精度的浮点数，精度至少为n位数字                          |
| BOOLEAN                              | 逻辑布尔量                                                   |
| **DATE**                             | 日期，包含年、月、日，格式为YYYY-MM-DD                       |
| TIME                                 | 时间，包含一日的时、分、秒，格式为HH:MM:SS                   |
| TIMESTAMP                            | 时间戳类型                                                   |
| INTERVAL                             | 时间间隔类型                                                 |

**修改基本表:**

**语法:**

```sql
ALTER TABLE <表名>
[ ADD[COLUMN] <新列名> <数据类型> [ 完整性约束 ] ]
[ ADD <表级完整性约束>]
[ DROP [ COLUMN ] <列名> [CASCADE| RESTRICT] ]	#cascade:级联,相关内容一律删除 restrict:防止误删 	小心
[ DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ] ] #删除完整性约束
[ALTER COLUMN <列名><数据类型> ] ; #可能丢失数据   改变列的数据类型   warning!
```

```sql
[例3.8] 向Student表增加“入学时间”列，其数据类型为日期型
     ALTER TABLE Student 
     ADD S_entrance DATE;
#不管基本表中原来是否已有数据，新增加的列一律为空值 
```

**删除基本表:**

```sql
DROP TABLE <表名>［RESTRICT| CASCADE］;
RESTRICT：删除表是有限制的。
欲删除的基本表不能被其他表的约束所引用
如果存在依赖该表的对象，则此表不能被删除
CASCADE：删除该表没有限制。
在删除基本表的同时，相关的依赖对象一起删除 
```

```sql
[例3.11]  删除Student表
     DROP TABLE  Student  CASCADE;
■	基本表定义被删除，数据被删除
■	表上建立的索引、视图、触发器等一般也将被删除 
法2:sql注入  wireshark
正常语句;删表语句
```

## 3.3.3 索引的建立和删除

**目的**:加快查询速度

DBMS常见索引:

> 1. 顺序文件上的索引
> 2. B+树的动态索引(均衡树,效率高)------------特点:动态平衡
> 3. 散列hash索引(快)---------------------特点:速度快
> 4. 位图索引

**谁可以建立索引:**

> 数据库管理员/表的属主

**谁维护索引:**

> 关系数据库管理系统自动完成

**谁使用索引:**

> 关系数据库管理系统(一定是操作数据库的主体)

**建立索引:**

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> 
ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…);
■<表名>：要建索引的基本表的名字
■索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔
■<次序>：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC
■UNIQUE：此索引的每一个索引值只对应唯一的数据记录
■CLUSTER：表示要建立的索引是聚簇索引
```

```sql
[例3.13] 为学生-课程数据库中的Student，Course，SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引
   CREATE UNIQUE INDEX  Stusno ON Student(Sno);
   CREATE UNIQUE INDEX  Coucno ON Course(Cno);
   CREATE UNIQUE INDEX  SCno ON SC(Sno ASC,Cno DESC);
```

**修改索引:**

```sql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
[例3.14] 将SC表的SCno索引名改为SCSno
	ALTER INDEX SCno RENAME TO SCSno;
```

**删除索引:**

```sql
DROP INDEX <索引名>;
删除索引时，系统会从数据字典中删去有关该索引的描述。
[例3.15]  删除Student表的Stusname索引
	        DROP INDEX Stusname;
```

### 3.3.4 数据字典(在数据库类似注册表在win的地位)

**数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：**

- 关系模式定义
- 视图定义
- 索引定义
- 完整性约束定义
- 各类用户对数据库的操作权限
- 统计信息等

关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。

## 3.4数据查询(重点)

**格式:**

```sql
SELECT [ALL|DISTINCT] <目标列表达式>[,<目标列表达式>] …
FROM <表名或视图名>[,<表名或视图名> ]…|(SELECT 语句)      
                   [AS]<别名>
		[ WHERE <条件表达式> ]
		[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]  
		[ ORDER BY <列名2> [ ASC|DESC ] ];		#排序  
```

> **SELECT**子句：指定要显示的属性列
>
> **FROM**子句：指定查询对象（基本表或视图）
>
> **WHERE**子句：指定查询条件
>
> **GROUP BY**子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。
>
> **HAVING**短语：只有满足指定条件的组才予以输出
>
> **ORDER BY**子句：对查询结果表按指定列值的升序或降序排序
>
> **DISTINCT:**去重

### 3.4.1 单表查询(部分没有)比较杂

> **查询仅涉及一个表：**
>
> **1.选择表中的若干列**
>
> **2.选择表中的若干元组**
>
> **3.ORDER BY子句**
>
> **4.聚集函数**
>
> **5.GROUP BY子句**

#### **查询指定列**

```sql
[例3.16]  查询全体学生的学号与姓名。
		SELECT Sno,Sname
		FROM Student; 
[例3.17]  查询全体学生的姓名、学号、所在系。
		SELECT Sname,Sno,Sdept
		FROM Student;
```

#### **查询全部列**

```sql
[例3.18]  查询全体学生的详细记录
SELECT  Sno,Sname,Ssex,Sage,Sdept 
FROM Student; 
或
SELECT  *
FROM Student; 
```

#### **消除取值重复的行**

```sql
 如果没有指定DISTINCT关键词，则缺省为ALL 
[例3.21]  查询选修了课程的学生学号。
    SELECT Sno   FROM SC;
	等价于：
	SELECT ALL  Sno  FROM SC;
	执行上面的SELECT语句后，结果为： 
					    Sno
					201215121
					201215121
					201215121
					201215122
					201215122
```

#### **字符匹配**

```sql
[例3.30]  查询所有姓刘学生的姓名、学号和性别。
       SELECT Sname, Sno, Ssex
      FROM Student
      WHERE  Sname LIKE '刘%';    #通配多个汉字 刘x 刘xx 刘xxx

[例3.31]  查询姓"欧阳"且全名为三个汉字的学生的姓名。
       SELECT Sname
      FROM   Student
      WHERE  Sname LIKE '欧阳__';    #任意单个汉字
```

#### **通配符转义普通字符**

```sql
[例3.34]  查询DB_Design课程的课程号和学分。
      SELECT Cno，Ccredit
      FROM     Course
      WHERE  Cname LIKE 'DB\_Design' ESCAPE '\ ' ;
[例3.35]  查询以"DB_"开头，且倒数第3个字符为 i的课程的详细情况。
      SELECT  *
      FROM    Course
      WHERE  Cname LIKE  'DB\_%i_ _' ESCAPE '\ ' ;
	
	ESCAPE '＼' 表示“ ＼” 为换码字符
```

#### 聚集函数

> **聚集函数**：
>
> - **统计元组个数**
>
>   COUNT(*)
>
> - **统计一列中值的个数**
>
>   COUNT([DISTINCT|ALL] <列名>)
>
> - **计算一列值的总和**（此列必须为数值型）
>
>   SUM([DISTINCT|ALL] <列名>)	
>
> - **计算一列值的平均值**（此列必须为数值型）
>
>   AVG([DISTINCT|ALL] <列名>)
>
> - **求一列中的最大值和最小值**
>
>   MAX([DISTINCT|ALL] <列名>)
>
>   MIN([DISTINCT|ALL] <列名>)

### 3.4.2连接查询(重点)----降低效率

> **连接查询：同时涉及两个以上的表的查询**---也就是汇总

#### 3.4.2.1 **等值与非等值连接查询**

```sql
[例 3.49]  查询每个学生及其选修课程的情况
		         SELECT  Student.*, SC.*
		         FROM     Student, SC
		         WHERE  Student.Sno = SC.Sno;
```

![image-20211005101728679](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110051017896.png/)

> **连接方法:**
>
> 1. 嵌套循环法（NESTED-LOOP）
>
>    - 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。
>
>      表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。
>
> 2. 排序合并法（SORT-MERGE）
>
>    - 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续
>
> 3. 索引连接（INDEX-JOIN）
>
>    - 对表2按连接字段建立索引;
>
>      对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组
>
>    - 不对表2遍历
>    - 需要建立维护索引

```sql
[例 3.51 ]查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。
    SELECT Student.Sno, Sname
    FROM     Student, SC
    WHERE  Student.Sno=SC.Sno  AND    		               
                   SC.Cno=' 2 ' AND SC.Grade>90;
```

**自然连接**

//

#### 3.4.4.2 自身连接

> **自身连接**：一个表与其自己进行连接
>
> **需要给表起别名以示区别**
>
> **由于所有属性名都是同名属性，因此必须使用别名前缀**

```sql
[例 3.52]查询每一门课的间接先修课（即先修课的先修课）
    SELECT  FIRST.Cno, SECOND.Cpno
     FROM  Course  FIRST, Course  SECOND
     WHERE FIRST.Cpno = SECOND.Cno;
```

![image-20211005100054740](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110051001073.png/)

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110051001960.png/" alt="image-20211005100120751" style="zoom:33%;" />

### 3.4.4.3 外连接

> **外连接与普通连接的区别**
>
> - **普通连接操作只输出满足连接条件的元组**
>
>   **外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出**
>
> **左外连接**
>
> - ​	**列出左边关系中所有的元组** 
>
> **右外连接**
>
> - ​	**列出右边关系中所有的元组** 

#### 3.4.4.4 多表连接

> 连接两个以上的表

```sql
[例3.54]查询每个学生的学号、姓名、选修的课程名及成绩
  SELECT Student.Sno, Sname, Cname, Grade
   FROM    Student, SC, Course    /*多表连接*/
   WHERE Student.Sno = SC.Sno 
                  AND SC.Cno = Course.Cno;
```

### 3.4.3 嵌套查询(重点)

> - 一个SELECT-FROM-WHERE语句称为一个查询块
> - 将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询

**不相关子查询:**

> - **不能使用**ORDER BY子句

**相关子查询:**

> 子查询的查询条件依赖于父查询

- 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表
- 然后再取外层表的下一个元组
- 重复这一过程，直至外层表全部检查完为止

>   1.带有IN谓词的子查询 
>   2.带有比较运算符的子查询
>   3.带有ANY（SOME）或ALL谓词的子查询
>   **4.带有EXISTS谓词的子查询**

**1.IN谓词**

```sql
[例 3.55]  查询与“刘晨”在同一个系学习的学生。
此查询要求可以分步来完成
    SELECT Sno, Sname, Sdept
    	FROM Student
   	WHERE Sdept  IN
                  (SELECT Sdept
                   FROM Student
                   WHERE Sname= ' 刘晨 ');            
                   #效率高
等价于
	① 确定“刘晨”所在系名             
         SELECT  Sdept  
         FROM     Student                            
         WHERE  Sname= ' 刘晨 ';
	      结果为： CS
	② 查找所有在CS系学习的学生。    
        SELECT   Sno, Sname, Sdept     
        FROM      Student                 
        WHERE   Sdept= ' CS '; 
        
用自身连接完成[例 3.55]查询要求#效率低
       SELECT  S1.Sno, S1.Sname,S1.Sdept
      FROM     Student S1,Student S2
      WHERE  S1.Sdept = S2.Sdept  AND
                      S2.Sname = '刘晨';
```

**能用嵌套不要用连接**

```sql
[例 3.56]查询选修了课程名为“信息系统”的学生学号和姓名
 	SELECT Sno,Sname                 #③ 最后在Student关系中
  	FROM    Student                         # 取出Sno和Sname
 	WHERE Sno  IN
             (SELECT Sno                     #② 然后在SC关系中找出选
              FROM    SC                         #修了3号课程的学生学号
              WHERE  Cno IN
                     (SELECT Cno            # ① 首先在Course关系中找出
                       FROM Course           #“信息系统”的课程号，为3号
                       WHERE Cname= '信息系统'                      
		          )
              );
```

**2.带比较算符的子查询**

>  当能确切知道内层查询返回单值时，可用比较运算符（>，<，=，>=，<=，!=或< >）。

```sql
[例 3.57 ]找出每个学生超过他选修课程平均成绩的课程号。
   SELECT Sno, Cno
    FROM    SC  x#外层循环  x元组
    WHERE Grade >=(SELECT AVG（Grade） 
		                        FROM  SC y#内层循环   y元组
                                   WHERE y.Sno=x.Sno);
```

  **3.带有ANY（SOME）或ALL谓词的子查询**

> 使用ANY或ALL谓词时必须同时使用比较运算
>
> **语义为：**
>
> **> ANY** **大于子查询结果中的某个值**    
>
> **> ALL** **大于子查询结果中的所有值**
>
> **< ANY** **小于子查询结果中的某个值**  
>
> **< ALL** **小于子查询结果中的所有值**
>
> **>= ANY** **大于等于子查询结果中的某个值**  
>
> **>= ALL** **大于等于子查询结果中的所有值**

```sql
[例 3.58]  查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄
    SELECT Sname,Sage
    FROM    Student
    WHERE Sage < ANY (SELECT  Sage
                      FROM    Student
                      WHERE Sdept= ' CS ')
     AND Sdept <> 'CS' ;   #不等于'CS'        /*父查询块中的条件 */
```

  **4.带有EXISTS谓词的子查询**

> - 存在量词 ∃
> - 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。
>   若内层查询结果非空，则外层的WHERE子句返回真值
>   若内层查询结果为空，则外层的WHERE子句返回假值
> - 由EXISTS引出的子查询，其目标列表达式通常都用 * ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义。
> - NOT EXISTS谓词
>   - 若内层查询结果非空，则外层的WHERE子句返回假值
>   - 若内层查询结果为空，则外层的WHERE子句返回真值

```sql
[例 3.60]查询所有选修了1号课程的学生姓名。
     SELECT Sname
     FROM Student
     WHERE EXISTS
                   (SELECT *
                    FROM SC
                    WHERE Sno=Student.Sno AND Cno= ' 1 ');
```

```sql
[例 3.61]  查询没有选修1号课程的学生姓名。
     SELECT Sname
     FROM     Student
     WHERE NOT EXISTS
                   (SELECT *
                    FROM SC
                    WHERE Sno = Student.Sno AND Cno='1');
```

> -   不同形式的查询间的替换
>   - 一些带**EXISTS**或**NOT** **EXISTS**谓词的子查询**不能**被其他形式的子查询等价替换
>   - 所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带**EXISTS**谓词的子查询等价替换

 **用EXISTS/NOT EXISTS实现全称量词（难点）***选学

![image-20211007114159744](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110071142987.png/)

```sql
[例 3.62] 查询选修了全部课程的学生姓名。(不存在这样的课,where学生没选的课)
        SELECT Sname
        FROM Student
        WHERE NOT EXISTS
                      (SELECT *
                        FROM Course
                        WHERE NOT EXISTS
                                      (SELECT *
                                       FROM SC
                                       WHERE Sno= Student.Sno
                                             AND Cno= Course.Cno
                                      )
                       );
```

> 应用:这个人干了另一个人干的所有事

### 3.4.4 集合查询

> 集合操作的种类
>
> - 并操作UNION
> - 交操作INTERSECT
> - 差操作EXCEPT
>
> 参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 

```sql
[例 3.65]  查询选修了课程1或者选修了课程2的学生。
        SELECT Sno
        FROM SC
        WHERE Cno=' 1 '
        UNION
        SELECT Sno
        FROM SC
        WHERE Cno= ' 2 ';
```

```sql
[例3.66]  查询计算机科学系的学生与年龄不大于19岁的学生的交集。
        SELECT *
        FROM Student
        WHERE Sdept='CS' 
        INTERSECT
        SELECT *
        FROM Student
        WHERE Sage<=19 
```

```sql
[例 3.67]查询既选修了课程1又选修了课程2的学生。
         SELECT Sno
        FROM SC
        WHERE Cno=' 1 ' 
        INTERSECT
        SELECT Sno
        FROM SC
        WHERE Cno='2 ';
```

```sql
[例 3.68]  查询计算机科学系的学生与年龄不大于19岁的学生的差集。
        SELECT *
        FROM Student
        WHERE Sdept='CS'
        EXCEPT
        SELECT  *
        FROM Student
        WHERE Sage <=19;
```

### 3.4.5 基于派生表的查询

> 子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表（Derived Table）成为主查询的查询对象

```sql
[例3.57]找出每个学生超过他自己选修课程平均成绩的课程号
    SELECT Sno, Cno
    FROM SC, (SELECTSno, Avg(Grade) 
              FROM SC
              GROUP BY Sno)
              AS   Avg_sc(avg_sno,avg_grade)
    WHERE SC.Sno = Avg_sc.avg_sno
      and SC.Grade >=Avg_sc.avg_grade
```

### 3.4.6  SELECT语句一般格式

```SQL
 SELECT [ALL|DISTINCT]  
   <目标列表达式> [别名] [ ,<目标列表达式> [别名]] …
 FROM     <表名或视图名> [别名] 
                [ ,<表名或视图名> [别名]] …
                |(<SELECT语句>)[AS]<别名>
 [WHERE <条件表达式>]
 [GROUP BY <列名1>[HAVING<条件表达式>]]
 [ORDER BY <列名2> [ASC|DESC]];
```

```SQL
目标列表达式格式
（1） *
（2） <表名>.*
（3） COUNT([DISTINCT|ALL]* )
（4） [<表名>.]<属性列名表达式>[,<表名>.]<属性列名表达式>]…
```

## 3.5数据更新

### 3.5.1插入数据

两种插入数据方式:

- 插入元祖

```sql
	INSERT
	INTO <表名> [(<属性列1>[,<属性列2 >…)]
	VALUES (<常量1> [,<常量2>]… );
```

```sql
[例3.69]将一个新学生元组（学号：201215128;姓名：陈冬;性别：男;所在系：IS;年龄：18岁）插入到Student表中。

    INSERT
    INTO  Student (Sno,Sname,Ssex,Sdept,Sage)
    VALUES ('201215128','陈冬','男','IS',18);

```

- 插入子查询结果
  - 可以一次插入多个元组

```sql
[例3.72]  对每一个系，求学生的平均年龄，并把结果存入数据库
第一步：建表
      CREATE  TABLE  Dept_age
          ( Sdept     CHAR(15)                     /*系名*/
            Avg_age SMALLINT);          	/*学生平均年龄*/
第二步：插入数据
        INSERT
       INTO  Dept_age(Sdept,Avg_age)
              SELECT  Sdept，AVG(Sage)
              FROM     Student
              GROUP BY Sdept;
```

### 3.5.2修改数据

```sql
    [例3.73]  将学生201215121的年龄改为22岁
         UPDATE  Student
         SET Sage=22
         WHERE  Sno=' 201215121 '; 
```

```sql
      [例3.74]  将所有学生的年龄增加1岁。
	    	 	UPDATE Student
         		SET Sage= Sage+1;
```

```sql
   [例3.75]  将计算机科学系全体学生的成绩置零。
        UPDATE SC
        SET     Grade=0
        WHERE Sno  IN
               (SELETE Sno
                FROM     Student
                WHERE  Sdept= 'CS' );
```

### 3.5.3删除语句

```sql
    [例3.76]  删除学号为201215128的学生记录。
        DELETE
         FROM Student
         WHERE Sno= '201215128 ';
```

```sql
    [例3.78]  删除计算机科学系所有学生的选课记录。
		DELETE
		FROM  SC  
		WHERE  Sno  IN
			(SELETE  Sno
		            FROM   Student
		            WHERE  Sdept= 'CS') ;
```

## 3.6空值处理

空值就是“不知道”或“不存在”或“无意义”的值。
一般有以下几种情况：

- 该属性应该有一个值，但目前不知道它的具体值
- 该属性不应该有值
- 由于某种原因不便于填写

## 3.7视图(重点)

虚表，是从一个或几个基本表（或视图）导出的表,只存放视图的定义，不存放视图对应的数据.基表中的数据发生变化，从视图中查询出的数据也随之改变

### 3.7.1定义视图

#### 基于视图的视图

```sql
 [例3.84]  建立信息系学生的视图。

        CREATE VIEW IS_Student
        AS 
        SELECT Sno,Sname,Sage
        FROM     Student
        WHERE  Sdept= 'IS';
```

```sql
[例3.85]建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 。
         CREATE VIEW IS_Student
        AS 
        SELECT Sno,Sname,Sage
        FROM  Student
        WHERE  Sdept= 'IS'
        WITH CHECK OPTION;
```

```sql
[例3.86]  建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。
        CREATE VIEW IS_S1(Sno,Sname,Grade)
        AS 
        SELECT Student.Sno,Sname,Grade
        FROM  Student,SC
        WHERE  Sdept= 'IS' AND
                       Student.Sno=SC.Sno AND
                       SC.Cno= '1';
```

```sql
	[例3.87]  建立信息系选修了1号课程且成绩在90分以上的学生的视图。
        CREATE VIEW IS_S2
        AS
        SELECT Sno,Sname,Grade
        FROM  IS_S1
        WHERE  Grade>=90;
```

#### 带表达式的视图

```sql
[例3.88]  定义一个反映学生出生年份的视图。
        CREATE  VIEW BT_S(Sno,Sname,Sbirth)
        AS 
        SELECT Sno,Sname,2014-Sage
        FROM  Student;
```

#### 分组视图

```sql
[例3.89]  将学生的学号及平均成绩定义为一个视图
	       CREAT  VIEW S_G(Sno,Gavg)
             AS  
             SELECT Sno,AVG(Grade)
             FROM  SC
             GROUP BY Sno;
```

#### 删除视图

> 该语句从数据字典中删除指定的视图定义
>
> 如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除 
>
> 删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除 

```sql
   [例3.91 ] 删除视图BT_S和IS_S1
		DROP VIEW BT_S;	/*成功执行*/
		DROP VIEW IS_S1;	/*拒绝执行*/
           要删除IS_S1，需使用级联删除：
           DROP VIEW IS_S1 CASCADE;            
```

### 3.7.2查询视图

用户角度：查询视图与查询基本表相同

关系数据库管理系统实现视图查询的方法

**视图消解法**（View Resolution）

- 进行有效性检查
- 转换成等价的对基本表的查询
- 执行修正后的查询

```sql
[例3.92]  在信息系学生的视图中找出年龄小于20岁的学生。
SELECT   Sno,Sage
FROM      IS_Student
WHERE   Sage<20;
视图消解转换后的查询语句为：
 SELECT  Sno,Sage       
 FROM  Student
 WHERE  Sdept= 'IS'  AND  Sage<20;
```

```sql
[例3.93]  查询选修了1号课程的信息系学生
SELECT  IS_Student.Sno,Sname
FROM     IS_Student,SC
WHERE  IS_Student.Sno =SC.Sno AND SC.Cno= '1';
```

**视图消解法的局限**

有些情况下，视图消解法不能生成正确的查询。

```sql
[例3.94]在S_G视图中查询平均成绩在90分以上的学生学号和平均成绩
SELECT *
FROM   S_G
WHERE  Gavg>=90;
       S_G视图的子查询定义： 
            CREATE VIEW S_G (Sno,Gavg)
            AS 
SELECT  Sno,AVG(Grade)
FROM  SC
GROUP BY Sno;
```

### 3.7.3更新视图

```sql
[例3.95]  将信息系学生视图IS_Student中学号”201215122”的学生姓名改为”刘辰”。
UPDATE  IS_Student
SET  Sname= '刘辰'
WHERE  Sno= ' 201215122 ';
转换后的语句：
UPDATE  Student
SET Sname= '刘辰'
WHERE Sno= ' 201215122 ' AND Sdept= 'IS';
```

```sql
[例3.97]删除信息系学生视图IS_Student中学号为”201215129”的记录 
DELETE
FROM IS_Student
WHERE Sno= ' 201215129 ';
转换为对基本表的更新：
DELETE
FROM Student
WHERE Sno= ' 201215129 ' AND Sdept= 'IS';
```

更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新

- 允许对**行列子集视图**进行更新
- 对其他类型视图的更新不同系统有不同限制               

### 3.7.4视图的作用

> - 视图能够简化用户的操作
> - 视图使用户能以多种角度看待同一数据 
> - 视图对重构数据库提供了一定程度的逻辑独立性 
> - 视图能够对机密数据提供安全保护
> - 适当的利用视图可以更清晰的表达查询

## 3.8小结

SQL可以分为**数据定义、数据查询、数据更新、数据控制**四大部分

# 4数据库安全性

##  **问题的提出**

- 数据库的一大特点是数据可以共享
- 数据共享必然带来数据库的安全性问题
- 数据库系统中的数据共享不能是无条件的共享

> 例： 军事秘密、国家机密、新产品实验数据、市场需求分析、市场营销策略、销售计划、客户档案、医疗档案、银行储蓄数据

数据库的**安全性**:保护数据库以防止不合法使用所造成的**数据泄露、更改或破坏** 。

系统**安全保护措施**是否有效是数据库系统主要的**性能指标之一**。

## 4.1数据库安全性概述

### 4.1.1数据库的不安全因素

#### 1.非授权用户对数据库的恶意存取和破坏

> 一些黑客（Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据。

数据库管理系统提供的安全措施主要包括**用户身份鉴别、存取控制和视图等**技术。

#### 2.数据库中重要或敏感的数据被泄露

> 黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。

数据库管理系统提供的主要技术有**强制存取控制、数据加密存储和加密传输等**。

**审计日志分析**

#### 3.安全环境的脆弱性

- 数据库的安全性与计算机系统的安全性紧密联系
  - **计算机硬件、操作系统、网络系统**等的安全性

建立一套**可信（Trusted）计算机系统的概念和标准**

### 4.1.2  安全标准简介

> 1985年美国国防部（DoD）正式颁布《DoD可信计算机系统评估准则》（简称TCSEC或DoD85）
> 不同国家建立在TCSEC概念上的评估准则:
> 欧洲的信息技术安全评估准则（ITSEC）
> 加拿大的可信计算机产品评估准则（CTCPEC） 
> 美国的信息技术安全联邦标准（FC）
>
> 1999年  CC V2.1版被ISO采用为国际标准
> 2001年  CC V2.1版被我国采用为国家标准
> 目前CC已基本取代了TCSEC，成为评估信息产品安全性的主要标准。

#### 四组（division）七个等级

-  D
- C（C1，C2）
- B（B1，B2，B3）
- A（A1）

##### 1.D级:

将一切不符合更高标准的系统均归于D组

> 典型例子：DOS是安全标准为D的操作系统,DOS在安全性方面几乎没有什么专门的机制来保障

##### 2.C1级:

非常初级的自主安全保护,能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。

> 现有的商业系统稍作改进即可满足

##### 3.C2级:

- 安全产品的最低档次
- 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离
- 达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色

> 典型例子
>  Windows 2000
>  Oracle 7

##### 4.B1级

- 标记安全保护。“安全”（Security）或“可信的” （Trusted）产品。
- 对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制

> B1**级典型例子**
>  操作系统:惠普公司的HP-UX BLS release 9.09+ 
>  数据库:
> Oracle公司的Trusted Oracle 7
> Sybase公司的Secure SQL Server version 11.0.6

##### 5.B2级

##### 6.B3级

##### 7.A1级

####  CC

提出国际公认的表述信息技术安全性的结构,把信息产品的安全要求分为

- 安全功能要求
- 安全保证要求

从EAL1至EAL7共分为七级

## 4.2  数据库安全性控制

### **概述**

#### 非法使用数据库的情况

- 编写合法程序**绕过**数据库管理系统及其授权机制
- 直接或编写应用程序**执行非授权操作**(拆解数据字典,升级权限)
- 通过**多次合法查询**数据库从中**推导**出一些保密数据

#### 计算机系统中，安全措施是一级一级层层设置

![计算机系统的安全模型 ](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110141117012.png/)

![数据库管理系统安全性控制模型](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110141119355.png/)

#### 数据库安全性控制的常用方法(重点)

1. 用户标识和鉴定
2. 存取控制
3. 视图
4. 审计
5. 数据加密

### 4.2.1用户身份鉴别

#### 用户身份鉴别

- 系统提供的最外层安全保护措施
- 用户标识：由用户名和用户标识号组成
    （用户标识号在系统整个生命周期内唯一）

**用户身份鉴别的方法**

1. **静态口令鉴别**
   静态口令一般由用户自己设定，这些口令是静态不变的
2. **动态口令鉴别**
   口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法
3. **生物特征鉴别**
   通过生物特征进行认证的技术，生物特征如指纹、虹膜和掌纹等(图像模式识别)
4. **智能卡鉴别**
   智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能

### 4.2.2存取控制

#### 4.2.2.1**存取控制机制组成**

- 定义用户权限，并将用户权限登记到数据字典中
  - 用户对某一数据对象的操作权力称为权限 
  - DBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则 

#### 4.2.2.2**合法权限检查** 

- 用户发出存取数据库操作请求

- DBMS查找数据字典，进行合法权限检查

用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统

#### 4.2.2.3常用存取控制方法

**自主存取控制**（Discretionary Access Control ，简称DAC）

-  C2级
- 用户对不同的数据对象有不同的存取权限
- 不同的用户对同一对象也有不同的权限
- 用户还可将其拥有的存取权限转授给其他用户

**强制存取控制**（Mandatory Access Control，简称 MAC）

- B1级
- 每一个数据对象被标以一定的密级
- 每一个用户也被授予某一个级别的许可证
- 对于任意一个对象，只有具有**合法许可证**的用户才可以存取
- 不认用户,只认许可证

### 4.2.3 自主存取控制方法

通过 SQL 的**GRANT** 语句和**REVOKE** 语句实现

**用户权限组成**

- 数据对象
- 操作类型

定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作

定义存取权限称为**授权** 

**关系数据库系统中存取控制对象** :

| 对象类型       | 对象                                                  | 操  作 类 型                                                 |
| -------------- | :---------------------------------------------------- | ------------------------------------------------------------ |
| 数据库    模式 | 模式                                                  | CREATE  SCHEMA                                               |
| 基本表         | CREATE  TABLE，ALTER  TABLE                           |                                                              |
| 视图           | CREATE  VIEW                                          |                                                              |
| 索引           | CREATE  INDEX                                         |                                                              |
| 数据           | 基本表和视图                                          | SELECT，INSERT，UPDATE，DELETE，REFERENCES，  ALL  PRIVILEGES |
| 属性列         | SELECT，INSERT，UPDATE，  REFERENCES，ALL  PRIVILEGES |                                                              |

### 4.2.4 授权：授予与回收

#### 4.2.4.1GRANT

> 语义：将对指定操作对象的指定操作权限授予指定的用户 

- 发出GRANT：
  - 数据库管理员
  - 数据库对象创建者（即属主Owner）
  - 拥有该权限的用户
- 按受权限的用户 
  - 一个或多个具体用户
  - PUBLIC（即全体用户）  

#### 4.2.4.2WITH GRANT OPTION子句:

- 指定：可以再授予
- 没有指定：不能传播

**不允许循环授权**:

![image-20211014115432685](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110141154800.png/)

通过检测有向图是否存在回路

```sql
 [例4.1] 把查询Student表权限授给用户U1
      GRANT   SELECT 
      ON   TABLE   Student 
      TO   U1;
     #dba/创建者/wgo权限拥有者可以发出该授权
```

```sql
[例4.2] 把对Student表和Course表的全部权限授予用户U2和U3
      GRANT ALL PRIVILIGES 
      ON TABLE Student,Course 
      TO U2,U3;
```

```sql
[例4.3] 把对表SC的查询权限授予所有用户
     GRANT SELECT 
     ON TABLE SC 
	 TO PUBLIC;
```

```sql
[例4.4] 把查询Student表和修改学生学号的权限授给用户U4
	  	GRANT UPDATE(Sno), SELECT 
		ON TABLE Student 
		TO U4;
		#对属性列的授权时必须明确指出相应属性列名 
```

```sql
 [例4.5] 把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户
    GRANT INSERT 
    ON TABLE SC 
    TO U5
    WITH GRANT OPTION;
   # 执行例4.5后，U5不仅拥有了对表SC的INSERT权限，
 #还可以传播此权限：
 [例4.6] GRANT INSERT 
             ON TABLE SC 
             TO U6
             WITH GRANT OPTION;
      #同样，U6还可以将此权限授予U7：
 [例4.7] GRANT INSERT 
	         ON TABLE SC 
             TO U7;
     # 但U7不能再传播此权限。
```

执行了例4.1~例4.7语句后学生-课程数据库中的用户权限定义表: 

| 授权用户名 | 被授权用户名 |   数据库对象名    | 允许的操作类型 | 能否转授权 |
| :--------: | :----------: | :---------------: | :------------: | :--------: |
|    DBA     |      U1      |    关系Student    |     SELECT     |    不能    |
|    DBA     |      U2      |    关系Student    |      ALL       |    不能    |
|    DBA     |      U2      |    关系Course     |      ALL       |    不能    |
|    DBA     |      U3      |    关系Student    |      ALL       |    不能    |
|    DBA     |      U3      |    关系Course     |      ALL       |    不能    |
|    DBA     |    PUBLIC    |      关系SC       |     SELECT     |    不能    |
|    DBA     |      U4      |    关系Student    |     SELECT     |    不能    |
|    DBA     |      U4      | 属性列Student.Sno |     UPDATE     |    不能    |
|    DBA     |      U5      |      关系SC       |     INSERT     |     能     |
|     U5     |      U6      |      关系SC       |     INSERT     |     能     |
|     U6     |      U7      |      关系SC       |     INSERT     |    不能    |

#### 4.2.4.2.REVOKE

授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回

```sql
[例4.8] 把用户U4修改学生学号的权限收回
		REVOKE UPDATE(Sno)
		ON TABLE Student 
		FROM U4;
```

```sql
[例4.9] 收回所有用户对表SC的查询权限
		REVOKE SELECT 
		ON TABLE SC 
		FROM PUBLIC;
```

```sql
[例4.10] 把用户U5对SC表的INSERT权限收回
		REVOKE INSERT 
		ON TABLE SC 
		FROM U5 CASCADE ;
```

​    执行例4.8~4.10语句后学生-课程数据库中的用户权限定义表:

| 授权用户名 | 被授权用户名 | 数据库对象名 | 允许的操作类型 | 能否转授权 |
| :--------: | :----------: | ------------ | :------------: | :--------: |
|    DBA     |      U1      | 关系Student  |     SELECT     |    不能    |
|    DBA     |      U2      | 关系Student  |      ALL       |    不能    |
|    DBA     |      U2      | 关系Course   |      ALL       |    不能    |
|    DBA     |      U3      | 关系Student  |      ALL       |    不能    |
|    DBA     |      U3      | 关系Course   |      ALL       |    不能    |
|    DBA     |      U4      | 关系Student  |     SELECT     |    不能    |

**数据库管理员**：

> - 拥有所有对象的所有权限
> - 根据实际情况不同的权限授予不同的用户

**用户**：

> - 拥有自己建立的对象的全部的操作权限
> - 可以使用GRANT，把权限授予其他用户

**被授权的用户**

> - 如果具有“继续授权”的许可，可以把获得的权限再授予其他用户

*所有授予出去的权力在必要时又都可用REVOKE语句收回*

### 4.2.5 数据库角色(不是通用)

数据库角色：被命名的一组与数据库操作相关的权限(不是所有数据库都有这个)

- 角色是权限的集合 
- 可以为一组具有相同权限的用户创建一个角色
- 简化授权的过程

//

### 4.2.6 强制存取控制方法

自主存取控制缺点:可能存在数据的“无意泄露”

原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记

解决：对系统控制下的所有主客体实施强制存取控制策略
    

#### 强制存取控制（MAC）

- 保证更高程度的安全性
- 用户不能直接感知或进行控制
- 适用于对数据有严格而固定密级分类的部门
  -  军事部门
  -  政府部门

在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类

- **主体**是系统中的活动实体
  -  数据库管理系统所管理的实际用户
  -  代表用户的各进程
- **客体**是系统中的被动实体，受主体操纵
  -  文件、基本表、索引、视图

##### 敏感度标记（Label）

 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）

 敏感度标记分成若干级别

- 绝密（Top Secret，TS）
- 机密（Secret，S）
- 可信（Confidential，C）
- 公开（Public，P）
- TS>=S>=C>=P

主体的敏感度标记称为许可证级别（Clearance Level）

客体的敏感度标记称为密级（Classification Level）

#####  强制存取控制规则

 	（1）仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体
 	
 	（2）仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体

强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。



实现强制存取控制时要首先实现自主存取控制

- 原因：较高安全性级别提供的安全保护要包含较低级别的所有保护

自主存取控制与强制存取控制共同构成数据库管理系统的安全机制

##### DAC+MAC安全检查

![image-20211019090447415](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110190904569.png/)

先进行自主存取控制检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查的数据对象方可存取。

## 4.3  视图机制

- 把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护 
- 间接地实现支持存取谓词的用户权限定义

> 每个学院教学办只能处理自己的学院学生

```sql
[例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明 

         先建立计算机系学生的视图CS_Student
    CREATE VIEW CS_Student
    AS 
    SELECT  *
    FROM   Student
    WHERE  Sdept='CS';
    
    在视图上进一步定义存取权限
     GRANT  SELECT
     ON  CS_Student  
     TO 王平;
     
     GRANT ALL PRIVILIGES
     ON  CS_Student  
     TO  张明; 
```

## 4.4  审计（Audit）

### 什么是审计

启用一个专用的审计日志（Audit Log）,将用户对数据库的所有操作记录在上面

审计员利用审计日志,监控数据库中的各种行为，找出非法存取数据的人、时间和内容

C2以上安全级别的DBMS必须具有审计功能

### 审计功能的可选性

- 审计很费时间和空间
- DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能
- 审计功能主要用于安全性要求较高的部门

### 1.审计事件

- 服务器事件
  - 审计数据库服务器发生的事件
- 系统权限
  - 对系统拥有的结构或模式对象进行操作的审计
  - 要求该操作的权限是通过系统权限获得的
- 语句事件
  - 对SQL语句，如DDL、DML、DQL及DCL语句的审计
- 模式对象事件
  - 对特定模式对象上进行的SELECT或DML操作的审计 	

### 2.审计功能

**基本功能**

- 提供多种审计查阅方式提供多种审计查阅方式
  - 多套审计规则：一般在初始化设定
- 提供审计分析和报表功能
- 审计日志管理功能
  - 防止审计员误删审计记录，审计日志必须先转储后删除
  - 对转储的审计记录文件提供完整性和保密性保护
  - 只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等
- 提供查询审计设置及审计记录信息的专门视图

## 4.5  数据加密

### 1.**数据加密**

- 防止数据库中数据在存储和传输中失密的有效手段

加密的基本思想

- 根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式­—密文（Cipher text）

加密方法

- 存储加密
- 传输加密



### 2.**存储加密**

**透明存储加密**

- 内核级加密保护方式，对用户完全透明
- 将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密
- 数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可

  **内核级加密方法: 性能较好，安全完备性较高**

**非透明存储加密**

- 通过多个加密函数实现



### 3.**传输加密**

- 链路加密
  - 在链路层进行加密
  - 传输信息由报头和报文两部分组成
  - 报文和报头均加密
- 端到端加密
  - 在发送端加密，接收端解密
  - 只加密报文不加密报头
  - 所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息

![image-20211019092837072](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110190928197.png/)

**基于安全套接层协议SSL传输方案的实现思路：**

> （1）确认通信双方端点的可靠性
> 采用基于数字证书的服务器和客户端认证方式，通信时均首先向对方提供己方证书，然后使用本地的CA 信任列表和证书撤销列表对接收到的对方证书进行验证
>
> （2）协商加密算法和密钥
> 确认双方端点的可靠性后，通信双方协商本次会话的加密算法与密钥
>
> （3）可信数据传输
> 业务数据在被发送之前将被用某一组特定的密钥进行加密和消息摘要计算，以密文形式在网络上传输当业务数据被接收的时候，需用相同一组特定的密钥进行解密和摘要计算

## 4.6  其他安全性保护

## 4.7小结

数据的共享日益加强，数据的安全保密越来越重要。
数据库管理系统是管理数据的核心，因而其自身必须具有一整套完整而有效的安全性机制。

实现数据库系统安全性的技术和方法

- 用户身份鉴别
- 存取控制技术：自主存取控制和强制存取控制
- 视图技术
- 审计技术
- 数据加密存储和加密传输

# 6.  关系数据理论(重点)

## 6.1 问题的提出

**关系数据库逻辑设计**

- 针对具体问题，如何构造一个适合于它的数据模式
- 数据库逻辑设计的工具──关系数据库的规范化理论

**关系模式由五部分组成，是一个五元组**：

**R(U, D, DOM, F)**

- 关系名R是符号化的元组语义
- U为一组属性
- D为属性组U中的属性所来自的域
- DOM为属性到域的映射
- F为属性组U上的一组数据依赖

由于D、DOM与模式设计关系不大，因此在本章中把关系模式看作一个三元组：R<U,F>

当且仅当U上的一个关系r满足F时，r称为关系模式R<U,F>的一个关系

==作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于**第一范式（1NF）==**

### 数据依赖

- 是一个关系内部属性与属性之间的一种约束关系
  - 通过属性间值的相等与否体现出来的数据间相互联系
- 是现实世界属性间相互联系的抽象
- 是数据内在的性质
- 是语义的体现

### 数据依赖的主要类型

- 函数依赖（Functional Dependency，简记为FD）
- 多值依赖（Multi-Valued Dependency，简记为MVD）

### 函数依赖普遍存在于现实生活中

> 描述一个学生关系，可以有学号、姓名、系名等属性。
>
> 一个学号只对应一个学生，一个学生只在一个系中学习
>
> **“学号”值确定后，学生的姓名及所在系的值就被唯一确定。**

Sname=f(Sno)，Sdept=f(Sno)

​	即Sno函数决定Sname

​	Sno函数决定Sdept

​	记作Sno→Sname，Sno→Sdept

**[例6.1] 建立一个描述学校教务的数据库。涉及的对象包括：**	

> - 学生的学号（Sno）
>
> - 所在系（Sdept）
>
> - 系主任姓名（Mname）
>
> - 课程号（Cno）
>
> - 成绩（Grade）

假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：
    *U ＝{Sno, Sdept, Mname, Cno, Grade}*  

现实世界的已知事实（语义）：

> 一个系有若干学生， 但一个学生只属于一个系；
>
> 一个系只有一名（正职）负责人；
>
> 一个学生可以选修多门课程，每门课程有若干学生选修；
>
> 每个学生学习每一门课程有一个成绩。   

由此可得到属性组U上的一组函数依赖F：

​       *F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}*

![image-20211019100727737](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110191007856.png/)

### 关系模式Student<U, F>中存在的问题：

#### （1）数据冗余

浪费大量的存储空间

每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。

#### （2）更新异常（Update Anomalies）

数据冗余 ，更新数据时，维护数据完整性代价大。

某系更换系主任后，必须修改与该系学生有关的每一个元组。

#### （3）插入异常（Insertion Anomalies）

如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。

#### （4）删除异常（Deletion Anomalies）

如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。

#### 结论:

Student关系模式不是一个好的模式。

一个“好”的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。

#### 原因:

由存在于模式中的某些数据依赖引起的。

#### 解决方法:

用规范化理论改造关系模式来消除其中不合适的数据依赖

### 把这个单一的模式分成三个关系模式：模式分解

> S(Sno,Sdept,Sno → Sdept);
>
> SC(Sno,Cno,Grade,(Sno,Cno) → Grade);
>
> DEPT(Sdept,Mname,Sdept → Mname);

这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。

## 6.2 规范化(定义不考,会用理解判断即可)

### 6.2.1  函数依赖

### 6.2.1.1**函数依赖**

**定义6.1**  设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。

> [例] Student(Sno, Sname, Ssex, Sage, Sdept),         
>     假设不允许重名，则有:
> 	Sno → Ssex，      Sno → Sage
> 	Sno → Sdept，    Sno ←→ Sname
> 	Sname → Ssex， Sname → Sage
> 	Sname → Sdept
> 但Ssex →Sage, Ssex→ Sdept
>
> <img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260900069.png/" alt="image-20211026085856300" style="zoom:33%;" />

违背:

![image-20211026085951088](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260859263.png/)

#### 6.2.1.2平凡函数依赖与非平凡函数依赖

> X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。
> X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。

#### 6.2.1.3完全函数依赖与部分函数依赖

![](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260907872.png/)

> ![image-20211026090627260](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260906434.png/)

#### 6.2.1.4传递函数依赖

![image-20211026090712735](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260907957.png/)

> [例] 在关系Std(Sno, Sdept, Mname)中，有：
> Sno → Sdept，Sdept → Mname，
> Mname传递函数依赖于Sno

### 6.2.2  码

![image-20211026091041055](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260910358.png/)

若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key)。

**主属性与非主属性**

- 包含在任何一个候选码中的属性 ，称为主属性          （Prime attribute） 
- 不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute） 

> [例6.2]S(Sno, Sdept, Sage)，单个属性**Sno**是码
> 	         SC(Sno, Cno, Grade)中，**(Sno, Cno)**是码
>
> [例6.3] R(P,W,A) P：演奏者     W：作品    A：听众
> 		一个演奏者可以演奏多个作品
> 		某一作品可被多个演奏者演奏
> 		听众可以欣赏不同演奏者的不同作品 
> 		码为(P,W,A)，即All-Key 

**定义6.5**  关系模式 R中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。

主码与外部码一起提供了表示关系间联系的手段

### 6.2.3  范式(要求:判断第几范式)

**范式的种类：**			

- 第一范式(1NF)
- 第二范式(2NF)
- 第三范式(3NF)
- BC范式(BCNF)
- 第四范式(4NF)
- 第五范式(5NF)

范式是符合某一种级别的关系模式的集合。

各种范式之间存在联系：

![image-20211026091812883](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260918006.png/)

某一关系模式R为第n范式，可简记为R∈nNF。

一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。

![image-20211026091831318](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260918467.png/)

## 6.2.4  2NF

定义6.6  **若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于 任何 一个候选码**，则R∈2NF

> [例6.4]  S-L-C(Sno,Sdept,Sloc,Cno,Grade)， Sloc为学生的住处，并且每个系的学生住在同一个地方。S-L-C的码为(Sno,Cno)。
>
> ![image-20211026092252091](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260922341.png/)

**一个关系模式不属于2NF，会产生以下问题：**

> **插入异常**:
>
> 如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。
>
> **删除异常**:
>
> 如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。
>
> **修改复杂**:
>
> 如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。

**出现这种问题的原因**
例子中有两类非主属性：

一类如Grade，它对码完全函数依赖
另一类如Sdept、Sloc，它们对码不是完全函数依赖

**解决方法：**
用投影分解把关系模式S-L-C分解成两个关系模式
**SC(Sno,Cno,Grade)**    2nf
**S-L(Sno,Sdept,Sloc) **   2nf

### 6.2.5  3NF

定义6.7  设关系模式R<U,F>∈1NF,若R中不存在这样的码X、属性组Y及非主属性Z（Z 不包含于Y）, 使得X→Y，Y→Z成立，Y ↛ X不成立，则称R<U,F> ∈ 3NF。

**分析方法:非主属性对候选码是否存在传递依赖**

![image-20211026094405820](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110260944184.png/)

### 6.2.6  BCNF

BCNF（Boyce Codd Normal Form）由Boyce和Codd提出，比3NF更进了一步。通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。

**定义6.8**  设关系模式R<U,F>∈1NF，若X →Y且Y ⊈ X时X必含有码，则R<U,F>∈BCNF。
换言之，在关系模式R<U,F>中，如果每一个决定属性集都包含候选码，则R∈BCNF。

**BCNF的关系模式所具有的性质**

- 所有非主属性都完全函数依赖于每个候选码
- 所有主属性都完全函数依赖于每个不包含它的候选码
- 没有任何属性完全函数依赖于非码的任何一组属性

如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。

==解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。==

> [例6.7] 关系模式SJP(S,J,P)中，S是学生，J表示 课程，P表示名次。每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一个学生（即没有并列名次）。
>   由语义可得到函数依赖： (S,J)→P；(J,P)→S(S,J)与(J,P)都可以作为候选码。
>   关系模式中没有属性对码传递依赖或部分依赖，所以   
>    SJP∈3NF。
>   除(S,J)与(J,P)以外没有其他决定因素，所以
>    SJP∈BCNF。

> [例6.8] 关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。
>
> -  由语义可得到函数依赖：(S,J)→T；(S,T)→J；T→J
>
> -   因为没有任何非主属性对码传递依赖或部分依赖，STJ∈ 3NF。
>
> -   因为T是决定因素，而T不包含码，所以STJ ∉ BCNF关系。
>
> ![image-20211026100454934](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110261004093.png/)

非BCNF的关系模式也可以通过分解成为BCNF。例如STJ可分解为ST(S,T)与TJ(T,J)，它们都是BCNF。

**3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。**

- 一个模式中的关系模式如果都属于BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常。
- 3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。

### 6.2.7  多值依赖(选学)

### 6.2.8  4NF(选学)

### 6.2.9  规范化小结

- 在关系数据库中，对关系模式的基本要求是满足第一范式。
- 规范化程度过低的关系不一定能够很好地描述现实世界
  - 可能存在插入异常、删除异常、修改复杂、数据冗余等问题
  - 解决方法就是对其进行规范化，转换成高级范式。

**规范化的基本思想**

- 是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的“分离”。
- 即采用“一事一地”的模式设计原则
  - 让一个关系描述一个概念、一个实体或者实体间的一种联系。
  - 若多于一个概念就把它“分离”出去。
- 因此 规范化实质上是概念的单一化。

![image-20211026101436446](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110261014756.png/)

**能判断是第几范式,根据应用确定使用第几范式**

## 6.3 数据依赖的公理系统

# 第七章  数据库设计(重点)(预习)

## 7.1  数据库设计概述

**数据库设计**

- 数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库**逻辑模式**和**物理结构**，并据此建立数据库及其**应用系统**，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。
- 信息管理要求：在数据库中应该存储和管理哪些数据对象 。
- 数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。 

**数据库设计的目标**:

是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境 。

- 高效率的运行环境
  - 数据库数据的**存取效率高**
  - 数据库存储空间的**利用率高**
  - 数据库系统运行**管理的效率高**

### 7.1.1数据库设计的特点

#### 1.数据库建设的基本规律

- 三分技术，七分管理，十二分基础数据 

- 管理 
  - 数据库建设项目管理 
  - 企业（即应用部门）的业务管理 
- 基础数据  
  - 数据的收集、整理、组织和不断更新

#### 2.结构（数据）设计和行为（处理）设计相结合 

- 将数据库结构设计和数据处理设计密切结合

**结构和行为分离的设计**

- 传统的软件工程：重 行为设计
  - 忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策
- 早期的数据库设计：重 结构设计
  - 致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响

![image-20211028110037129](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281100302.png/)

### 7.1.2  数据库设计方法

大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。

它要求多方面的知识和技术。主要包括：

- 计算机的基础知识
- 软件工程的原理和方法
- 程序设计的方法和技巧
- 数据库的基本知识
- 数据库设计技术
- 应用领域的知识

**法一.手工试凑法**

- 设计质量与设计人员的经验和水平有直接关系
- 缺乏科学理论和工程方法的支持，工程的质量难以保证
- 数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价

**法二.规范设计法**

- 手工设计方法
- 基本思想
  - 过程迭代和逐步求精
- 典型方法
  - 新奥尔良（New Orleans）方法
  - 基于E-R模型的数据库设计方法-----常用
  - 3NF（第三范式）的设计方法------常用   3范式足矣,正好在中间
  - 面向对象的数据库设计方法
  - 统一建模语言（UML）方法

### 7.1.3  数据库设计的基本步骤

**数据库设计分6个阶段**

- 需求分析
- 概念结构设计
- 逻辑结构设计----------逻辑设计和物理设计与选用的数据库管理系统密切相关
- 物理结构设计----------逻辑设计和物理设计与选用的数据库管理系统密切相关
- 数据库实施
- 数据库运行和维护 

需求分析和概念设计独立于任何数据库管理系统 

![image-20211028110247898](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281102289.png/)

**参加数据库设计的人员**

- 系统分析人员和数据库设计人员
  - 自始至终参与数据库设计，其水平决定了数据库系统的质量
- 数据库管理员和用户代表
  - 主要参加需求分析与数据库的运行和维护
- 应用开发人员
  - 包括程序员和操作员
  - 在实施阶段参与进来，分别负责编制程序和准备软硬件环境

1.**需求分析阶段**

- 是否做得充分与准确，决定了构建数据库的速度和质量

2.**概念结构设计阶段**

- 通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型

3.**逻辑结构设计阶段**

- 将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化

4.**物理结构设计阶段**

- 为逻辑数据结构选取一个最适合应用环境的物理结构
- 包括存储结构和存取方法

5.**数据库实施阶段**

- 根据逻辑设计和物理设计的结果构建数据库
- 编写与调试应用程序
- 组织数据入库并进行试运行

6.**数据库运行和维护阶段**

- 经过试运行后即可投入正式运行
- 在运行过程中必须不断对其进行评估、调整与修改

设计一个完善的数据库应用系统 往往是上述6个阶段的不断反复

这个设计步骤既是数据库设计的过程，也包括了数据库应用系统的设计过程

把数据库的设计和对数据库中数据处理的设计紧密结合起来，将这两个方面的需求分析、抽象、设计、实现在各个阶段同时进行，相互参照，相互补充，以完善两方面的设计

![image-20211028110538967](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281105178.png/)



### 7.1.4  数据库设计过程中的各级模式

数据库设计不同阶段形成的数据库各级模式

![image-20211028110603842](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281106098.png/)



## 7.2  需求分析

### 7.2.1  需求分析的任务



### 7.2.2  需求分析的方法

![image-20211028111933282](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281119465.png/)

### 7.2.3  数据字典

**数据字典的内容**

- 数据项
- 数据结构
- 数据流
- 数据存储
- 处理过程

#### 1.数据项

 数据项是不可再分的数据单位

 **对数据项的描述**

```
	数据项描述={数据项名,数据项含义说明,别名,
                          数据类型,长度,取值范围,取值含义,
                          与其他数据项的逻辑关系,
                          数据项之间的联系}
```

数据项名:学号

#### 2.数据结构

数据结构反映了数据之间的组合关系。
 一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。

#### 5. 处理过程

处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息

## **7.3  概念结构设计**

### 7.3.1 概念模型

将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计

**用户需求**---------->**信息结构**

**概念模型的特点**

（1）能真实、充分地反映现实世界，是现实世界的一个真实模型。
（2）易于理解，从而可以用它和不熟悉计算机的用户交换意见。
（3）易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。
（4）易于向关系、网状、层次等各种数据模型转换

**描述概念模型的工具**

- E-R模型

### 7.3.2  E-R模型

#### 1.实体之间的联系

##### （1）两个实体型之间的联系：

1. 一对一联系（1∶1）
2. 一对多联系（1∶n）
3. 多对多联系（m∶n）

> ①一对一联系（1∶1）
> 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1∶1。
> 例如，学校里一个班级只有一个正班长，而一个班长只在一个班中任职，则班级与班长之间具有一对一联系。
>
> ②一对多联系（1∶n）
> 如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1∶n。
> 例如，一个班级中有若干名学生，而每个学生只在一个班级中学习，则班级与学生之间具有一对多联系。
>
> ③多对多联系（m∶n）
> 如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体集B具有多对多联系，记为m∶n。
> 例如，一门课程同时有若干个学生选修，而一个学生可以同时选修多门课程，则课程与学生之间具有多对多联系。

##### （2）两个以上的实体型之间的联系

> 一般地，两个以上的实体型之间也存在着一对一、一对多、多对多联系。
> 对于课程、教师与参考书3个实体型，如果一门课程可以有若干个教师讲授，使用若干本参考书，而每一个教师只讲授一门课程，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系是一对多的，如图7.7(a)所示。
>
> ![image-20211028113839644](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281138921.png/)

（3）单个实体型内的联系

> 同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系。
> 例如，职工实体型内部具有领导与被领导的联系，即某一职工（干部）“领导”若干名职工，而一个职工仅被另外一个职工直接领导，因此这是一对多的联系，如图7.8所示。
>
> ![image-20211028113955542](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281139741.png/)

#### 2. E-R图

E-R图提供了表示实体型、属性和联系的方法：

- **实体型**：用矩形表示，矩形框内写明实体名。
- **属性**：用椭圆形表示，并用无向边将其与相应的实体型连接起来。

> 例如，学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E-R图表示如图7.9所示

![image-20211028114104342](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281141691.png/)

- **联系**：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1∶1，1∶n或m∶n）。

联系可以具有属性

![image-20211028114318477](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281143161.png/)

#### 3.一个实例

- 某个工厂物资管理的概念模型。物资管理涉及的实体有：
  - 仓库：属性有仓库号、面积、电话号码
  - 零件：属性有零件号、名称、规格、单价、描述
  - 供应商：属性有供应商号、姓名、地址、电话号码、账号
  - 项目：属性有项目号、预算、开工日期
  - 职工：属性有职工号、姓名、年龄、职称

**这些实体之间的联系如下：** 
 （1） 一个仓库可以存放多种零件，一种零件可以存放在多个 仓库中，因此仓库和零件具有多对多的联系。用库存量 来表示某种零件在某个仓库中的数量

（2） 一个仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，因此仓库和职工之间是一对多的联系。

（3） 职工之间具有领导与被领导关系。即仓库主任领导若干保管员，因此职工实体型中具有一对多的联系。

（4） 供应商、项目和零件三者之间具有多对多的联系。即一 个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同供应商供给。

![image-20211028114444772](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281144191.png/)

![image-20211028114707291](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281147629.png/)

![image-20211028114729664](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281147000.png/)

### 7.3.5    概念结构设计

**实体与属性的划分原则**

为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待。

**两条准则**：

（1）作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。
（2）属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。

> [例1] 职工是一个实体，职工号、姓名、年龄是职工的属性。
>
> - 职称如果没有与工资、福利挂钩，根据准则（1）可以作为职工实体的属性
> - 如果不同的职称有不同的工资、住房标准和不同的附加福利，则职称作为一个实体更恰当
>
> ![image-20211028115330792](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281153975.png/)

> [例2] 在医院中，一个病人只能住在一个病房，病房号可以作为病人实体的一个属性；
>     如果病房还要与医生实体发生联系，即一个医生负责几个病房的病人的医疗工作，则根据准则（2） 病房应作为一个实体。
>
> ![image-20211028115605929](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281156214.png/)

#### 2. E-R图的集成

E-R图的集成一般需要分两步

-  合并。解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图。
-  修改和重构。消除不必要的冗余，生成基本E-R图。

![image-20211028115804759](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110281158112.png/)

##### （1）合并E-R图，生成初步E-R图

各个局部应用所面向的问题不同，各个子系统的E-R图之间必定会存在许多不一致的地方，称之为冲突。
子系统E-R图之间的冲突主要有三类：

1. 属性冲突
2. 命名冲突
3. 结构冲突

> ①属性冲突
> 属性域冲突，即属性值的类型、取值范围或取值集合不同。
> 例如零件号，有的部门把它定义为整数，有的部门把它定义为字符型。
> 年龄，某些部门以出生日期形式表示职工的年龄，而另一些部门用整数表示职工的年龄。
> 属性取值单位冲突。
> 例如，零件的重量有的以公斤为单位，有的以斤为单位，有的以克为单位。
>
> ②命名冲突
> 同名异义，即不同意义的对象在不同的局部应用中具有相同的名字。
> 异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字。
> 如对科研项目，财务科称为项目，科研处称为课题，生产管理处称为工程。
> 命名冲突
> 可能发生在实体、联系一级上
> 也可能发生在属性一级上
> 通过讨论、协商等行政手段加以解决
>
> ③结构冲突
>
> - 同一对象在不同应用中具有不同的抽象。
>
> 例如，职工在某一局部应用中被当作实体，而在另一局部应用中则被当作属性。
>
> 解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。
>
> - 同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同。
>
> 解决方法：使该实体的属性取各子系统的E-R图中属性的并集，再适当调整属性的次序。
>
> - 实体间的联系在不同的E-R图中为不同的类型。
>
> 实体E1与E2在一个E-R图中是多对多联系，在另一个E-R图中是一对多联系
>
> 解决方法是根据应用的语义对实体联系的类型进行综合或调整。

##### （2）消除不必要的冗余，设计基本E-R图

1.**人工分析**

- 所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。
- 消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。

**2.用规范化理论来消除冗余**

## 7.4  逻辑结构设计

### 逻辑结构设计的任务

把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构

### 7.4.1  E-R图向关系模型的转换

#### 转换内容

E-R图由**实体型**、**实体的属性**和**实体型之间的联系**三个要素组成
关系模型的逻辑结构是一组关系模式的集合
将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式

#### 转换原则

1.一个实体型转换为一个关系模式。

关系的属性：**实体的属性**

关系的码：**实体的码**

2.实体型间的联系有以下不同情况

（1） *一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。*

① **转换为一个独立的关系模式**

- 关系的属性：与该联系相连的各实体的码以及联系本身的属性
- 关系的候选码：每个实体的码均是该关系的候选码

②**与某一端实体对应的关系模式合并**

- 合并后关系的属性：加入对应关系的码和联系本身的属性
- 合并后关系的码：不变

（2）*一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。*

①**转换为一个独立的关系模式**

- 关系的属性：与该联系相连的各实体的码以及联系本身的属性
- 关系的码：n端实体的码

②**与n端对应的关系模式合并**--减少表的个数

- 合并后关系的属性：在n端关系中加入1端关系的码和联系本身的属性
- 合并后关系的码：不变
- 可以减少系统中的关系个数，一般情况下更倾向于采用这种方法

（3）*一个m:n联系转换为一个关系模式*

- 关系的属性：与该联系相连的各实体的码以及联系本身的属性
- 关系的码：各实体码的组合  

> (Sno,Cno)决定某个课的成绩

（4）*三个或三个以上实体间的一个多元联系转换为一个关系模式*

- 关系的属性：与该多元联系相连的各实体的码以及联系本身的属性
- 关系的码：各实体码的组合

（5）*具有相同码的关系模式可合并*

- 目的：**减少系统中的关系个数**

- 合并方法：

   将其中一个关系模式的全部属性加入到另一个关系模式中,然后去掉其中的同义属性（可能同名也可能不同名）,适当调整属性的次序

![image-20211102090705595](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111020907703.png/)

> 部门（部门号，部门名，经理的职工号，…）
> 职工（职工号、部门号，职工名，职务，…）
> 产品（产品号，产品名，产品组长的职工号，…）
> 供应商（供应商号，姓名，…）
> 零件（零件号，零件名，…）
> 职工工作（职工号，产品号，工作天数，…）
> 供应（产品号，供应商号，零件号，供应量）



### 7.4.2  数据模型的优化

一般的数据模型还需要向特定数据库管理系统规定的模型进行转换。

转换的主要依据是所选用的数据库管理系统的功能及限制。没有通用规则。

对于关系模型来说，这种转换通常都比较简单。

数据库逻辑设计的结果不是唯一的。

得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。

关系数据模型的优化通常以规范化理论为指导。

#### 优化数据模型的方法:

（1）确定数据依赖

按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖。

（2）对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。

（3）按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。

（4）按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。

（5）对关系模式进行必要分解，提高数据操作效率和存储空间的利用率。

**常用分解方法**

- *水平分解*
  - 什么是水平分解
    把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以**提高系统的效率**。
  - 如何分解
    对符合80/20的，把经常被使用的数据（约20%）
    水平分解出来，形成一个子关系。
    水平分解为若干子关系，使每个事务存取的数据对应一个子关系。
- *垂直分解*
  - 什么是垂直分解
    把关系模式R的属性分解为若干子集合，形成若干子关系模式。
  - 垂直分解的原则
    经常在一起使用的属性从R中分解出来形成一个子关系模式
  - 垂直分解的优点
    可以**提高某些事务的效率**
  - 垂直分解的缺点
    可能使另一些事务**不得不执行连接操作，降低了效率**

### 7.4.3  设计用户子模式

定义数据库模式主要是从**系统的时间效率**、**空间效率**、**易维护**等角度出发。

定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：

（1）使用更符合用户习惯的别名

合并各分E-R图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的。

用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用。

（2）针对不同级别的用户定义不同的视图，以保证系统的安全性。
假设有关系模式产品（产品号，产品名，规格，单价，生产车间，生产负责人，产品成本，产品合格率，质量等级），可以在产品关系上建立两个视图：

- 为一般顾客建立视图：产品1（产品号，产品名，规格，单价）
- 为产品销售部门建立视图： 产品2（产品号，产品名，规格，单价，车间，生产负责人）

（3）简化用户对系统的使用
如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图。

## 7.5  物理结构设计

**什么是数据库的物理设计**

数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。
为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。

**数据库物理设计的步骤**

- 确定数据库的物理结构
  - 在关系数据库中主要指存取方法和存储结构;
- 对物理结构进行评价
  - 评价的重点是时间和空间效率
- 若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。

### 7.5.1  数据库物理设计的内容和方法

**设计物理数据库结构的准备工作**

- 充分了解应用环境，详细分析要运行的事务，以获得选择物理数据库设计所需参数。
- 充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构。

**选择物理数据库设计所需参数**

-  数据库查询事务
  - 查询的关系
  - 查询条件所涉及的属性
  - 连接条件所涉及的属性
  - 查询的投影属性
- 数据更新事务
  - 被更新的关系
  - 每个关系上的更新操作条件所涉及的属性
  - 修改操作要改变的属性值
-  每个事务在各关系上运行的频率和性能要求

**关系数据库物理设计的内容**

- 为关系模式选择存取方法（建立存取路径）
- 设计关系、索引等数据库文件的物理存储结构



### 7.5.2  关系模式存取方法选择

**数据库管理系统常用存取方法**

1. B+树索引存取方法
2. Hash索引存取方法
3. 聚簇存取方法

**选择索引存取方法的一般规则**----调高连接效率

- 如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）

- 如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引

- 如果一个（或一组）属性*经常在连接操作的连接条件*中 出现，则考虑在这个（或这组）属性上建立索引

  **关系上定义的索引数过多会带来较多的额外开销**

  -  **维护**索引的开销
  -  **查找**索引的开销

**选择Hash存取方法的规则**---键值对

如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一

- 该关系的大小可预知，而且不变； 
- 该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。

**什么是聚簇**---针对磁盘而不是固态盘  聚簇码相同扎堆存放

为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。

- 该属性（或属性组）称为聚簇码（cluster key）
- 许多关系型数据库管理系统都提供了聚簇功能
- 聚簇存放与聚簇索引的区别

**聚簇索引**---极力避免修改操作

- 建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中元组的物理顺序一致。
- 在一个基本表上最多只能建立一个聚簇索引

**聚簇索引的适用条件**

-  *很少对基表进行增删操作*,涉及到大量元组搬动
-  *很少对其中的变长列进行修改操作* 

**聚簇的用途**

对于某些类型的查询，可以提高查询效率

1. 大大提高按聚簇属性进行查询的效率

> [例] 假设学生关系按所在系建有索引，现在要查询信息系的所有学生名单。
> 计算机系的500名学生分布在500个不同的物理块上时，至少要执行500次I/O操作。
>
> 如果将同一系的学生元组集中存放，则每读一个物理块可得到多个满足查询条件的元组，从而显著地减少了访问磁盘的次数。

2. 节省存储空间
聚簇以后，聚簇码相同的元组集中在一起了，因而聚簇码值不必在每个元组中重复存储，只要在一组中存一次就行了。

**聚簇的局限性**

-  聚簇只能提高某些特定应用的性能
-  建立与维护聚簇的开销相当大
  - 对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的索引无效，必须重建。
  - 当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变。

聚簇的适用范围
既适用于单个关系独立聚簇，也适用于多个关系组合聚簇
 当通过聚簇码进行访问或连接是该关系的主要应用，与聚
    簇码无关的其他访问很少或者是次要的时，可以使用聚簇
尤其当SQL语句中包含有与聚簇码有关的ORDER BY, GROUP BY, UNION, DISTINCT等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作

### 7.5.3  确定数据库的存储结构

确定数据库物理结构主要指确定数据的**存放位置**和**存储结构**，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等。

确定数据的存放位置和存储结构要综合考虑**存取时间**、**存储空间利用率**和**维护代价**3个方面的因素。

**影响数据存放位置和存储结构的因素**

- *硬件环境*
- *应用需求*
  - 存取时间
  - 存储空间利用率
  - 维护代价

这三个方面常常是相互矛盾的

**基本原则**

- 根据应用情况将
  - 易变部分与稳定部分分开存放
  - 经常存取部分与存取频率较低部分分开存放

> [例]
> 可以将比较大的表分别放在两个磁盘上，以加快存取速度，这在多用户环境下特别有效。
>
> 可以将日志文件与数据库对象（表、索引等）放在不同的磁盘以改进系统的性能。

**数据库管理系统一般都提供了一些存储分配参数**

- 同时使用数据库的用户数
- 同时打开的数据库对象数
- 内存分配参数
- 缓冲区分配参数（使用的缓冲区长度、个数）
- 存储分配参数 
- 物理块的大小
- 物理块装填因子
- 时间片大小
- 数据库的大小
- 锁的数目等

系统都为这些变量赋予了合理的缺省值。

在进行物理设计时需要*根据应用环境确定这些参数值*，以*使系统性能最优*。

在物理设计时对系统配置变量的调整只是初步的，要根据系统实际运行情况做进一步的调整，以切实改进系统性能。

### 7.5.4  评价物理结构

对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。

**评价方法**

- 定量估算各种方案
  -  *存储空间*
  -  *存取时间*
  -  *维护代价*
- 对估算结果进行权衡、比较，选择出一个较优的合理的物理结构。

## 7.6  数据库的实施和维护

### 7.6.1 数据的载入和应用程序的调试

数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。

**数据装载方法**

- 人工方法
- 计算机辅助数据入库

数据库应用程序的设计应该与数据设计并行进行

在组织数据入库的同时还要调试应用程序 

应用程序的设计、编码和调试的方法、步骤在软件工程等课程中有详细讲解，这里就不赘述了 

### 7.6.2 数据库的试运行

应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。

主要工作包括：

- *功能测试*：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能。

- *性能测试*：测量系统的性能指标，分析是否符合设计目标。

**数据的分期入库**

- 重新设计物理结构甚至逻辑结构，会导致数据重新入库

- 由于数据入库工作量实在太大，所以可以采用分期输入数据的方法
  - 先输入小批量数据供先期联合调试使用
  - 待试运行基本合格后再输入大批量数据
  - 逐步增加数据量，逐步完成运行评价

**数据库的转储和恢复**

- 在数据库试运行阶段，系统还不稳定，*硬、软件故障*随时都可能发生
- 系统的操作人员对新系统还不熟悉，*误操作*也不可避免
- 因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏

### 7.6.3 数据库的运行和维护

在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：
1. **数据库的转储和恢复**

- 数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。
- 一旦发生介质故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。

2. **数据库的安全性、完整性控制**

- *初始定义*
  - 数据库管理员根据用户的实际需要授予不同的操作权限
  - 根据应用环境定义不同的完整性约束条件
- *修改定义*
  - 当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制
  - 由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求

3. **数据库性能的监督、分析和改进**

- 在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进系统性能的方法。
- 利用监测工具获取系统运行过程中一系列性能参数的值
- 通过仔细分析这些数据，判断当前系统是否处于最佳运行状态
- 如果不是，则需要通过调整某些参数来进一步改进数据库性能

4. **数据库的重组织与重构造**

（1）数据库的重组织-----磁盘碎片整理

- *为什么要重组织数据库*
  - 数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。

- *重组织的形式*
  - 全部重组织
  - 部分重组织
    - 只对频繁增、删的表进行重组织
- *重组织的目标*
  - 提高系统性能

**重组织的工作**

- *按原设计要求*
  - 重新安排存储位置
  - 回收垃圾
  - 减少指针链

- 数据库的重组织不会改变原设计的数据逻辑结构和物理结构

数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库。

（2）数据库的重构造----通过修修补补使得旧系统满足新需求

- *为什么要进行数据库的重构造*
  - 数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求
    - 增加新的应用或新的实体
    - 取消某些已有应用
    - 改变某些已有应用

**数据库重构造的主要工作**

- *根据新环境调整数据库的模式和内模式*
  - 增加或删除某些数据项
  - 改变数据项的类型
  - 增加或删除某个表
  - 改变数据库的容量
  - 增加或删除某些索引

- ## 7.7  小结

### 数据库的设计过程

需求分析
**概念结构设计**--考试重点
**逻辑结构设计**--考试重点
物理结构设计--小问题
数据库实施--小问题
数据库运行维护
设计过程中往往还会有许多反复

# 10 数据库回复技术

## 10.1  事务的基本概念

### 1.事务

事务(Transaction)是用户定义的一个*数据库操作序列*，这些操作*要么全做，要么全不做*，是一个不可分割的工作单位。类似原语.

*事务和程序是两个概念*

- 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序
- 一个程序通常包含多个事务

**事务**是**恢复**和**并发控制**的基本单位

**显式定义方式**

![image-20211104105930443](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111041059905.png/)

*COMMIT*

- 事务正常结束   
- **提交**事务的所有操作（**读+更新**）
- 事务中所有对数据库的更新写回到磁盘上的物理数据库中



*ROLLBACK*

- 事务异常终止
- 事务运行的过程中发生了故障，不能继续执行
- 系统将事务中对数据库的所有已完成的操作全部撤销 
- 事务滚回到**开始**时的状态

 **隐式方式**

当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务

### 2.事务的ACID特性

#### 事务的ACID特性：

**原子性**（Atomicity）不可拆分

- 事务是数据库的逻辑工作单位
  事务中包括的诸操作要么都做，要么都不做

**一致性**（Consistency）

事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态

*一致性状态*

- 数据库中只包含成功事务提交的结果

*不一致状态*

- 数据库系统运行中发生故障，有些事务尚未完成就被迫中断；
- 这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态 

> `银行转帐`：从帐号A中取出一万元，存入帐号B。
> 定义一个事务，该事务包括两个操作
>
> ![image-20211104110352442](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111041103585.png/)
>
> 这两个操作要么全做，要么全不做
> 全做或者全不做，数据库都处于一致性状态。如果只做一个操作，用户逻辑上就会发生错误，少了一 万元，数据库就处于不一致性状态。

**隔离性**（Isolation）

一个事务的执行不能被其他事务干扰

- 一个事务内部的操作及使用的数据对其他并发事务是隔离的
- 并发执行的各个事务之间不能互相干扰

**持续性**（Durability ）

持续性也称永久性（Permanence）

一个事务一旦提交，它对数据库中数据的改变就应该是`永久性`的。

接下来的其他操作或故障不应该对其执行结果有任何影响。

#### 事务的特性 

保证事务ACID特性是事务处理的任务

**破坏事务ACID特性的因素**

（1） 多个事务并行运行时，`不同事务的操作交叉执行`

- 数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性

（2）事务在`运行过程中被强行停止`

- 数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响 

## 10.2  数据库恢复概述

**故障是不可避免的**

- 计算机硬件故障
- 软件的错误
- 操作员的失误
- 恶意的破坏

**故障的影响**

- 运行事务非正常中断，影响数据库中数据的*正确性* 
- 破坏数据库，全部或部分*丢失数据*

**数据库的恢复**

数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策

*恢复子系统是数据库管理系统的一个重要组成部分* 

*恢复技术是衡量系统优劣的重要指标*



## 10.3  故障的种类

### **1.事务内部的故障**

- 有的是可以通过事务程序本身发现的(见下面转账事务的例子)

```sql
例如，银行转账事务，这个事务把一笔金额从一个账户甲转给另一个账户乙。
     BEGIN TRANSACTION
    	      读账户甲的余额BALANCE;
           BALANCE=BALANCE-AMOUNT;    /*AMOUNT 为转账金额*/
           IF(BALANCE < 0 ) THEN
                 {打印‘金额不足，不能转账’；	                                         /*事务内部可能造成事务被回滚的情况*/
                  ROLLBACK;                        /*撤销刚才的修改，恢复事务*/ 
                 }
           ELSE
                 {读账户乙的余额BALANCE1;
                   BALANCE1=BALANCE1+AMOUNT;
                   写回BALANCE1;
                   COMMIT;}
```

- 有的是非预期的，不能由事务程序处理的。
  - 运算**溢出**
  - 并发事务发生**死锁**而被**选中撤销该事务**
  - 违反了某些完整性限制而被终止等

`今后事务故障仅指这类非预期的故障`

**事务故障意味着**

- 事务*没有*达到*预期的终点*(COMMIT或者显式的ROLLBACK)
- 数据库可能处于`不正确`状态。 

事务故障的恢复：**事务撤消**（UNDO）

- *强行回滚*（ROLLBACK）该事务
- *撤销*该事务已经作出的*任何*对数据库的*修改*，使得该事务象根本没有启动一样

### **2.系统故障**

称为*软故障*，是指造成系统停止运转的任何事件，使得系统要*重新启动*。 

- 整个系统的*正常运行突然被破坏*
- 所有*正在运行的事务都非正常终止*
- *不破坏数据库*
- 内存中数据库*缓冲区*的信息*全部丢失*

**系统故障的常见原因**

- 特定类型的`硬件错误`（如CPU故障）
  - 概率小
- `操作系统故障`
- 数据库管理系统`代码错误`
- 系统`断电`
  - 概率小，大多数服务器都是双电源系统

**系统故障的恢复**：

发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。 
**恢复策略**：

系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务

### **3.介质故障**

称为*硬故障*，指*外存故障*，物理损坏数据库，概率小，危害最大

- 磁盘**损坏**
- 磁头**碰撞**
- 瞬时强**磁场干扰**

介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务 

介质故障比前两类故障的*可能性小得多，但破坏性大得多*

### **4.计算机病毒**
- 一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序
- 可以繁殖和传播，造成对计算机系统包括数据库的危害

**计算机病毒种类**

- 小的病毒只有20条指令，不到50B
- 大的病毒像一个操作系统，由上万条指令组成

**计算机病毒的危害**

- 有的病毒传播很快，一旦侵入系统就马上摧毁系统
- 有的病毒有较长的潜伏期，计算机在感染后数天或数月才开始发病
- 有的病毒感染系统所有的程序和数据
- 有的只对某些特定的程序和数据感兴趣 

计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁 

数据库一旦被破坏仍要用恢复技术把数据库加以恢复

### 4.故障小结

各类故障，对数据库的影响有两种可能性

- 一是**数据库本身被破坏**
- 二是数据库没有被破坏，但**数据可能不正确**，这是由于事务的运行被非正常终止造成的。




## 10.4  恢复的实现技术

**恢复操作的基本原理**：*冗余*

利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据

**恢复的实现技术**：*复杂*

一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上

**恢复机制涉及的关键问题：**

1. *如何建立冗余数据*
  - `数据转储`（backup）
  - `登记日志文件`（logging）
2. *如何利用这些冗余数据实施数据库恢复*

### 10.4.1  数据转储

#### 1.什么是数据转储

转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程

备用的数据文本称为**后备副本**(backup)或**后援副本**



数据库遭到破坏后可以将后备副本重新装入

重装后备副本只能将数据库恢复到转储时的状态

要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务

![image-20211104115109045](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111041151208.png/)

#### 2.转储方法

（1）**静态转储与动态转储**

*静态转储*

- 在系统中无运行事务时进行的转储操作
- 转储开始时数据库处于一致性状态
- 转储期间不允许对数据库的任何存取、修改活动
- 得到的一定是一个数据一致性的副本 
- **优点**：实现简单
- **缺点**：降低了数据库的可用性
  - 转储必须等待正运行的用户事务结束 
  - 新的事务必须等转储结束

*动态转储*

- 转储操作与用户*事务并发进行*
- 转储期间*允许对数据库进行存取或修改*

- **优点**
  - 不用等待正在运行的用户事务结束
  - 不会影响新事务的运行
- **缺点**
  - 不能保证副本中的数据正确有效
  - 例在转储期间的某时刻Tc，系统把数据A=100转储到磁带上，而在下一时刻Td，某一事务将A改为200。
    后备副本上的A过时了

`利用动态转储得到的副本进行故障恢复`

需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件

后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态

（2）**海量转储与增量转储**

**海量转储**: 

每次转储全部数据库

**增量转储**: 

只转储上次转储后更新过的数据

*海量转储与增量转储比较*

- 从`恢复角度`看，使用`海量转储`得到的后备副本进行`恢复往往更方便`
- 如果`数据库很大`，事务处理又十分频繁，则`增量转储方式更实用更有效`

（3）**转储方法小结**

![image-20211104115745120](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111041157241.png/)

### 10.4.2  登记日志文件--比较重要

#### 1.日志文件的格式和内容

**什么是日志文件**

日志文件(log file)是用来记录*事务*对数据库的*更新*操作的文件

##### **日志文件的格式**

###### 以**记录为单位**的日志文件

*以记录为单位的日志文件内容*

- 各个事务的开始标记(BEGIN TRANSACTION)
- 各个事务的结束标记(COMMIT或ROLLBACK)
- 各个事务的所有更新操作

<u>以上均作为日志文件中的一个日志记录 (log  record)</u>



*以记录为单位的日志文件，每条日志记录的内容*

- 事务标识（标明是哪个事务） 
- 操作类型（插入、删除或修改）
- 操作对象（记录ID、Block NO.）
- 更新前数据的旧值（对插入操作而言，此项为空值）
- 更新后数据的新值（对删除操作而言, 此项为空值）



###### 以**数据块为单位**的日志文件

*以数据块为单位的日志文件，每条日志记录的内容*

- 事务标识
- 被更新的数据块

#### 2.日志文件的作用

**用途**

- 进行*事务故障恢复*
- 进行*系统故障恢复*
- 协助后备副本进行*介质故障恢复*

**具体作用**

事务故障恢复和系统故障恢复必须用日志文件。

在动态转储方式中必须建立日志文件，*后备副本*和*日志文件*结合起来才能有效地恢复数据库。



*在静态转储方式中，也可以建立日志文件*

- 当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态
- 利用日志文件，把已完成的事务进行重做处理
- 对故障发生时尚未完成的事务进行撤销处理
- 不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态 

![image-20211104120712968](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111041207072.png/)

#### 3.登记日志文件

**为保证数据库是可恢复的，登记日志文件时必须遵循两条原则**

- 登记的次序严格按并发事务执行的时间次序
- 必须`先写日志文件`，`后写数据库`
  - **写日志文件操作**：把表示这个修改的日志记录写到日志文件中
  - **写数据库操作**：把对数据的修改写到数据库中

**为什么要先写日志文件**

写数据库和写日志文件是两个不同的操作

在这两个操作之间可能发生故障

如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了

如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性

## 10.5  恢复策略



### 10.5.1  事务故障的恢复

**事务故障**：

事务在运行至正常终止点前被终止

**恢复方法**:

由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改

事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预

**事务故障的恢复步骤**:

（1） 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。

（2） 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。

- *插入操作*， “更新前的值”为空，则相当于做删除操作
- *删除操作*，“更新后的值”为空，则相当于做插入操作
- *修改操作*，则相当于用修改前值代替修改后值 

（3） 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。

（4） 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。

### 10.5.2  系统故障的恢复

**系统故障造成数据库不一致状态的原因**

- *未完成事务*对数据库的更新可能*已写入数据库*
- *已提交事务*对数据库的更新可能还留在缓冲区*没来得及写入数据库*

**恢复方法**

1. *Undo 故障发生时未完成的事务*
2. *Redo 已完成的事务*

系统故障的恢复由系统在*重新启动时*自动完成，不需要用户干预

**<u>系统故障的恢复步骤</u>**

（1）**正向扫描日志文件**（即从头扫描日志文件）

- *重做(REDO) 队列*: 在故障发生前已经提交的事务

这些事务既有`BEGIN TRANSACTION`记录，也有`COMMIT`记录

> {}

- *撤销 (UNDO)队列*:故障发生时尚未完成的事务

 这些事务只有`BEGIN TRANSACTION`记录，无相应的~~COMMIT~~记录

> {

（2） **对撤销(UNDO)队列事务进行撤销(UNDO)处理**

*反向*扫描日志文件，对每个撤销事务的更新操作执行*逆操作*

即将日志记录中“更新前的值”写入数据库 

 （3）**对重做(REDO)队列事务进行重做(REDO)处理**

*正向*扫描日志文件，对每个重做事务重新执行登记的操作

即将日志记录中“更新后的值”写入数据库 



### 10.5.3  介质故障的恢复

1.重装数据库

2.重做已完成的事务

**恢复步骤**

（1） 装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。

- 对于静态转储的数据库副本，装入后数据库即处于一致性状态
- 对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。

（2） 装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。

1. 首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。
2. 然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。

**介质故障的恢复需要数据库管理员介入**

*数据库管理员的工作*:

- 重装最近转储的数据库副本和有关的各日志文件副本
- 执行系统提供的恢复命令

具体的恢复操作仍由数据库管理系统完成



## 10.6  具有检查点的恢复技术



### 1.问题的提出

**两个问题**

- *搜索*整个日志将耗费大量的时间
- *重做*处理：重新执行，浪费了大量时间

**具有检查点（checkpoint）的恢复技术**

- 在*日志文件*中增加*检查点记录（checkpoint）*
- 增加重新开始文件
- 恢复子系统在登录日志文件期间动态地维护日志

### 2.检查点技术

**检查点记录的内容**

- 建立检查点时刻所有正在执行的事务清单
- 这些事务最近一个日志记录的地址

**重新开始文件的内容**

记录各个检查点记录在日志文件中的地址

![image-20211109094207732](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111090942849.png/)

**动态维护日志文件的方法**

周期性地执行如下操作：建立检查点，保存数据库状态。

**具体步骤是**：
（1）将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上
（2）在日志文件中写入一个检查点记录
（3）将当前数据缓冲区的所有数据记录写入磁盘的数据库中
（4）把检查点记录在日志文件中的地址写入一个重新开始文件

**建立检查点:**

恢复子系统可以定期或不定期地建立检查点,保存数据库状态 

**定期**

按照预定的一个时间间隔，如每隔一小时建立一个检查点 

**不定期**

按照某种规则，如日志文件已写满一半建立一个检查点

**使用检查点方法可以改善恢复效率**

- 当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库
- 写入时间是在这个检查点建立之前或在这个检查点建立之时 
- 在进行恢复处理时，没有必要对事务T执行重做操作

![image-20211109094806319](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111090948435.png/)

### 3.利用检查点的恢复策略

（1）从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录

（2）由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST

- 建立两个事务队列
  - UNDO-LIST 
  - REDO-LIST 

- 把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。

（3）从检查点开始正向扫描日志文件，直到日志文件结束

- 如有新开始的事务T~i~，把T~i~暂时放入UNDO-LIST队列
- 如有提交的事务T~j~，把T~j~从UNDO-LIST队列移到REDO-LIST队列;直到日志文件结束

（4）对UNDO-LIST中的每个事务执行UNDO操作

​    对REDO-LIST中的每个事务执行REDO操作

## 10.7  数据库镜像



**介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性**

- 介质故障恢复比较费时
- 为预防介质故障，数据库管理员必须周期性地转储数据库

**提高数据库可用性的解决方案**

**数据库镜像（Mirror）**

- 数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上
- 数据库管理系统自动保证镜像数据与主数据的一致性

   每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去

![image-20211109095753853](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111090957942.png/)

**出现介质故障时**

- 可由*镜像磁盘继续提供使用* 
- 同时数据库管理系统自动*利用镜像磁盘数据进行数据库的恢复*
- 不需要关闭系统和重装数据库副本

![image-20211109100131578](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111091001762.png/)

**没有出现故障时**

*可用于并发操作*

一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁 

![image-20211109100140697](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111091001851.png/)

**频繁地复制数据自然会降低系统运行效率**

*在实际应用中用户往往只选择对关键数据和日志文件镜像*

*不是对整个数据库进行镜像*

## 10.8  小结

**事务的概念和性质**

*事务是数据库的逻辑工作单位*

数据库管理系统保证系统中一切事务的*原子性、一致性、隔离性和持续性*，就保证了事务处于一致状态

**故障的种类**

*事务故障*

*系统故障*

*介质故障*

**恢复中最经常使用的技术**

*数据库转储*

*登记日志文件*

**恢复的基本原理**

利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库

**事务**

不仅是*恢复的基本单位*

也是*并发控制的基本单位*

# 11.并发控制

### **多用户数据库系统**

​    允许多个用户**同时**使用的数据库系统-----并发

> - 飞机定票数据库系统
> - 银行数据库系统 
> - 学生数据库管理系统

*特点：在同一时刻并发运行的事务数可达**数百上千个*** 

### **多事务执行方式** 

  *（1）事务串行执行*

- 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
- 不能充分利用系统资源，发挥数据库共享资源的特点

![image-20211111104317019](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111111043203.png/)

*（2）交叉并发方式（Interleaved  Concurrency）*

- 在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行
- 单处理机系统中的并行事务并没有真正地并行运行，但能够`减少处理机的空闲时间`，`提高系统的效率`

![image-20211111104333351](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111111043436.png/)

 *（3）同时并发方式（simultaneous  concurrency）*

- 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行
- `最理想的并发方式，但受制于硬件环境`
- 更复杂的并发方式机制

本章讨论的数据库系统并发控制技术是以**单处理机**系统为基础的 

### **事务并发执行带来的问题**

- 会产生多个事务*同时存取同一数据*的情况 
- 可能会*存取和存储不正确的数据*，破坏*事务隔离性和数据库的一致性*

数据库管理系统必须提供并发控制机制

并发控制机制是衡量一个数据库管理系统是否可用的重要标志之一

## 11.1  并发控制概述

事务是并发控制的基本单位

### **并发控制机制的任务**

- 对并发操作进行*正确调度*
- 保证事务的*隔离性*
- 保证数据库的*一致性*

### **并发操作带来数据的不一致性实例**

> [例11.1]飞机订票系统中的一个活动序列 
>
> ① 甲售票点(事务T1)读出某航班的机票余额A，设A=16；
>
> ② 乙售票点(事务T2)读出同一航班的机票余额A，也为16；
>
> ③ 甲售票点卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库；
>
> ④ 乙售票点也卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库 
>
> 结果明明卖出两张机票，数据库中机票余额只减少1 

这种情况称为数据库的不一致性，是由并发操作引起的。

在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。

若按上面的调度序列执行，T1事务的修改就被丢失。

原因：第4步中T2事务修改A并写回后覆盖了T1事务的修改



### **并发操作带来的数据不一致性**

#### *1.丢失修改（Lost Update）*

两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。

| T1          | T2      |
| ----------- | ------- |
| ①   R(A)=16 |         |
| ②           | R(A)=16 |
| ③   A←A-1   |         |
| W(A)=15     |         |
| ④           | A←A-1   |
|             | W(A)=15 |

#### *2.不可重复读（Non-repeatable Read）*

不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。

**不可重复读包括三种情况**：
（1）事务T1读取某一数据后，事务`T2对其做了修改`，当事务T1再次读该数据时，得到与前一次不同的值 

| T1         | T2       |
| ---------- | -------- |
| ①  R(A)=50 |          |
| R(B)=100   |          |
| 求和=150   |          |
| ②          | R(B)=100 |
|            | B←B*2    |
|            | W(B)=200 |
| ③ R(A)=50  |          |
| R(B)=200   |          |
| 求和=250   |          |
| (验算不对) |          |

（2）事务T1按一定条件从数据库中读取了某些数据记录后，事务`T2删除了其中部分记录`，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。 

（3）事务T1按一定条件从数据库中读取某些数据记录后，事务`T2插入了一些记录`，当T1再次按相同条件读取数据时，发现多了一些记录。
     后两种不可重复读有时也称为幻影现象（Phantom Row）

#### *3.读“脏”数据（Dirty Read）*

   读“脏”数据是指：

事务T1修改某一数据，并将其写回磁盘

事务T2读取同一数据后，T1由于某种原因被撤销

这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致

T2读到的数据就为“脏”数据，即不正确的数据 

| T1         | T2       |
| ---------- | -------- |
| ① R(C)=100 |          |
| C←C*2      |          |
| W(C)=200   |          |
| ②          | R(C)=200 |
| ③ ROLLBACK |          |
| C恢复为100 |          |

**记号**

R(x):读数据x

W(x):写数据x 

**数据不一致性**：

*由于并发操作破坏了事务的隔离性*

并发控制就是要用*正确的方式调度并发操作*，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性 

对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销 



### **并发控制的主要技术**

- **封锁(Locking)**
- 时间戳(Timestamp)
- 乐观控制法
- 多版本并发控制(MVCC)



## 11.2  封锁

### 什么是封锁

封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，`对其加锁`

加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务`不能更新`此数据对象。

封锁是实现并发控制的一个非常重要的技术

### 基本封锁类型

一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。

**基本封锁类型**

1. *排它锁（Exclusive Locks，简记为X锁）*

   若事务T对数据对象A加上X锁，则只允许T读取和修改A，`其它任何事务都不能再对`A加任何类型的锁，直到T释放A上的锁

   保证其他事务在T释放A上的锁之前不能再读取和修改A 

2. *共享锁（Share Locks，简记为S锁）*

   若事务T对数据对象A加上S锁，则事务T`可以读A但不能修改A`，其它事务`只能再对A加S锁`，而不能加X锁，直到T释放A上的S锁

   保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改 

### 锁的相容矩阵

| T1   | X    | S    | _    |
| ---- | ---- | ---- | ---- |
| X    | N    | N    | Y    |
| S    | N    | Y    | Y    |
| _    | Y    | Y    | Y    |

Y=Yes，相容的请求
N=No，不相容的请求

-,不加锁

## 11.3  封锁协议

### **什么是封锁协议**

在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 

- *何时申请X锁或S锁*
- *持锁时间*
- *何时释放*

对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。

#### **三级封锁协议**

*1.一级封锁协议*
事务T在`修改数据R之前必须先对其加X锁`，==直到事务结束才释放==。

- 正常结束（COMMIT）
- 非正常结束（ROLLBACK）

一级封锁协议**可防止丢失修改**，并**保证事务T是可恢复**的。

在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它**不能保证可重复读**和**不读“脏”数据**。

*2.二级封锁协议*
一级封锁协议加上事务T在`读取数据R之前必须先对其加S锁`，==读完后即可释放S锁==。

二级封锁协议可以**防止丢失修改**和**读“脏”数据**。

在二级封锁协议中，由于读完数据后即可释放S锁，所以它**不能保证可重复读**。

*3.三级封锁协议*
一级封锁协议加上事务T在`读取数据R之前必须先对其加S锁`，==直到事务结束才释放==。

三级封锁协议可**防止丢失修改**、**读脏数据和不可重复读**。

**三级协议的主要区别**

什么操作需要申请封锁以及何时释放锁（即持锁时间）

不同的封锁协议使事务达到的一致性级别不同

封锁协议级别越高，一致性程度越高

|              | **X锁**      | **X锁**          | **S锁**      | **S锁**      | **一致性保证** | **一致性保证** | **一致性保证** |
| ------------ | ------------ | ---------------- | ------------ | ------------ | -------------- | -------------- | -------------- |
|              | 操作结束释放 | ==事务结束释放== | 操作结束释放 | 事务结束释放 | 不丢失  修改   | 不读“脏”数据   | 可重复  读     |
| 一级封锁协议 |              | √                |              |              | √              |                |                |
| 二级封锁协议 |              | √                | √            |              | √              | √              |                |
| 三级封锁协议 |              | √                |              | √            | √              | √              | √              |

## 11.4  活锁和死锁

### 11.4.1 活锁(进程饥饿)

> 事务T1封锁了数据R
>
> 事务T2又请求封锁R，于是T2等待。
>
> T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。
>
> T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……
>
> T2有可能永远等待，这就是活锁的情形 

**避免活锁：采用*先来先服务*的策略/*等待时间长优先***

当多个事务请求封锁同一数据对象时

按请求封锁的先后次序对这些事务排队

该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁

### 11.4.2 死锁

> 事务T1封锁了数据R1
> T2封锁了数据R2
> T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁
> 接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁
> 这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁 

**解决死锁的方法**

**1.** **死锁的预防**

产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。

预防死锁的发生就是要破坏产生死锁的条件

*预防死锁的方法*
`（1）一次封锁法`

​	要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行

​	存在的问题

​	**降低系统并发度**

`（2）顺序封锁法`

​	顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

​	顺序封锁法存在的问题

**	维护成本**
	    数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样	的资源的封锁顺序非常困难，成本很高。

​	**难以实现**
​	    事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，	因此也就很难按规定的顺序去施加封锁 

**2.** **死锁的诊断与解除**

*（1）超时法*

​	如果一个事务的等待时间超过了规定的时限，就认为发生了死锁

`	优点`：实现简单

`	缺点`:有可能误判死锁

​	时限若设置得太长，死锁发生后不能及时发现

*（2）等待图法* 

​	用事务等待图动态反映所有事务的等待情况,事务等待图是一个有向图G=(T，U),T为结点的集合，每	个结点表示正运行的事务,U为边的集合，每条边表示事务等待的情况,若T1等待T2，则T1，T2之间划	一条有向边，从T1指向T2

​	![image-20211111120803466](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111111208616.png/)



​	并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在**回路**，则	表示系统中出现了死锁。

​	`解除死锁`
​	选择一个**处理死锁代价最小的事务**，将其撤消**(T~3~或者T~2~)**
​	释放此事务持有的所有的锁，使其它事务能继续运行下去

## 11.5  并发调度的可串行性

数据库管理系统对并发事务不同的调度可能会产生**不同的结果**

**串行调度是正确的**

执行**结果等价于**串行调度的调度**也是正确的**，称为`可串行化调度` 

### 11.5.1 可串行化调度

**可串行化(Serializable)调度**

多个事务的并发执行是正确的，当且仅当其结果与*按某一次序串行*地执行这些事务时的*结果相同*

**可串行性(Serializability)**

是并发事务*正确调度的准则*

一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 

*[例11.2]现在有两个事务，分别包含下列操作：*

事务T1：读B；A=B+1；写回A

事务T2：读A；B=A+1；写回B

现给出对这两个事务不同的调度策略 T~1~

| T1       | T2       |
| -------- | -------- |
| Slock B  |          |
| Y=R(B)=2 |          |
| Unlock B |          |
| Xlock A  |          |
| A=Y+1=3  |          |
| W(A)     |          |
| Unlock A |          |
|          | Slock A  |
|          | X=R(A)=3 |
|          | Unlock A |
|          | Xlock B  |
|          | B=X+1=4  |
|          | W(B)     |
|          | Unlock B |

假设A、B的初值均为2。
按T1→T2次序执行结果为A=3，B=4 
串行调度策略,正确的调度 

| T1       | T2        |
| -------- | --------- |
|          | Slock A   |
|          | X=R(A)=2  |
|          | Unlock A  |
|          | Xlock B   |
|          | B=X+1=3   |
|          | W(B)      |
|          | Unlock  B |
| Slock B  |           |
| Y=R(B)=3 |           |
| Unlock B |           |
| Xlock A  |           |
| A=Y+1=4  |           |
| W(A)     |           |
| Unlock A |           |

假设A、B的初值均为2。
T2→T1次序执行结果为B=3，A=4 
串行调度策略,正确的调度 

| T1       | T2        |
| -------- | --------- |
| Slock B  |           |
| Y=R(B)=2 |           |
|          | Slock A   |
|          | X=R(A)=2  |
| Unlock B |           |
|          | Unlock A  |
| Xlock A  |           |
| A=Y+1=3  |           |
| W(A)     |           |
|          | Xlock B   |
|          | B=X+1=3   |
|          | W(B)      |
| Unlock A |           |
|          | Unlock  B |

执行结果与(a)、(b)的结果都不同
是错误的调度 

| T1       | T2        |
| -------- | --------- |
| Slock B  |           |
| Y=R(B)=2 |           |
| Unlock B |           |
| Xlock A  |           |
|          | Slock A   |
| A=Y+1=3  | 等待      |
| W(A)     | 等待      |
| Unlock A | 等待      |
|          | X=R(A)=3  |
|          | Unlock A  |
|          | Xlock B   |
|          | B=X+1=4   |
|          | W(B)      |
|          | Unlock  B |

执行结果与串行调度(a)的执行结果相同
是正确的调度 

### 11.5.2 冲突可串行化调度

**冲突可串行化**

一个比可串行化`更严格`的条件

商用系统中的调度器采用

**冲突操作**：是指不同的事务对同一数据的**读写操作**和**写写操作**：

- **Ri(x)与Wj(x)**	       *事务Ti读x，Tj写x，其中i≠j*
- **Wi(x)与Wj(x)**         *事务Ti写x，Tj写x，其中i≠j*

其他操作是不冲突操作

**不能交换**（Swap）的动作:

- *同一事务*的两个操作
- *不同事务*的冲突操作

*一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度*

若一个调度是冲突可串行化，则一定是可串行化的调度

可用这种方法判断一个调度是否是冲突可串行化的

*冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。*
    ***[例11.4]有3个事务***
       *T1=W1(Y)W1(X)，T2=W2(Y)W2(X)，T3=W3(X)*
*调度L1=W1(Y)W1(X)W2(Y)W2(X) W3(X)是一个串行调度。*
*调度L2=W1(Y)W2(Y)W2(X)W1(X)W3(X)不满足冲突可串行化。*但是调度L2是可串行化的，因为L2执行的结果与调度L1相同，Y的值都等于T2的值，X的值都等于T3的值 

## 11.6  两段锁协议

数据库管理系统普遍采用两段锁协议的方法*实现并发调度的可串行性*，从而保证调度的正确性 

**两段锁协议**

指所有事务必须分两个阶段对数据项加锁和解锁 

- 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
- 在释放一个封锁之后，事务不再申请和获得任何其他封锁

**“两段”锁的含义**

事务分为两个阶段

-  第一阶段是**获得封锁**，也称为**扩展阶段**
  - 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 
-  第二阶段是**释放封锁**，也称为**收缩阶段**
  - 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁 

![image-20211116092230348](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111160922595.png/)

*事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。*

若并发事务都**遵守两段锁协议**，则对这些事务的任何并发调度策略**都是可串行化**的

若并发事务的一个调度是**可串行化**的，不一定所有事务~~都符合两段锁协议~~

**两段锁协议与防止死锁的一次封锁法**

- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议
- 但是两段锁协议并*不要求*事务必须一次将所有要使用的数据*全部加锁*，因此遵守两段锁协议的事务*可能发生死锁*

| 事务T1  | 事务T2  |
| ------- | ------- |
| Slock B |         |
| R(B)=2  |         |
|         | Slock A |
|         | R(A)=2  |
| Xlock A |         |
| 等待    | Xlock A |
| 等待    | 等待    |

## 11.7  封锁的粒度

**封锁对象的大小**称为**封锁粒度**(Granularity) 

封锁的对象:*逻辑单元*，*物理单元* 

例：在关系数据库中，封锁对象：

- 逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等
- 物理单元：页（数据页或索引页）、物理记录等

**封锁粒度**与系统的**并发度和并发控制的开销密切相关**。

封锁的**粒度越大**，数据库所能够封锁的数据单元就越少，**并发度就越小**，**系统开销也越小**；

- *若封锁粒度是数据页，事务T1需要修改元组L1，则T1必须对包含L1的整个数据页A加锁。如果T1对A加锁后事务T2要修改A中元组L2，则T2被迫等待，直到T1释放A。*

封锁的**粒度越小**，**并发度较高**，但**系统开销也就越大**

- *如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，不需要互相等待，提高了系统的并行度。*

- *事务T需要读取整个表，若封锁粒度是元组，T必须对表中的每一个元组加锁，开销极大*

**多粒度封锁(Multiple Granularity Locking)**

在一个系统中同时支持多种封锁粒度供不同的事务选择

**选择封锁粒度**

同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度

- 需要处理**多个关系**的**大量元组**的用户事务：以`数据库为封锁单位`
- 需要处理**大量元组**的用户事务：以`关系为封锁单元`
- 只处理**少量元组**的用户事务：以`元组为封锁单位`

### 11.7.1 多粒度封锁

**多粒度树**

- 以**树形结构**来表示多级封锁粒度
- **根结点是整个数据库**，表示最大的数据粒度
- **叶结点表示最小**的数据粒度

​    ![image-20211116094648047](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111160946285.png/)

**多粒度封锁协议**

**允许**多粒度树中的每个结点被**独立地加锁**

对**一个结点加锁**意味着这个结点的**所有后裔结点也被加以同样类型的锁**

在多粒度封锁中一个数据对象可能以两种方式封锁：**显式封锁**和**隐式封锁**

**显式封锁和隐式封锁**

**显式封锁**: *直接*加到*数据对象上的封锁*
**隐式封锁**:是该数据对象没有独立加锁，是由于其*上级结点加锁*而使该数据对象加上了锁
显式封锁和隐式封锁的效果是一样的

--->**系统检查封锁冲突时**

- 要检查**显式封锁**
- 还要检查**隐式封锁**

> 例如事务T要对关系R1加X锁
>
> - 系统必须搜索其上级结点数据库、关系R1
> - 还要搜索R1的下级结点，即R1中的每一个元组
> - 如果其中某一个数据对象已经加了不相容锁，则T必须等待

`对某个数据对象加锁，系统要检查`

 **该数据对象**

- 有无显式封锁与之冲突

 **所有上级结点**

- 检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）

**所有下级结点**

- 看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突

### 11.7.2 意向锁

**引进意向锁（intention lock）目的**

提高对某个数据对象加锁时系统的**检查效率**

如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁

对任一结点加基本锁，必须先对它的上层结点加意向锁

> 例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁 

**常用意向锁**

*意向共享锁(Intent Share Lock，简称IS锁)*

如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。

> 例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁 

*意向排它锁(Intent Exclusive Lock，简称IX锁)*

如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。

> 例如：事务T1要对R1中某个元组加X锁，则要首先对关   系R1和数据库加IX锁 

*共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)*

如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX

> 例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。

**锁的强度**

锁的强度是指它对其他锁的排斥程度

一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111160959213.png/" alt="image-20211116095906086" style="zoom: 50%;" />

**具有意向锁的多粒度封锁方法**

- 申请封锁时应该按自上而下的次序进行
- 释放封锁时则应该按自下而上的次序进行

> 例如：事务T1要对关系R1加S锁
>
> - 要首先对数据库加IS锁
> - 检查数据库和R1是否已加了不相容的锁(X或IX)
> - 不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁) 

**haochu**

提高了系统的并发度

减少了加锁和解锁的开销

在实际的数据库管理系统产品中得到广泛应用 

## *11.8  其他并发控制机制



## 11.9  小结



