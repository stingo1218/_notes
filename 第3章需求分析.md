[TOC]



# 第3章需求分析

为了开发出真正满足用户需求的软件产品，首先必须知道用户的需求。对软件需求的深入理解是软件开发工作获得成功的前提条件，不论人们把设计和编码工作做得如何出色，不能真正满足用户需求的程序只会令用户失望，给开发者带来烦恼。

尽管目前有许多不同的用于需求分析的结构化分析方法，但是，所有这些分析方法都遵守下述准则。

- 必须理解并描述问题的信息域，根据这条准则应该建立数据模型。

- 必须定义软件应完成的功能，这条准则要求建立功能模型。
- 必须描述作为外部事件结果的软件行为，这条准则要求建立行为模型
- 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。

## 3.1需求分析的任务

虽然功能需求是对软件系统的一项基本需求，但却并不是唯一的需求。通常对软件系统有下述几方面的综合要求。

- 功能需求
  - 这方面的需求指定系统必须提供的服务。通过需求分析应该划分出系统必须完成的所有功能
- 性能需求
  - 性能需求指定系统必须满足的定时约束或容量约束，通常包括速度(响应时间)、信息量速率、主存容量、磁盘容量、安全性等方面的需求。
- 可靠性和可用性需求
  - 可靠性需求定量地指定系统的可靠性，可用性与可靠性密切相关，它量化了用户可以使用系统的程度。
- 出错处理需求
  - 这类需求说明系统对环境错误应该怎样响应。例如，如果它接收到从另一个系统发来的违反协议格式的消息，应该做什么?注意，上述这类错误并不是由该应用系统本身造成的。
- 接口需求
  - 接口需求描述应用系统与它的环境通信的格式。常见的接口需求有：用户接口需求；硬件接口需求；软件接口需求；通信接口需求。
- 约束
  - 设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件。常见的约束有：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台。
- 逆向需求
  - 逆向需求说明软件系统不应该做什么。理论上有无限多个逆向需求，人们应该仅选取能澄清真实需求且可消除可能发生的误解的那些逆向需求。
- 将来可能提出的要求
  - 应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。这样做的目的是，在设计过程中对系统将来可能的扩充和修改预做准备，以便一旦确实需要时能比较容易地进行这种扩充和修改。

### 3.1.2分析系统的数据要求

任何一个软件系统本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响，因此，必须分析系统的数据要求，这是软件需求分析的一个重要任务。

复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观。为了提高可理解性，常常利用图形工具辅助描绘数据结构。

### 3.1.3导出系统的逻辑模型

综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用数据流图、实体联系图、状态转换图、数据字典和主要的处理算法描述这个逻辑模型。

### 3.1.4  修正系统开发计划

根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。

## 3.2 与用户沟通获取需求的方法

### 3.2.1 访谈

访谈是最早开始使用的获取用户需求的技术，也是迄今为止仍然广泛使用的需求分析技术。访谈有两种基本形式，分别是正式的和非正式的访谈。

正式访谈时，系统分析员将提出一些事先准备好的具体问题，例如，询问客户公司销售的商品种类、雇用的销售人员数目以及信息反馈时间应该多快等。在非正式访谈中，分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法，例如，询问用户对目前正在使用的系统有哪些不满意的地方。

访谈有两种基本形式，分别是正式的和非正式的访谈。正式访谈时，系统分析员将提出一些事先准备好的具体问题，非正式访谈中，分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法

在访问用户的过程中使用情景分析技术往往非常有效。所谓情景分析就是对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。

情景分析技术的用处主要体现在下述两个方面。

- 它能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。
- 由于情景分析较易为用户所理解，使用这种技术能保证用户在需求分析过程中始终扮演一个积极主动的角色。

### 3.2.2 面向数据流自顶向下求精

结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法。通过可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。
为了达到这个目标，通常从数据流图的输出端着手分析，这是因为系统的基本功能是产生这些输出，输出数据决定了系统必须具有的最基本的组成元素。

数据流图是帮助复查的极好工具，从输入端开始，分析员借助数据流图、数据字典和IPO图向用户解释输入数据是怎样一步一步地转变成输出数据的。这些解释集中反映了通过前面的分析工作分析员所获得的对目标系统的认识。

随着分析过程的进展，经过提问和解答的反复循环，分析员越来越深入具体地定义了目标系统，最终得到对系统数据和功能要求的满意了解。

![image-20220316212849229](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316212849.png)



### 3.2.3 简易的应用规格说明技术

简易的应用规格说明技术是为了解决使用传统的访谈或面向数据流自顶向下求精方法定义需求时，用户处于被动地位而且往往有意无意地与开发者区分“彼此”。由于不能像同一个团队的人那样齐心协力地识别和精化需求，这两种方法的效果有时并不理想的问题，提出的。

简易的应用规格说明技术分析需求的典型过程如下

- 进行初步的访谈
- 开发者和用户分别写出“产品需求”。
- 开会讨论，各自展示需求列表
- 得出了意见一致，为需求列表制定小型规格说明
- 根据会议结果，起草完整的软件需求规格说明

### 3.2.4  快速建立软件原型

为了快速地构建和修改原型，通常使用下述3种方法和工具。

- 第四代技术
- 可重用的软件构件
- 形式化规格说明和原型环境

快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序，快速原型应该具备的特性：

- 快速原型应该具备的第一个特性是“快速”。
- 快速原型应该具备的第二个特性是“容易修改”。

## 3.3 分析建模与规格说明

### 3.3.1 分析建模

模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。

为了开发复杂的系统，应从不同角度（模型）抽象出目标系统的特性（数据模型、功能模型、行为模型）

- 实体联系图，描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。
- 数据流图是建立功能模型的基础。
- 状态转换图描绘了系统的各种行为模式和在不同状态间转换的方式。

### 3.3.2 软件需求规格说明

<u>软件需求规格说明是需求分析阶段得出的最主要的文档。</u>

通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。

## 3.4 实体联系图

数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系。

### 3.4.1 数据对象

<u>数据对象是对软件必须理解的复合信息的抽象。</u>

数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。总之，可以由一组属性来定义的实体都可以被认为是数据对象。

### 3.4.2 属性

**属性定义了数据对象的性质**。
必须把一个或多个属性定义为“标识符”，也就是说，当人们希望找到数据对象的一个实例时，用标识符属性作为“关键字”(通常简称为“键”)。

### 3.4.3 联系

**客观世界中的事物彼此间往往是有联系的**。
数据对象彼此之间相互连接的方式称为联系，也称为关系。联系可分为以下3种类型。

- 一对一联系(1∶1)
  - 例如，一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的。
- 一对多联系(1∶N)
  - 例如，某校教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教(见图3.2)。
- 多对多联系(M∶N)
  - 例如，图3.2表示学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。

![image-20220316213431593](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213431.png)

### 3.4.4 实体联系图的符号

通常，使用实体联系图(entityrelationship diagram)来建立数据模型。可以把实体联系图简称为ER图，相应地可把用ER图描绘的数据模型称为ER模型。

ER图中包含了实体(即数据对象)、关系和属性3种基本成分，通常用矩形框代表实体，用连接相关实体的菱形框表示关系，用椭圆形或圆角矩形表示实体(或关系)的属性，并用直线把实体(或关系)与其属性连接起来。

ER模型可以作为用户与分析员之间有效的交流工具。

## 3.5 数据规范化

软件系统经常使用各种长期保存的信息，这些信息通常以一定方式组织并存储在数据库或文件中，为减少数据冗余，避免出现插入异常或删除异常，简化修改数据的过程，通常需要把数据结构规范化。

通常用“范式(normal forms)”定义消除数据冗余的程度。

![image-20220316213523747](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213523.png)



## 3.6状态转换图

<u>状态转换图(简称为状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作。</u>

### 3.6.1 状态

<u>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</u>

在状态图中定义的状态主要有：初态(即初始状态)、终态(即最终状态)和中间状态。在一张状态图中只能有一个初态，而终态则可以有0至多个。

状态图既可以表示系统循环运行过程，也可以表示系统单程生命期。

### 3.6.2 事件

事件是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。

事件就是引起系统做动作或(和)转换状态的控制信息。

### 3.6.3 符号

在状态图中，初态用实心圆表示，终态用一对同心圆(内圆为实心圆)表示。
中间状态用圆角矩形表示，可以用两条水平横线把它分成上、中、下3个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，这部分是可选的；下面部分是活动表，1这部分也是可选的。

活动表的语法格式如下：
事件名(参数表)/动作表达式其中，“事件名”可以是任何事件的名称。
在活动表中经常使用下述3种标准事件：entry, exit和do。entry事件指定进入该状态的动作，exit事件指定退出该状态的动作，而do事件则指定在该状态下的动作。需要时可以为事件指定参数表。活动表中的动作表达式描述应做的具体动作。

状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。
事件表达式的语法如下：
事件说明［守卫条件］／动作表达式其中，事件说明的语法为：事件名(参数表)。

状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。
事件表达式的语法如下：
事件说明［守卫条件］／动作表达式其中，事件说明的语法为：事件名(参数表)。

![image-20220316213640635](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213640.png)

### 3.6.4 例子

为了具体说明怎样用状态图建立系统的行为模型，下面举一个例子
下图是人们非常熟悉的电话系统的状态图。

![image-20220316213659937](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213700.png)

## 3.7其他图形工具

 描述复杂的事物时，图形远比文字叙述优越得多，它形象直观容易理解。前面已经介绍了用于建立功能模型的数据流图、用于建立数据模型的实体联系图和用于建立行为模型的状态图，本节再简要地介绍在需求分析阶段可能用到的另外3种图形工具。

### 3.7.1 层次方框图

<u>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</u>

例如，描绘一家计算机公司全部产品的数据结构可以用下图3.5层次方框图表示。
这家公司的产品由硬件、软件和服务3类产品组成，软件产品又分为系统软件和应用软件，系统软件又进一步分为操作系统、编译程序和软件工具等。

![image-20220316213738418](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213738.png)

### 3.7.2 Warnier图

和层次方框图类似，Warnier图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。

用Warnier图可以表明信息的逻辑组织，也就是说，它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的。

![image-20220316213756527](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213756.png)

### 3.7.3 IPO图

IPO图是输入、处理、输出图的简称，它是由美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。

下图3.7是主文件更新的例子，通过这个例子不难了解IPO图的用法

![image-20220316213814920](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213814.png)



![image-20220316213831226](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213831.png)

## 3.8 验证软件需求

### 3.8.1 从哪些方面验证软件需求的正确性

需求分析阶段的工作结果是开发软件系统的重要基础，大量统计数字表明，软件系统中15%的错误起源于错误的需求。

为了提高软件质量，确保软件开发成功，降低软件开发成本，一旦对目标系统提出一组要求之后，必须严格验证这些需求的正确性。一般说来，应该从下述4个方面进行验证。

- 一致性所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
- 完整性需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。
- 现实性指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。
- 有效性必须证明需求是正确有效的，确实能解决用户面对的问题。

### 3.8.2 验证软件需求的方法

上一小节已经指出，至少必须从一致性、完整性、现实性和有效性这4个不同角度验证软件需求的正确性。那么，怎样验证软件需求的正确性呢?验证的角度不同，验证的方法也不同。

- 验证需求的一致性
  - 当需求分析的结果是用自然语言书写的时候，除了靠人工技术审查验证软件系统规格说明书的正确性之外，目前还没有其他更好的“测试”方法。但是，这种非形式化的规格说明书是难于验证的，特别在目标系统规模庞大、规格说明书篇幅很长的时候，人工审查的效果是没有保证的，冗余、遗漏和不一致等问题可能没被发现而继续保留下来，以致软件开发工作不能在正确的基础上顺利进行。
    为了克服上述困难，人们提出了形式化的描述软件需求的方法。
- 验证需求的现实性
  - 为了验证需求的现实性，分析员应该参照以往开发类似系统的经验，分析用现有的软、硬件技术实现目标系统的可能性。必要的时候应该采用仿真或性能模拟技术，辅助分析软件需求规格说明书的现实性。
- 验证需求的完整性和有效性
  - 只有目标系统的用户才真正知道软件需求规格说明书是否完整、准确地描述了他们的需求。因此，检验需求的完整性，特别是证明系统确实满足用户的实际需要，只有在用户的密切合作下才能完成。然而许多用户并不能清楚地认识到他们的需要(特别在要开发的系统是全新的，以前没有使用类似系统的经验时，情况更是如此)，不能有效地比较陈述需求的语句和实际需要的功能。只有当他们有某种工作着的软件系统可以实际使用和评价时，才能完整确切地提出他们的需要。

### 3.8.3 用于需求分析的软件工具

为了更有效地保证软件需求的正确性，特别是为了保证需求的一致性，需要有适当的软件工具支持需求分析工作。这类软件工具应该满足下列要求。

- 必须有形式化的语法(或表)，因此可以用计算机自动处理使用这种语法说明的内容。
- 使用这个软件工具能够导出详细的文档。
- 必须提供分析(测试)规格说明书的不一致性和冗余性的手段，并且应该能够产生一组报告指明对完整性分析的结果。
- 使用这个软件工具之后，应该能够改进通信状况。

PSL/PSA系统是CADSAT（计算机辅助设计和规格说明分析工具）的一部分。其中PSL是用来描述系统的形式语言，PSA是处理PSL描述的分析程序。

**PSL/PSA系统的功能主要有下述4种。**

- 描述任何应用领域的信息系统。
- 创建一个数据库保存对该信息系统的描述符。
- 对描述符施加增加、删除和更改等操作。
- 产生格式化的文档和关于规格说明书的各种分析报告。

# 第4章  形式化说明技术

​       本章将介绍 形式化技术在软件工程中有效的提高了开发的效率、改进了软件开发的质量、减少了开发费用。形式化的技术容易在软件的规约上取得一致性，它属于一种非常有效的交流方式。

![image-20220316214236361](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316214236.png)

## 4.1 概述

### 4.1.1 非形式化方法的缺点

用自然语言书写的系统规格说明书，可能存在矛盾、二义性、含糊性、不完整性及抽象层次混乱等问题。

①矛盾是指一组相互冲突的陈述。

②二义性是指读者可以用不同方式理解的陈述。

③含糊性

④不完整性

⑤抽象层次混乱是指在非常抽象的陈述中混进了一些关于细节的低层次陈述。

### 4.1.2 形式化方法的优点

为了克服非形式化方法的缺点，人们把数学引入软件开发过程，创造了基于数学的形式化方法。

①数学能够简洁准确地描述物理现象、对象或动作的结果，因此是理想的建模工具二义性是指读者可以用不同方式理解的陈述。

②数学以在不同的软件工程活动之间平滑地过渡。

③数学提供了高层确认的手段。

### 4.1.3 应用形式化方法的准则

①应该选用适当的表示方法。

②应该形式化，但不要过分形式化。

③应该估算成本。

④应该有形式化方法顾问随时提供咨询。

⑤不应该放弃传统的开发方法。

⑥应该建立详尽的文档。

⑦不应该放弃质量标准。

⑧不应该盲目依赖形式化方法。

⑨应该测试、测试再测试。

⑩ 应该重用。

## 4.2 有穷状态机

### 4.2.1 概念

例子：一个保险箱上装了一个复合锁，锁有3个位置，分别标记为1、2、3，转盘可向左(L)或向右(R)转动。这样，在任意时刻转盘都有6种可能的运动，即1L、1R、2L、2R、3L和3R。保险箱的组合密码是1L、3R、2L，转盘的任何其他运动都将引起报警。

![image-20220316214436136](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316214436.png)

一个初始态：保险箱锁定状态。

表4.1保险箱的状态装换表

![image-20220316214448916](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316214448.png)

从上面这个简单例子可以看出，一个有穷状态机包括下述5个部分：状态集J、输入集K、由当前状态和当前输入确定下一个状态(次态)的转换函数T、初始态S和终态集F。

对于保险箱的例子，相应的有穷状态机的各部分如下：

状态集J：｛保险箱锁定，A，B，保险箱解锁，报警｝。

输入集K：｛1L，1R，2L，2R，3L，3R｝。

转换函数T：如表所示。 

初始态S：保险箱锁定。

终态集F：｛保险箱解锁，报警｝。

如果使用更形式化的术语，一个有穷状态机可以表示为一个5元组(J，K，T，S，F)，其中：J是一个有穷的非空状态集；

​     K是一个有穷的非空输入集；

​     T是一个从(J-F)×K到J的转换函数；

​     S∈J，是一个初始状态；

​     F\\J，是终态集。

有穷状态机的概念在计算机系统中应用得非常广泛。

例如，每个菜单驱动的用户界面都是一个有穷状态机的实现。一个菜单的显示和一个状态相对应，键盘输入或用鼠标选择一个图标是使系统进入其他状态的一个事件。状态的每个转换都具有下面的形式：

​			**当前状态〔菜单〕+事件〔所选择的项〕=>下个状态。**

为了对一个系统进行规格说明，通常都需要对有穷状态机做一个很有用的扩展，即在前述的5元组中加入第6个组件——谓词集P，从而把有穷状态机扩展为一个6元组，其中每个谓词都是系统全局状态Y的函数。转换函数T现在是一个从(J-F)×K×P到J的函数。现在的转换规则形式如下：

​			**当前状态〔菜单〕+事件〔所选择的项〕+谓词=>下个状态。**

### 4.2.2  例子

**有穷状态机技术表达系统的规格说明**，现在给出电梯系统的规格说明。

用自然语言描述的对电梯系统的需求。

在一幢m层的大厦中需要一套控制n部电梯的产品，要求这n部电梯按照约束条件C1，C2和C3在楼层间移动。

> C1：每部电梯内有m个按钮，每个按钮代表一个楼层。当按下一个按钮时该按钮指示灯亮，同时电梯驶向相应的楼层，到达按钮指定的楼层时指示灯熄灭。
>
> C2：除了大厦的最低层和最高层之外，每层楼都有两个按钮分别请求电梯上行和下行。这两个按钮之一被按下时相应的指示灯亮，当电梯到达此楼层时灯熄灭，电梯向要求的方向移动。
>
> C3：当对电梯没有请求时，它关门并停在当前楼层。

使用一个**扩展的有穷状态机**对本产品进行规格说明.
分析：问题中有两个按钮集。n部电梯中的每一部都有m个按钮，一个按钮对应一个楼层。因为这m×n个按钮都在电梯中，为电梯按钮。每层楼有两个按钮，一个请求向上，另一个请求向下，称为楼层按钮。
电梯按钮的状态转换图如图4.2所示。

![image-20220316214649566](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316214649.png)

令EB(e,f)表示按下电梯e内的按钮并请求到f层去。EB(e,f)有两个状态，分别是按钮发光(打开)和不发光(关闭)。状态是：

EBON(e,f)：电梯按钮(e,f)打开

EBOFF(e,f)：电梯按钮(e,f)关闭

如果电梯按钮(e,f)发光且电梯到达f层，该按钮将熄灭。相反如果按钮熄灭，则按下它时，按钮将发光。两个事件，它们分别是：

EBP(e,f)：电梯按钮(e,f)被按下

EAF(e,f)：电梯e到达f层

为了定义与这些事件和状态相联系的状态转换规则，

需要一个谓词V(e,f)，它的含义如下：

V(e,f)：电梯e停在f层

如果电梯按钮(e,f)处于关闭状态〔当前状态〕，而且电梯按钮(e,f)被按下〔事件〕，而且电梯e不在f层〔谓词〕，则该电梯按钮打开发光〔下个状态〕。

状态转换规则的形式化描述如下：

**EBOFF(e,f)+EBP(e,f)+not V(e,f)=>EBON(e,f)**

反之，如果电梯到达f层，而且电梯按钮是打开的，于是它就会熄灭。

这条转换规则可以形式化地表示为：

**EBON(e,f)+EAF(e,f) =>EBOFF(e,f)**

考虑楼层按钮。令FB(d,f)表示f层请求电梯向d方向运动的按钮，楼层按钮FB(d,f)的状态转换图如图所示,楼层按钮的状态如下。

FBON(d,f)：楼层按钮(d,f)打开

FBOFF(d,f)：楼层按钮(d,f)关闭

楼层按钮已经打开，一部电梯到达f层则按钮关闭。

楼层按钮原来是关闭的，被按下后该按钮将打开。

FBP(d,f)：楼层按钮(d,f)被按下

EAF(1…n,f)：电梯1或…或n到达f层

其中，1…n表示或为1或为2…或为n。

![image-20220316214725963](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316214726.png)

为了定义与这些事件和状态相联系的状态转换规则，需要一个谓词S(d,e,f)，定义如下：S(d,e,f)：电梯e停在f层并且移动方向由d确定为向上(d=U)或向下(d=D)或待定(d=N)。

这个谓词是一个状态，形式化方法允许把事件和状态作为谓词对待。

使用谓词S(d,e,f)，形式化转换规则为：

FBOFF(d,f)+FBP(d,f)+not S(d,1…n,f) =>FBON(d,f)

FBON(d,f)+EAF(1…n,f)+S(d,1…n,f) =>FBOFF(d,f)

其中，d=UorD。

电梯按钮状态转换规则时定义的谓词V(e,f)，可以用谓词S(d,e,f)重新定义如下：**V(****e,f****)=S(****U,e,f****)or S(****D,e,f****)or S(****N,e,f****)**

电梯的状态及其转换规则，一个电梯状态实质上包含许多子状态(如，电梯减速、停止、开门、在一段时间后自动关门)。

下面定义电梯的3个状态。

M(d,e,f)：电梯e正沿d方向移动，即将到达的是第f层

S(d,e,f)：电梯e停在f层，将朝d方向移动(尚未关门)

W(e,f)：电梯e在f层等待(已关门)其中，S(d,e,f)状态已在讨论楼层按钮时定义过，但是，现在的定义更完备。

图是电梯的状态转换图。3个电梯停止状态S(U，e,f)、S(N，e,f)和S(D，e,f)已组合成一个大的状态，目的是减少状态总数以简化流图。

![image-20220316214816012](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316214816.png)

图4.4中包含了下述3个可触发状态发生改变的事件。

DC(e,f)：电梯e在楼层f关上门

ST(e,f)：电梯e靠近f层时触发传感器，电梯控制器决定在当前楼层电梯是否停下

RL：电梯按钮或楼层按钮被按下进入打开状态，登录需求

**电梯的状态转换规则**。这里给出的规则仅发生在关门之时。

S(U，e,f)+DC(e,f) => M(U，e,f+1)

S(D，e,f)+DC(e,f) => M(D，e,f-1)

S(N，e,f)+DC(e,f) =>W(e,f)

第一条规则表明，如果电梯e停在f层准备向上移动，且门已经关闭，则电梯将向上一楼层移动。

第二条和第三条规则，分别对应于电梯即将下降或者没有待处理的请求的情况。

### 4.2.3  评价

有穷状态机方法采用了一种简单的格式来描述规格说明：

**当前状态+事件+谓词=>下个状态**

这种形式的规格说明易于书写、易于验证，而且可以比较容易地把它转变成设计或程序代码。事实上，可以开发一个CASE工具把一个有穷状态机规格说明直接转变为源代码。

有穷状态机方法比数据流图技术更精确，而且和它一样易于理解。

它也有缺点：在开发一个大系统时三元组(即状态、事件、谓词)的数量会迅速增长。此外，和数据流图方法一样，形式化的有穷状态机方法也没有处理定时需求。

## 4.3 Petri网

### 4.3.1  概念

**Petri**网由来：

并发系统中遇到的一个主要问题是定时问题。这个问题可以表现为多种形式，如同步问题、竞争条件以及死锁问题。

用于确定系统中隐含的定时问题的一种有效技术是Petri网，这种技术的一个很大的优点是它也可以用于设计中。

Petri网是由*Carl Adam Petri*发明的。在性能评价、操作系统和软件工程等领域，Petri网应用得都比较广泛。特别是已经证明，用Petri网可以有效地描述并发活动。

Petri网包含4种元素：一组位置P、一组转换T、输入函数I、输出函数O。

其中：

一组位置P为｛P1，P2，P3，P4｝，在图中用圆圈代表位置。

一组转换T为｛t1，t2｝，在图中用短直线表示转换。

![image-20220316215033664](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215033.png)

两个用于转换的输入函数，用由位置指向转换的箭头表示，是：

​                I(t1)=｛P2，P4｝

​                I(t2)=｛P2｝

两个用于转换的输出函数，用由转换指向位置的箭头表示，是：

​                O(t1)=｛P1｝

​                O(t2)=｛P3，P3｝

注意，输出函数O(t2)中有两个P3，是因为有两个箭头由t2指向P3。

更形式化的Petri网结构，是一个四元组C=(P,T,I,O)。

其中：P=｛P1，…，Pn｝是一个有穷位置集，n≥0。

​      T=｛t1，…，tm｝是一个有穷转换集，m≥0，且T和P不相交。

​      I：T→P∞为输入函数，是由转换到位置无序单位组(bags)的映射。

​      O：T→P∞为输出函数，是由转换到位置无序单位组的映射。

一个无序单位组或多重组是允许一个元素有多个实例的广义集。

Petri网的标记是在Petri网中权标(token)的分配。例如，在图4.6中有4个权标，其中一个在P1中，两个在P2中，P3中没有，还有一个在P4中。上述标记可以用向量(1，2，0，1)表示。由于P2和P4中有权标，因此t1启动(即被激发)。

![image-20220316215156612](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215156.png)

通常，当每个输入位置所拥有的权标数大于等于从该位置到转换的线数时，就允许转换。当t1被激发时，P2和P4上各有一个权标被移出，而P1上则增加一个权标。Petri网中权标总数不是固定的，在这个例子中两个权标被移出，而P1上只能增加一个权标。

在图4.6中P2上有权标，因此t2也可以被激发。当t2被激发时，P2上将移走一个权标，而P3上新增加两个权标。Petri网具有非确定性，也就是说，如果数个转换都达到了激发条件，则其中任意一个都可以被激发。

左图所示Petri网的标记为(1，2，0，1)，t1和t2都可以被激发。假设t1被激发了，则结果如左图所示，标记为(2，1，0，0)。此时，只有t2可以被激发。如果t2也被激发了，则权标从P2中移出，两个新权标被放在P3上，结果如右图所示，标记为(2，0，2，0)。

![image-20220316215227444](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215227.png)

更形式化地说，Petri网C=(P，T，I，O)中的标记M，是由一组位置P到一组非负整数的映射：

M：P→｛0，1，2，…｝

带有标记的Petri网成为一个五元组(P，T，I，O，M)。对Petri网的一个重要扩充是加入禁止线。如图所示，禁止线是用一个小圆圈而不是用箭头标记的输入线。

![image-20220316215249733](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215249.png)

### 4.3.2  例子

现在把Petri网应用于上一节讨论过的电梯问题。当用Petri网表示电梯系统的规格说明时，每个楼层用一个位置Ff代表(1≤f≤m)，在Petri网中电梯是用一个权标代表的。在位置Ff上有权标，表示在楼层f上有电梯。

**1** **电梯按钮**

电梯问题的第一个约束条件描述了电梯按钮的行为。

**第一条约束C1**：每部电梯有m个按钮，每层对应一个按钮。当按下一个按钮时该按钮指示灯亮，指示电梯移往相应的楼层。当电梯到达指定的楼层时，按钮将熄灭。

为了用Petri网表达电梯按钮的规格说明，在Petri网中还必须设置其他的位置。电梯中楼层f的按钮，在Petri网中用位置EBf表示(1≤f≤m)。在EBf上有一个权标，就表示电梯内楼层f的按钮被按下了。

电梯按钮只有在第一次被按下时才会由暗变亮，以后再按它则只会被忽略。如图所示的Petri网描述了电梯按钮的行为规律。首先，假设按钮没有发亮，在位置EBf上没有权标，在存在禁止线的情况下，转换“EBf被按下”是允许发生的。现在按下按钮，则转换被激发并在EBf上放置了一个权标，如图所示。因此，位置EBf上的权标数不会多于1。

![image-20220316215341104](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215341.png)

假设电梯由g层驶向f层，因为电梯在g层，如上图所示，位置Fg上有一个权标。由于每条输入线上各有一个权标，转换“电梯在运行”被激发，从而EBf和Fg上的权标被移走，按钮EBf被关闭，在位置Ff上出现一个新权标，即转换的激发使电梯由g层驶到f层。

事实上，电梯由g层移到f层是需要时间的，为处理这个情况及其他类似的问题，Petri网模型中必须加入时限。也就是说，在标准Petri网中转换是瞬时完成的，而在现实情况下就需要时间控制Petri网，以使转换与非零时间相联系。

![image-20220316215458961](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215459.png)

图所示的情况为电梯由g层驶向f层。根据电梯乘客的要求，某一个楼层按钮亮或两个楼层按钮都亮。如果两个按钮都亮了，则只有一个按钮熄灭。图所示的Petri网可以保证，当两个按钮都亮了的时候，只有一个按钮熄灭。但是要保证按钮熄灭正确，则需要更复杂的Petri网模型，对此不做更进一步的介绍。

![image-20220316215518322](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215518.png)

![image-20220316215543164](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215543.png)

## 4.4 Z语言

### 4.4.1 简介

用Z语言描述的、最简单的形式化规格说明含有下述4个部分。

- 给定的集合、数据类型及常数。
- 状态定义。
- 初始状态。
- 操作。

**1.** **给定的集合**

一个Z规格说明从一系列给定的初始化集合开始。所谓初始化集合就是不需要详细定义的集合，这种集合用带方括号的形式表示。对于电梯问题，给定的初始化集合称为Button，即所有按钮的集合，因此，Z规格说明开始于：〔Button〕

**2.** **状态定义**

一个Z规格说明由若干个“格(schema)”组成，每个格含有一组变量说明和一系列限定变量取值范围的谓词。例如，格S的格式如图所示。

![image-20220316215622927](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215622.png)

在电梯问题中，Button有4个子集，即floor_buttons(楼层按钮的集合)、elevator_buttons(电梯按钮的集合)、buttons(电梯问题中所有按钮的集合)以及pushed(所有被按的按钮的集合，即所有处于打开状态的按钮的集合)。描述了格Button_State，符号P表示幂集(即给定集的所有子集)图。约束条件声明，floor_buttons集与elevator_buttons集不相交，而且它们共同组成buttons集

![image-20220316215657380](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215657.png)

![image-20220316215701759](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215701.png)

![image-20220316215721278](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215721.png)

![image-20220316215726619](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215726.png)

操作的谓词部分，包含了一组调用操作的前置条件，以及操作完全结束后的后置条件。

图4.14中的第一个前置条件规定，“button?”必须是buttons的一个元素，而buttons是电梯系统中所有按钮的集合。如果第二个前置条件button? ∉pushed得到满足(即按钮没有开启)，则更新pushed按钮集，使之包含刚开启的按钮“button?”。Z语言中，当一个变量的值发生改变时，就用符号“′”表示。后置条件是当执行完操作Push_Button之后，“button?”将被加入到pushed集中。无须打开按钮，使“button?”变成pushed中的一个元素即可。

另一种可能性是，被按的按钮原先已经打开了。由于button?∈pushed，根据第3个前置条件，将没有任何事情发生，这可以用pushed′=pushed来表示，即pushed的新状态和旧状态一样。注意，如果没有第3个前置条件，规格说明将不能说明在一个按钮已被按过之后又被按了一次的情况下将发生什么事，因此，结果将是不可预测的。

电梯到达了某楼层，如果相应的楼层按钮已经打开，则此时会关闭；同样，如果相应的电梯按钮已经打开，则此时它也会关闭。也就是说，如果“button?”属于pushed集，则将它移出该集合，如图所示(符号＼表示集合差运算)。但是，如果按钮“button?”原先没有打开，则pushed集合不发生变化。

![image-20220316215745815](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316215745.png)

### 4.4.2 评价

Z也许是应用得最广泛的形式化语言，

(1) 可以比较容易地发现用Z写的规格说明的错误，特别是在自己审查规格说明，及根据形式化的规格说明来审查设计与代码时，情况更是如此。

(2) 用Z写规格说明时，要求作者十分精确地使用Z说明符

(3) Z是一种形式化语言，在需要时开发者可以严格地验证规格说明的正确性。

(4) 虽然完全学会Z语言相当困难，但是，经验表明，只学过中学数学的软件开发人员仍然可以只用比较短的时间就学会编写Z规格说明，当然，这些人还没有能力证明规格说明的结果是否正确。

(5) 使用Z语言可以降低软件开发费用。

(6) 虽然用户无法理解用Z写的规格说明，但是，可以依据Z规格说明用自然语言重写规格说明。经验证明，这样得到的自然语言规格说明，比直接用自然语言写出的非形式化规格说明更清楚、更正确。