# #######

选择题 20 2/个

判断 20 2/个

程序填空20 2/个

简答题10 10  第二章 第四章

编程20 

最开始的造型到最后的脚本 

**脚本**

考第一章第二章

灯泡

#########

> **四种VR系统**:桌面式 沉浸式 增强式 分布式
>
> **3I特性**:沉浸感 交互性 想象力

# 1 虚拟现实技术概论

## 课后题

> **1、发展虚拟现实技术的目的是什么？**
>
> 真实体验+基于自然技术的人机交互
>
> **2、何谓自然交互与实时交互？**
>
> 
>
> **3、试述典型的虚拟现实系统的工作原理。**
> **4、试举例说明虚拟现实技术三大基本特征的含义。**
> **5、试述在各类专业培训中引入虚拟现实技术的优势与必要性。**

什么是虚拟现实：

由计算机产生一种逼真的虚拟三维场景，并使用特殊交互设备让用户在多种感官上产生身临其境的感觉。

- *实时三维空间表现能力*

- *自然交互方式*

- *身临其境的感受*

## 1.1	虚拟现实技术的发展史

1929年，Edward Link设计出用于训练飞行员的模拟器

1956年，Morton Heilig开发出多通道仿真体验系统Sensorama 

1965年，Ivan Sutherland发表论文“Ultimate Display”感觉真实，交互真实

1968年，Ivan Sutherland研制成功了带跟踪器的头盔式立体显示器（Head Mounted Display，HMD） 

1972年，Nolan Bushnell开发出第一个交互式电子游戏Pong 

1977年，Dan Sandin、Tom DeFanti和Rich Sayre研制出第一个数据手套——Sayre Glove

## 1.2	虚拟现实技术的概念

虚拟现实技术是指利用计算机生成一种模拟环境，并通过多种专用设备使用户“投入”到该环境中，实现用户与该环境直接进行自然交互的技术。

典型的VR**系统的工作方式**：

- 用户激活交互设备
- VR软件根据输入信号对数据库进行更新

- 将相应信息传递给相应设备

**虚拟现实系统的组成**:

- 用户
- 计算机
- 输入输出设备
- 虚拟现实开发软件
- 数据库



## 1.3	虚拟现实技术的特征

 VR技术的三角形：“**3I特性**”

- 交互性（Interactivity）
- 沉浸感（Immersion）
- 想像力（Imagination）

## 1.4	虚拟现实系统的分类

**VR的根本目标****：

真实体验+基于自然技术的人机交互

能够达到或部分达到根本目标的系统称为VR系统。 

- **桌面式VR系统**（Desktop VR） 
  - 使用个人计算机和低级工作站来产生三维空间的交互场景。
  - 周围现实环境干扰->不能获得完全的沉浸感
  - 成本相对较低->普及 
- **沉浸式VR系统**（Immersive VR） 
  - 利用头盔显示器、洞穴式显示设备和数据手套等交互设备把用户的视觉、听觉和其他感觉封闭起来，而使用户真正成为VR系统内部的一个参与者，产生一种身临其境、全心投入并沉浸其中的体验。
    高度的实时性和沉浸感。
- **增强式VR系统**（Augmented VR） 
  - 允许用户对现实世界进行观察的同时，将虚拟图像叠加在真实物理对象之上。
  - 为用户提供与所看到的真实环境有关的、存储在计算机中的信息，从而增强用户对真实环境的感受，又被称为叠加式或补充现实式VR系统。
  - 可以使用光学技术或视频技术实现。
- **分布式VR系统**（Distributed VR）
  - 指基于网络构建的虚拟环境，将位于不同物理位置的多个用户或多个虚拟环境通过网络相连接并共享信息，从而使用户的协同工作达到一个更高的境界。
  - 主要被应用于远程虚拟会议、虚拟医学会诊、多人网络游戏、虚拟战争演习等领域。

## 1.5	虚拟现实技术的应用领域

### **教育与训练**

虚拟现实技术能使学习者能直接、自然地与虚拟对象进行交互，以各种形式参与事件的发展变化过程，并获得最大的控制和操作整个环境的自由度。
**1、仿真教学与实验**
**2、特殊教育**
**3、多种专业训练**
**4、应急演练和军事演习**

### **设计与规划**

虚拟现实已被看作是设计领域中唯一的开发工具。它可以避免传统方式在原型制造、设计和生产过程中的重复工作，有效的降低成本，应用领域包括**汽车制造业、城市规划、建筑设计**等。

### **科学计算可视化**

**科学可视化**的功能就是将大量字母、数字数据**转换**成比原始数据更容易理解的各种**图像**，并允许参与者借助各种虚拟现实输入设备检**查这些“可见的”数据**。
它通常被用于建立分子结构、地震以及地球环境等模型。

### **商业领域**

VR技术被逐步应用于**网上销售**、**客户服务**、**电传会议及虚拟购物中心**等商业领域。它可以使客户在购买前先看到产品的外貌与内在，甚至在虚拟世界中使用它，因此对产品的推广和销售都很有帮助。

### **艺术与娱乐**

VR技术所具有的身临其境感及实时交互性还能将**静态的艺术**（如油画、雕刻等）转化为**动态**的形式，使观赏者更好地欣赏作者的思想艺术，包括**虚拟画廊、虚拟音乐厅、文物保护**等方面。
**娱乐**是VR系统的另一个重要应用领域，市场上已经推出了多款VR环境下的电脑游戏，带给游戏者强烈的感官刺激。

## 1.6	虚拟现实技术的研究现状

# 2 虚拟现实系统的硬件设备(简答题 选择判断)

## 2.1 跟踪定位设备

> 高精度高可靠性设备 获取人的动作信息 检测对象的位置和朝向  将信息返回给VR设备

> **人机之间沟通的重要通信手段,是实时处理的关键技术**

原理:

![image-20210928105307040](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/53114.png)

**典型工作方式**:发信号 收信号 处理信号 确认位置 数据->环境处理系统

**跟踪器:**

- **电磁波**:

  - 体积小,易穿戴 价格便宜 不受视线阻挡 
  - 延迟长 范围小 金属/磁场影响->精度低

- **超声波**:

  - 不收电磁干扰  不收临近物体影响  轻便接收器     

  - 工作范围有限  信号传输不能受遮挡  受温度气压等影响

    > 飞行时间测量法:
    >
    > 精确度和响应性  受外界噪音脉冲干扰  范围扩大->传输率降低  适合小范围
    >
    > 相位相干测量法:
    >
    > 连续测量  较高传输率

- **光学**:适合头部活动范围等小范围,高刷新精确率等应用

  - 速度快 实时性强      
  - 小范围   视线阻挡   不能提供角度数据     
  
- **机械:**

  - 范围受限 
  - 精度高

- **惯性:**小心陀螺仪

- **图像提取**:摄像机拍摄  图像处理技术(纯软件

  - 范围大 无附着感
  - 受阻挡 图片要求高(光照,设备) 算法要求 

**跟踪传感设备性能比较:**

> **响应时间**
>
> **精度**
>
> **抗干扰性**
>
> **分辨率**

常用3种跟踪技术性能指标对比:

//

## 2.2 立体显示设备

**人眼立体视觉效应原理:**

> 双眼时差,大脑分析,融合为一幅画面,由此获得距离和深度的感觉

**两种立体图像显示技术:**

> **同时显示**:同时显示两幅不同光波长的图像,滤光使用户左右眼只能看到对应图像
>
> **分时显示**:一定频率交替现实同一场景的立体图像,用户以相同频率同步切换的立体眼镜观察图像

**立体眼镜:**

- **有源眼镜**(主动立体眼镜)

  - 有线
  - 无线

  调节左右眼镜通断

- **无源眼镜**(被动立体眼镜)

  - 偏光眼镜
  - 滤光眼镜-红蓝眼镜

使用大屏幕投影显示立体图像:

//

**固定显示设备**

> **单台投影主动式立体显示:**
>
> - 两倍标准刷新率,有源立体眼镜,分时显示左右眼信息
>
> **单台投影被动式**
>
> //
>
> **多通道被动立体显示:**
>
> - 每个通道两台投影机,分别对应左右眼的图像
>
> **多通道被动立体显示:**
>
> - 边缘融合
> - 伽玛校正
> - //
>
> **相应工作台式显示设备**
>
> **洞穴式投影显示设备**
>
> **三维显示器**

**三维显示器的实现方式**

> 1. 特殊涂层,旅馆器代替立体眼镜
> 2. 投影机 闪投 屏幕快转  好像漂浮的影响
> 3. 多个超薄屏幕 闪投
> 4. 全息图像技术 真实空间创造完整的立体影像

**头盔显示器**

> Head Mounted Display
>
> 装有位置跟踪器,实施测出头部位置和朝向,输入到计算机
>
> 计算机根据数据生成场景图像,由两个显示屏分别提供图像

- 显示屏:CRT(分辨率高)或LCD微机械硅
- 光学作用透镜:调节焦距 (缓解视疲劳,提高适用范围)

**衡量头盔显示器性能:**

> 1. 逼真的立体视觉
> 2. 分辨率
> 3. 视场FOV
> 4. 透射率
> 5. 重叠率
> 6. 重量
> 7. 人的因素



## 2.3手部数据交互设备

### 2.3.1数据手套

数据手套是一种戴在用户手上的传感装置，用于检测用户手部活动的设备，并向计算机发送相应电信号，从而驱动虚拟手模拟真实手的动作。

### 2.3.2空间球

空间球是一种可以提供6自由度的桌面设备，它被安装在一个小型的固定平台上，可以扭转、挤压、按下、拉出和来回摇摆。

### 2.3.3三位浮动鼠标器

三维浮动鼠标器的工作原理是：在鼠标内部安装了一个超声波或电磁探测器，利用这个接收器和具有发射器的固定基座，就可以测量出鼠标离开桌面后的位置和方向。

## 2.4虚拟声音输出设备

为了提供身临其境的逼真感觉，声音输出设备应该满足的**要求**：

- 使人感觉置身于立体的声场之中
- 能识别声音的类型和强度
- 能判定声源的位置

### 2.4.1固定式声音设备

**扬声器**

- 允许多个用户同时听到声音
- 难以达到要求的声音空间定位——难以控制两个耳膜收到的信号，以及两个信号之差。
- 不能包含头部跟踪信息，并用这些信息随着用户头部位置变化适当调节喇叭的输入。

### 2.4.2耳机式声音设备

耳机式声音设备一般与头盔显示器结合使用。在默认情况下，耳机显示的是头部参照系的声音

## 2.5 其他交`互设备

### 2.5.1触觉和力反馈设备   

#### 触觉：

- 利用触感识别所探索对象及其方位；
- 利用触感去操作和移动虚拟物体以完成某种任务 

#### 分类：

- 触觉反馈：来自皮肤表面敏感神经传感器的触感（几何结构，表面硬度、温湿度等）
- 力觉反馈：身体的肌肉、肌健和关节运动所感受到的力量感和方向感 （对象的重量、惯性等）

#### 设备要求：

- 实时性强
- 安全性强
- 轻便、舒适

#### 触觉和力反馈设备

##### 1.接触反馈设备

- 充气式
- 振动式
- 温度式

##### 2.力反馈设备

（1）桌面式力反馈系统设备安装简单、使用轻便灵巧，并且不会因自身重量等问题而让用户在使用中产生疲倦甚至疼痛的感觉，因此目前已经成为较为常用的力反馈设备。

（2）力反馈手套可以独立反馈每个手指上的力，主要用于完成精细操作



### 2.5.2人体运动捕捉设备，数据衣

#### 人体运动捕捉的目的：

把真实人的动作完全附加到虚拟场景中的一个虚拟角色上，让虚拟角色表现出真实人物的动作效果。 

- 从应用角度来看
  - 表情捕捉和身体运动捕捉
- 从实时性来看
  - 实时捕捉系统和非实时捕捉

#### 人体运动捕捉设备一般由四部分组成：

- 传感器
- 信号捕捉设备
- 数据传输设备
- 数据处理设备 

#### 根据传感器信号类型的不同，运动捕捉设备分为：

- 机械式
- 声学式
- 电磁式
- 光学式

##### 声学式、电磁式

原理与三维定位跟踪设备类似

区别在于：在人体上放置多个传感器

##### 光学式

对人体身上特定光点的监视和跟踪来完成运动捕捉的任务。

###### 感光设备

- 高速数字摄像机获取标记

**优点**：

- 工作空间很大，运动不受妨碍，足够快的采样率（适于多数体育运动） 。

**缺点**：

- 最昂贵的运动捕捉系统
- 对光敏感（背景和环境照明都是问题）
- 标记的阻挡(每个标记至少被两个摄像机看到)

微软的**Kinect**交互设备:

精度一般，稳定性也不高。只能处理一些简单的肢体动作。

#### 数据衣（Data Suit） 

数据衣将大量的光纤、电极等传感器安装在一个紧身服上，可以根据需要检测出人的四肢、腰部的活动以及各关节（如腕关节、肘关节）的弯曲角度，然后用计算机重建出图像。

#### 三维扫描仪（3D Scanner）

- 三维扫描仪的功能是通过扫描真实模型的外观特征，构造出该物体对应的计算机模型，通常分为激光式、光学式、机械式等三种类型。
- 三维激光扫描仪（3D Laser Scanner）应用最为广泛，其数据处理的过程一般包括数据采集、数据预处理、几何模型重建和模型可视化等四个步骤。

#### 三维打印机

- 软件程序将三维模型分解成若干个横断面
- 硬件设备使用树脂或石膏粉等材料将这些横断面一层一层的沉淀、堆积，最终形成真实物体。 

### 

# 4 VRML

## 4.2VRML的语法基础

**文件内****定义节点和调用**

```vbscript
DEF yrc Shape {#定义
	geometry Cylinder {
		height 15
		radius 0.5
	}
	appearance Appearance {
		material Material {
			diffuseColor 0 1 1
		}
	}
}
USE	yrc  #使用
```



### 4.2.1VRML的组成要素

> 节点 域 事件(入/出) 路由(连接事件) 脚本 原型

原型:自定义节点 (区别系统节点)

### ~~4.2.2VRML的文件结构~~

### ~~4.2.3VRML的空间计量~~

**1.VRML的空间坐标系**

> **三维坐标**
>
> **原点**:VRML浏览器中心
>
> **X轴**:水平向右
>
> **Y轴**:垂直向上
>
> **Z轴**:正向垂直向前,指向浏览者

**2.计量单位**

> 描述长度的单位:VRML单位,不等同于显示世界/建模工具的计量单位
>
> 描述旋转等单位:弧度
>
> ![image-20210923134943745](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109231349054.png)

**3.色彩**

RGB颜色规范

> RGB范围:0.0~1.0的浮点数,0.0表示关闭,1.0表示完全打开

## 4.3 VRML的空间造型

### 4.3.1造型节点

任何一个VRML虚拟场景中的空间造型必须使用Shape节点创建

**Shape节点的语法格式:**

```visual basic
Shape{
		appearance NULL #SFNode
		geometry NULL	#SFNode单一节点
		}
```

![image-20210928114133135](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/281141216.png)

```visual basic
Shape{
    appearence Appearance{}
    geometry Cone #以域值形式出现的节点
    	{ 
        bottomRadius  3.0
        height  2.0 #默认为2.0
        bottom  FALSE
        #side   默认为TRUE
        }	
}
```



### 4.3.2简单造型节点

### 4.3.3复杂造型节点

#### 4.3.3.1**PointSet**节点

- 不受光源影响,不能粘贴纹理,不能检测碰撞

  > ![image-20210928114206420](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109281143937.png)

  创建一个四棱柱

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109281201568.png" alt="image-20210928120143498" style="zoom:50%;" />

#### **4.3.3.2IndexedLineSet**节点

> 创建由线段组合而成的各种开放或封装的立体几何造型

- 不受光源影响
- 不能粘贴纹理
- 不进行碰撞检测

**格式:**

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109281203239.png" alt="image-20210928120354164" style="zoom:50%;" />

```vbscript
IndexedLineSet	{
		coord  NULL
		coordIndex []
		color   NULL
		colorIndex []
		colorPerVertex  TRUE
              set_coordIndex
              set_colorIndex
}
```

eg:

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109281210840.png" alt="image-20210928121021768" style="zoom: 50%;" />

#### **4.3.3.3IndeedFaceSet**

IndexedFaceSet节点，创建各种由平面组合而成的不规则的立体几何造型。

```vbscript
IndexedFaceSet	{
		coord                       NULL
		coordIndex           	   []
          texCoord                 NULL#纹理坐标
          texCoordIndex        		[]#纹理坐标索引
		color                        NULL
		colorIndex               []#colorIndex[0,1,1,2,2]x号颜色依次给1,2,3,4,5顶点赋值
		colorPerVertex        TRUE      #基于点着色/面着色
		normal                     NULL	#法向  呈现光照明暗变化 	
          normalIndex           	 []		#
          normalPerVertex    		 TRUE	#
          ccw                          TRUE#逆时针方向连接顶点形成的面是正面
          convex                     TRUE#
          solid                         TRUE#
          creaseAngle             0.0
          set_coordIndex
          set_texCoordIndex
          set_colorIndex
          set_normalIndex
}
```

```vbscript
例4-2：将4-1中的五个顶点连成四棱锥体的轮廓线造型。
Shape {
  geometry IndexedFaceSet {
    coord Coordinate{
      point[
        0 2 0
        -1 0 0
        0 0 1 
        1 0 0 
        0 0 -1
      ]
    }
    coordIndex [
      0 1 2 -1
      0 2 3 -1
      0 3 4 -1
      0 1 4 -1
      1 2 3 4 -1
    ]
  }
}
```



### 4.3.4造型的外观设计

> ![image-20210930141605284](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109301442689.png)

#### 4.3.4.1**材质节点:**

> ```vbscript
> Material{
> diffuseColor           0.8 0.8 0.8    漫反射颜色;造型的颜色主要由该域值决定
> ambientIntensity    0.2                有多少环境光被物体表面反射
> specularColor         0 0 0             镜面反射光的颜色
> emissiveColor        0 0 0             自发光物体产生光的颜色
> shininess                 0.2                 物体表面的亮度
> transparency           0                    透明度
> }
> ```
>
> ```vbscript
> [例]柱体 高 1 半径1 黄色
> Shape{
> geometry Cylinder {
>  radius 1
>  height 1
> }
> appearance Appearance {
>  material Material {
>    diffuseColor 1 1 0
>  }
> }
> }
> ```

#### 4.3.4.2**造型的色彩设计:**

简单 同一颜色:diffuseColor

复杂  不同/变化颜色

1.**点集**

> 1. emissiveColor设定单一颜色
>
>    不能使用diffuseColor,点集不受光照影响
>
> 2. color域设置颜色
>
>    `Color{color []}`

2.**面集**

//

#### 4.3.4.3**纹理:**

```vbscript
三种纹理包装节点： 	ImageTexture
                    PixelTexture
                    MovieTexture
```

> **纹理**:位图,二维图形

![image-20211005115252460](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110051152846.png)

> 注：如果不使用textureTransform纹理变换域对纹理图进行缩放处理，浏览器会自动调整纹理图的大小使其恰好填满造型表面。
>
> 只有人为对纹理图进行缩小处理，使纹理图小于造型表面时，才需要设置repeatS和repeatT域的域值。

##### 1.**图像纹理:**

```vbscript
ImageTexture{
	url   [] REM url:指定一个优先级由高到低的图像纹理文件url地址的排序表。或""表示
	url "Koala.jpg"   REM 图片和wrl在同一个文件夹下
	repeatS          TRUE REM repeatS:是否沿S方向重复粘贴。
	repearT          TRUE REM repeatT:是否沿S方向重复粘贴。
}
```

##### 2.**像素纹理:**

```vbscript
PixelTexture{
		Image    0 0 0
		repeatS   TRUE
		repeatT   TRUE
}
```

> 无url域，利用image域将纹理直接存放在VRML文件中，浏览器不必调用外部的纹理文件，可以节约网络下载的时间。

> **其他知识:**
>
> - image：设定对造型进行纹理包装的像素纹理的大小、类型和像素值。该域前三个值必须为整数，第一个数表示纹理宽度，第二个数表示纹理高度，第三个数表示纹理类型.
> - 单元：灰度像素纹理 （0xFF:最亮；0x00:最暗）
> - 双元：灰度加透明度像素纹理
> - 三元：RGB彩色像素纹理
> - 四元：RGB彩色加透明度像素纹理
> - 注：像素纹理图的颜色从左下角第一个像素开始，一直到右上角最后一个像素填满结束。
> - image 2  2  3  
>              0xFF0000   0x00FF00
>              0x0000FF   0xFFFF00   红绿蓝黄依次填充

##### 3.**电影纹理:**

> 支持MPEG1-Systems（包含声音和图像），或者MPEG1-Video（只有图像）。如果电影包括伴音，则当播放时MovieTexture节点为Sound声音节点的source域指定所需的声音文件。

```vbscript
MovieTexture{
url                       [ ]  #路径
loop               FASLE	#是否循环
speed                1.0	#播放速度	
startTime			 0.0	#开始时间 一般由事件传入
stopTime            0.0		#结束时间
repeatS            TRUE		#是否沿着S轴重复粘贴
repeatT            TRUE		#是否沿着T轴重复粘贴
duration_changed         	 #出事件,电影播放时间   /s   -1值表示未被装载
isActive					#出事件,电影是否正在播放
}
```

##### 4.**纹理坐标变换**:

> 创建一个新的纹理坐标系。通过对纹理坐标系的平移、旋转、缩放等操作，改变粘贴在面的图像和电影纹理的位置、角度和缩放比例。

```vbscript
TextureTransform{
translation        0.0   0.0 
rotation            0.0
scale              1.0  1.0
center            0.0  0.0

```

```vbscript
明暗控制:
REM 设置法向可以控制物体造型外观的明暗程度。
IndexedFaceSet	{
		   normal            NULL
          normalIndex         []
          normalPerVertex     TRUE
       }
```



### 4.3.5创建文本造型

![image-20210930141251545](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109301412662.png)

**格式:**

> ![image-20210930141317462](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109301413561.png)
>
> **string**：一行或多行文本，置于双引号内。多行置于多个双引号内，中间用逗号隔开。
>
> **length**: 每一行文本造型的长度。浏览器通过改变字符尺寸或字间距来压缩或扩展。该域值与string域值一一对应。默认为0，不扩展也不压缩。
>
> **maxExtent**:设定文本造型中所对应行的最大有效长度。默认为0，表示对长度无限制。
>
> **fontStyle**：设置文本造型的外观特征。

**文本外观节点:**

> ![image-20210930141524790](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202109301415879.png)

## 4.4 造型的空间变换

### **4.4.1Transform坐标变换节点**

> 用于创建一个或多个不同于默认坐标系的新坐标系
>
> 组节点，在此节点下可包含一个或多个子节点，所有子节点的定位中心都基于同一个坐标系的原点。这些子节点可以是Shape、Group和Transform节点。

```vbscript
Transform{ 	
	children              []#Shape节点
	translation         	 0 0 0#平移向量
rotation               0 0 1 0#旋转轴(0 0 0 连接0 0 1) + 弧度(0)
	scale                     1 1 1#三轴缩放
	scaleOrientation  		0 0 1 0#朝向
###################################################################
	bboxCenter          	0 0 0#包围盒   形状简单,尽量紧密包围
	bboxSize               -1 -1 -1#-1 -1 -1为不设包围盒
	center                   0 0 0#相对移动的中心   0 0 0为自己的中心
	addChildren				#事件
	removeChildren
}
```

## 

### 4.4.2造型编组和素材调用

### 4.4.3**编组和素材调用:**

> VRML提供了一类具有编组功能的节点，它们可以将多个造型作为自己的子节点组合成一个整体，一起进行平移、旋转、缩放、外观设计、定义和调用等。

```vbscript
一 Group编组节点
Group{
children                     []
bboxCenter               0 0 0
bboxSize                   -1 -1 -1
addChildren			REM 事件
removeChildren
}
```

**素材调用的基本方法**

> 1 采用DEF节点定义及USE节点引用的方法，在**本文件范围内**定义和调用**不需要进行改动**的素材，使其成为场景中的一部分；
>
> 2 利用Inline内联节点，从**本文件范围之外**的其他文件或者互联网上，调用不需要进行修改加工的素材，使其成为场景中的一部分；
>
> 3 利用带链接功能的Anchor锚节点，将存储在本机硬盘或互联网上的素材作为一个新的完整场景调用，取代原有场景；
>
> 4 利用PROTO语句和EXTERPROTO语句，在本文件范围内或本文件范围外及互联网上定义原型节点和外部原型节点，调用素材时可根据需要对其原有的属性进行更改或赋予更多的功能。

#### 4.4.3.1**内联:**

```vbscript
Inline{
	url                       “ ”
	bboxCenter       0 0 0
	bboxSize            -1 -1 -1 
}
```

#### 4.4.3.2Anchor**锚链接节点**

```vbscript
Anchor{
		children                             []
		description                        “ ”REM 描述/提示语
	parameter                          []REM 关键字=值
		url                                “ ”REM 替换当前场景的新场景
		bboxCenter                       0 0 0
		bboxSize                           -1 -1 -1
		addChildren
     removeChildren
}
```

#### 4.4.3.3原型的定义和调用

> 前面三类调用只适用于对素材不需要进行加工处理，原汁原味调用的情况，如果需要对素材属性进行更改或赋予更多的功能后调用，可使用PROTO原型节点或EXTERNPROTO外部原型节点，它们可定义可供修改的属性。

原型：即自定义节点。设计者可以根据需要，利用原型创建一种新的节点类型，可通过对节点类型实例化建立新节点，可以为新节点添加各种域和事件。

**原型具有如下功能**：

1. 素材调用功能。（原型可作为素材库，反复调用）
2. 节点扩展功能。
3. 动态更新和保护功能。（通过设置接口中的域和事件，对虚拟现实中造型属性进行更改或者限制更改，从而达到场景的动态更新和保护一些造型不被改动的目的）
4. 造型及动作打包功能。（VRML中标准节点均不具备行为自控能力，通过原型可将造型与交互动作、事件、脚本等VRML元素捆绑使用）
5. 网络动作功能。（原型可在当前文件中定义和反复调用，外部原型可在其他文件和网络中定义，在当前文件中反复调用，提供了跨越网络的强大功能）

```vbscript
PROTO              nodeTypeName rem第一部分

[
field               fieldType域类型     fieldName域名   DEFaultValue默认域值
exposedField可以外部访问的域        fieldType     fieldName   DEFaultValue
eventIn入事件                  eventInType       eventInName
eventOut出事件               eventOutType     eventOutName
] rem 第二部分:接口

{
nodebody           #节点体，定义节点执行内容  rem第三部分
} 
```

> 节点体内的节点在使用节点接口中设置的各种域及事件时，必须使用IS语句进行连接。使用IS语句可以在节点体内反复使用同一个域或事件，但是必须注意接口元素的类型一定要与引用节点中的数据、事件的类型相匹配。

##### 1.内部原型:

使用PROTO语句定义的原型节点，定义和调用必须在同一个VRML文件中运行，应用范围受到限制。

```vbscript
例4-15：使用PROTO语句定义一个名为Coclock的钟表原型节点，并为其设置表身颜色、表身尺寸及钟表位置三个接口域；调用原型节点时，通过设置接口域的域值，改变钟表的位置、颜色及尺寸。

#VRML V2.0 utf8
PROTO COClock
[
	field SFColor bodyColor 1 0 0 # 颜色
	field SFVec3f bodySize 4 4 2 # 大 小
	field SFVec3f bodyPos 0 0 0 # 位置
]
{
	Transform {
		translation IS bodyPos # IS语句连接控制 步
      children [
			Shape {
				geometry Box {
					size IS bodySize # IS语句连接控制 步
				}
				appearance Appearance {
					material Material {
						diffuseColor IS bodyColor # IS语句连接控制 步
					}
				}
			}
		]
	}
}

#成 功
COClock {
	bodyColor 1 1 0
	bodySize 0.1 0.2 3
	bodyPos 0 0 0
}
```

##### 2.外部原型:

> 如果想从其他VRML文件或者网络中调用已经定义了的原型节点，VRML提供了EXTERNPROTO语句用来定义外部原型节点。
>
> 这样，我们可以将所有原型节点集中保存在本机或网络上的某一个VRML文件中，组成原型素材库，方便设计者利用EXTERNPROTO语句定义和调用。

```vbscript
EXTERNPROTO              nodeTypeName
[
field                       fieldType     fieldName   
exposedField         fieldType     fieldName
eventIn                  eventInType       eventInName
eventOut               eventOutType     eventOutName
]rem 接口
url  or   urlList
```

方括号中的接口域，公共域，入事件，出事件应与被引用的外部文件中由PROTO语句定义的原型节点中的完全一致或根据需要取其中的一部分。

如果在指定的外部**文件中包括多个**PTOTO语句定义的**原型节点**，可用以下格式指定要调用的原型节点：

```
“外部文件名#原型节点名”
```

```vbscript
例4-16：新建一个index.wrl，并引用sample4-15.wrl中的钟表原型节点。

#VRML V2.0 utf8
EXTERNPROTO	 COClock
[
	field SFColor bodyColor  # 颜色
	field SFVec3f bodySize  # 大 小
	field SFVec3f bodyPos  # 位置

]
"原型例4-15.wrl"

#成 功
COClock {
	bodyColor 1 1 0
	bodySize 0.1 0.2 3
	bodyPos 0 0 0
}
```

### 4.4.4其他组节点

#### 1.Billboard布告牌节点

无论场景如何移动，始终面向浏览者，便于观察，引起人们的注意。
适用于场景提示、路标指示、布告牌、广告牌及帮助信息等。

```vbscript
Billboard{
children                      [ ]
axisOfRotation            0 1 0默认绕着y轴旋转
bboxCenter                  0 0 0
bboxSize                      -1 -1 -1
addChildren 
removeChildren
}
```

#### 2.Switch开关节点

允许多个场景造型作为子节点并列排放在组内，浏览器每次只能选择其中某一个子场景造型进行渲染。

```vbscript
Switch{
choice                  [ ]
whichChoice        		 -1
}

choice:设定子节点场景造型列表；
whichChoice:设定所要选择的子节点的指针序号
```

#### 3.LOD细节层次控制节点

根据浏览者与造型距离的远近，选择按照不同的细致度刻画的造型。给同一个造型做不同细节程度的模型.

```vbscript
LOD{
level          [ ]REM 放细节不同的模型
center         0 0 0
range           [ ]REM 范围/距离
}
```

使用LOD，一般可为一个对象创建三个不同细节层次的造型，一般不超过五个。各层次造型创建之后，最好采用单独VRML文件形式保存，然后在LOD节点的level域中利用Inline内联节点进行引入和编组。

### 4.5VRML场景效果

### 4.5.1创建背景

VRML**中虚拟空间背景分为**：

- 全景空间背景
  - 将造型包围在里面的空间立方体，具有前、后、左、右、上、下六个平面，可根据需要设置不同的材质和图片。

- 天体空间背景
  - 无穷大的空间球体，分为天空背景和地面背景。天空和地面的划分以地平线为界。
  - 地平线位于原始坐标系XOZ平面向后延伸的无穷远处。

**背景和造型的嵌套关系**：
由内至外：造型->全景空间背景->天体空间背景

- 如果同时增加了全景空间和天体空间两种背景，可通过设置全景空间背景的透明度值决定能否看到天空和地面的颜色。
- 默认：没有全景空间背景，天空和地面均为黑色。

#### 一、Background背景节点

- 可以是任意组节点的子节点，用于在当前坐标系中创建全景空间或天体空间背景。
- 空间背景不受坐标系平移或缩放变换的影响，因此，浏览者在任何情况下都不可能靠近背景，只能从不同角度观察全景空间背景的不同侧面或天体背景中天空和地面的颜色。

```vbscript
Background{
REM 天体控制
skyColor           
            [0.0 0.0 0.0
            0.0 0.0 0.0
            0.0 0.0 0.0]
skyAngle          [ 0.0  0.0]
groundColor      [0.0 0.0 0.0]
groundAngle            [ ]
REM 立方体控制
frontUrl
backUrl
leftUrl
rightUrl
topUrl
bottomUrl
set_bind
isBound
}
```

- **skyAngle**: 天空着色位置所需的空间角。天空角从正上方0度开始，地平线处为90度，到正下方180度为止，天空角必须以升序排列。
  注：约定天空着色的位置在正上方，所以省略起始天空角的设置，天空颜色数目总比天空角数目多一个。
  如果设置的最后一个天空角小于180度，则剩余的空间均由指定的最后一种颜色着色。
- **groundColor**:正下方为地面角的起始位置0度，正上方为地面角180度的位置。必须升序排列。
  如果没有人为设置地面，浏览器只进行天空部分的着色。
- **topUrl**, bottomUrl:通常不设置背景图像，从而能看到天空和地面。
- **set_bind**和**isBound**用于进行空间背景切换。

#### 二、创建单色背景

只需对skyColor域进行设置即可。

#### 三、创建天空背景

```vbscript
例4-18：创建一个多色天空背景，由顶部的蓝色、中间的天蓝色到水平处的白色，形成一个颜色梯度变换的天空背景。
Background {skyAngle [0.78,2.53]
			skyColor [1 1 0 ,0 1 1, 1 0 1]}
```

#### 四、创建地面背景

#### 五、创建全景空间背景

### 4.5.2创建光源

- VRML浏览器自动生成白色头灯光源headlight.此光源为平行光束，与浏览者的视点同步运动，始终照亮浏览者的前方。
- 可通过NavigationInfo节点的headlight域进行设置。默认为打开，且光源颜色无法改变。

#### 4.5.2.1VRML中可人工设置的三类光源：

##### 1.点光源

- PointLight节点
- 由一个发光点向整个空间发射光线。
- 灯炮

```vbscript
PointLight{
on                            TRUE
location                0.0  0.0  0.0 
radius                      100.0

intensity                    1.0
rem点光源的明亮程度。

ambientIntensity       0.0 
rem点光源对照明球体内的造型所产生的环境光线的影响

color                      1.0   1.0   1.0
attenuation            1.0   0.0   0.0
rem 光照范围内光线的衰减方式。
rem 第一个值：是否光线恒定；
rem 第二个值：控制光线按线性方式衰减；
rem 第三个值：控制光线亮度衰减和距离平方之间的关系。
rem 该域所有值都要求大于等于0。

}
```

```vb
例4-19：使用导航节点将系统默认的头灯关闭，在(0 0 1.5)的坐标位置上设置一个白色点光源，引入小球造型组（三行五列），并且与默认头灯照射的效果进行对比。
#VRML V2.0 utf8
NavigationInfo {headlight FALSE }
PointLight {on  TRUE  location 0 5.5 0 intensity 500 color  1 1 1}

Shape {geometry Sphere {radius 0.5 }
		appearance Appearance {material Material {diffuseColor 1 0 0}}}
Transform {children [Shape {geometry Sphere {radius 0.5 }
		appearance Appearance {material Material {diffuseColor 1 0 0}}}]
		translation 0 2 0}

```

![image-20211014142625039](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110141426235.png)

##### 2.平行光源

- DirectionalLight节点
- 始终朝一个特定方向发射光线，在场景中产生一组完全平行的
- 光照效果。
- 太阳光

```vbscript
DirectionalLight{
		on                            TRUE
		direction                0.0  0.0  -1.0
		intensity                        1.0
		color                      1.0  1.0  1.0
}
```

**Direction**:设定平行光源的照射方向。由坐标原点指向这个特定的点

##### 3.锥光源

- SpotLight节点
- 由一个发光点向一个特定方向照亮圆锥体。
- 带罩的台灯

```vbscript
SpotLight{
on                              TRUE
direction               0.0  0.0  -1.0
intensity                      1.0
color                    1.0  1.0  1.0
location               0.0   0.0  0.0
radius                       100.0
beamWidth            1.570796
cutOffAngle           0.785398
ambientIntensity          0.0
attenuation          1.0    0.0  0.0
}
```

- **beamWidth**:在照明锥体中所包含的一个等强度光内部锥体的扩散角，即锥体中心轴到内部锥体表面所形成的夹角。0-1.571之间变化。
- **cutOffAngle**:设定整个照明锥体的扩散角。 0-1.571之间变化。

光源颜色可以在color域中进行设置。

##### 4.创建阴影

- VRML创建的光源与现实中光源的最大差别在于，无**法自动产生阴影**，必须通过**人为设置阴影**造型模拟阴影效果。
- 阴影的形状通常是造型沿光线照射方向形状的压缩和变形，一般利用Transform节点的scale域模拟阴影的形状。阴影颜色通常用Material节点的域值设置为灰色或者半透明的深灰色。

### 4.5.3创建雾化效果

雾化效果两个因素：**颜色、浓度**

VRML中，由Background节点设定的背景图像不会受雾的遮蔽效果的影响，因此设计者强调雾化效果时，最好不使用背景图像，或者便雾的颜色与背景颜色协调相融。

```vbscript
Fog{
color                           1.0  1.0  1.0
fogType                      “LINEAR”
visibilityRange                  0.0
set_bind      
isBound
}
```

- fogType:设定雾的渲染类型。
- “LINEAR”：浓度随观察距离的增大而线性增大
- “EXPONENTIAL”：浓度随观察距离的增大而指数增大，变化程度远远大于线性。
- visibilityRange:可见范围。越大，薄雾；越小，浓雾；距离超过此域值时，造型将完全不可见。

```vbscript
例4-22：创建一个雾化测试场景：平板底托上，由近往远错落排列6根金色圆柱。利用Fog节点增加雾化效果。改变其visibilityRange，观察6根圆柱的可见性。
Fog	{color 1 1 1 fogType "EXPONENTIAL" visibilityRange  10 }
```

![image-20211014143719692](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110141437968.png)

### 4.5.4创建观察视点和视点导航

VRML中，允许创建多视点供选择，但不能同时使用，每个时刻只能选择其中一个视点。随着时间推移，视点之间可以切换。

- **跳跃式**：定义能够在虚拟世界中观察到用户感兴趣的重要的精彩的场景造型的观测点，用户不必观看每一个场景，创建一种快捷方便的观察方式。
- **非跳跃式**：定义随坐标系平滑转换连续变化的观测点。

**Viewpoint**视点节点和**NavigationInfo**导航节点，一个用于设置观察视点，一个用于设置视点的移动方式，两者配合可以创造逼真、美妙的浏览效果。

#### 一、Viewpoint节点

```vbscript
Viewpoint{
position                      0.0  0.0  10.0
orientation                 0.0  0.0  1.0  0.0  观察者面对的方向
fieldOfView                   0.785398
jump                                  TRUE
description                         “ ”
set_bind
isBound
bindTime
}
```

- **fieldOfView**：视角。0-3.141，超过1.047（60度）时观察到的物体会产生显著变形。
- **jump**:视点切换类型是否为跳跃式。
- **Desciption**:描述视点的字符串，即视点名称。它会自动出现在浏览器的视点列表中，通过该域值，人们可以很方便地找到自己感兴趣的视点。
- **Set_bind**入事件isBound出事件：进行VRML空间视点切换。
- **bindTime**:出事件，发出视点被切换的时间，可用来在一个给定的视点被激活时，开始运行一段动画或者执行一段脚本程序。

#### 二、NavigationInfo导航节点

- 创建一个观察者的替身，该替身不可见。利用替身的视角，按照不同的视点导航方式，在虚拟现实空间里漫游。
- 该节点对替身的外表尺寸、浏览方式、浏览速度 、头灯光源等参数时行设置。

```vbscript
NavigationInfo{
headLight                            TRUE
type                                [“WALK”  “ANY”]
speed                                      1.0
visibilityLimit                         0.0
avatarSize                        [0.25  1.6  0.75]
set_bind
isBound
}
```

- type:视点导航方式。共五种。（ WALK， FLY，EXAMINE，ANY，NONE）。
- 默认值表示行走状态为初始浏览状态，用户可在控制面板上选择切换成任何一种浏览方式。

- visibilityLimit:观察者替身的最大观察距离。默认为0，表示可观察到无穷远处。如果观察者在最大观察距离内没观察到任何对象，浏览器将只显示背景图。
  在创建大的三维空间场景时，远处不必显示的造型和场景可以通过合理设置该域值而忽略。
- avatarSize:替身的外表参数。
  - 第一个：外表圆柱体的半径，设置替身进行碰撞和穿越时1/2的厚度和宽度；
  - 第二个：高度，视点距地面的高度；
  - 第三个：抬腿的高度，设置替身能跨越障碍物的最高高度。

### 4.5.5创建音响效果

**Sound**节点用于创建声场并设定声音播放方式，**AudioClipMovieTexture**节点用于创建声源。

#### 一、环境中声音的基本概念

- **WAV**(.wav):适于播放短的声音效果或讲话；
- **MIDI**(.mid):适于演奏背景音乐；
- **MPEG**-1(mpg):适于播放声音和图像同步的影片；

#### 二、Sound节点

用于在VRML中创建声场：设定声源位置及声音的播放方式。

![image-20211019104545370](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110191045499.png)

```vb
Sound{
    source                 NULL  #设定声源。其域值可以是AudioClip节点或者MovieTexture节点。
location              0  0  0
direction             0  0  1
intensity               1.0
maxBack                 10.0
maxFront                10.0
minBack                  1.0
minFront                  1.0
priority                  0.0
spatialize                TRUE
}
```

Source:设定声源。其域值可以是AudioClip节点或者MovieTexture节点。

#### 三、AudioClip节点

引入声源信息，其域值设定从哪里可以引入一个预告录制好的声音文件、声音文件的播放起止时间和播放方式等
该节点只能出现在Sound节点的source域中，可引入WAV文件或者MIDI文件。

```vb
AudioClip{
url                            []
description              “”
loop                         FALSE
pitch                         1.0    快速或慢速播放因子
startTime                   0.0
stopTime                   0.0
duration_changed        #出事件
isActive				#出事件 bool
}
```

## 4.5 动画和交互

VRML使用六种插补器节点(动画)和八种传感器节点(交互)，通过路由在各个造型节点和场景环境节点之间传递事件，为浏览者创建一个身临其境、动态、逼真、可以交互沟通的虚拟环境。

**动画：**

> 物体随时间发生变化的动态效果。

### 动画:

> ##### STEP1：
>
> 由时间传感器控制动画的时钟，包括动画开始的时间、停止的时间、循环的周期等；
>
> ##### STEP2：
>
> 将时间控制参数作为事件传送给各种插补器，插补器依据事先设计好的时间关键点和动画关键值，在浏览器渲染时形成连续变化的动画效果。
>
> 插补器：为线性关键帧动画而设计。
>
> 采用一组相对时间关键点，且每个关键点对应一种关键状态（关键值），该状态允许以各种数据形式表示。
> 浏览器将根据这些关键点所对应的关键状态，在场景中通过线性插值自动生成连续的动画。
> 一般，浏览器在两个相邻关键帧之间生成的连续帧是线性变化的。

------

#### 一、事件和路由的基本概念

节点由域和事件组成。

- 域：决定了节点所创建的造型或场景环境的当前状态；
- 事件：接收外界信息或向外界发送信息的能力。事件是按照指定的路径从一个节点发往另一个节点的信息。
- 路由：以上所提的路径就是路由。通过路由可将多个节点联系在一起，形成事件体系，使事件得以传播而引起节点域值的变化。

##### 时间传感器:

```vb
TimeSensor{
enabled                        TRUE
loop                              FALSE
cycleInterval                   1.0 #周期 单位/s
startTime                           0
stopTime                           0
isActive 
time
cycleTime
fraction_changed   				#输出比例时刻  0~1
}
```

> enabled:时间传感器的使用状态。TRUE表示打开。
>
> **loop**:是否循环输出事件。默认为FALSE，表示不循环，经过一个时间周期后，就会自动停止；若为TRUE，则表示按时间周期自动循环输出，直到stopTime设定的停止时间为止。
>
> **cycleInterval**:时间周期。必须大于0.
>
> startTime:开始输出事件的时间。
>
> stopTime:停止输出事件的时间。若该值小于startTime,则将被系统忽略。
>
> isActive:时间传感器当前的运行状态。
>
> time:时间传感器开始运行后，不断向外输出当前时间。
>
> cycleTime:时间传感器每次循环开始时输出一个当前时间。
>
> **fraction_changed**:时间传感器开始运行后，输出 0到1之间的时刻比例数值。0表示时间周期开始，1表示时间周期结束。

**时间传感器运行状态表**

| loop域值 | startTime,stopTime,cycleInterval域值之间的关系 | 运行状态                       |
| -------- | ---------------------------------------------- | ------------------------------ |
| TRUE     | stopTime≤startTime                             | 无限循环                       |
| TRUE     | startTime<stopTime                             | 循环到stopTime为止             |
| FALSE    | stopTime≤startTime                             | 只运行一个周期                 |
| FALSE    | startTime<(startTime+cycleInterval) ≤stopTime  | 只运行一个周期                 |
| FALSE    | startTime<stopTime< <(startTime+cycleInterval) | 不到一个周期，在stopTime处停止 |

#### 二、colorInterpolator颜色插补器

产生场景造型**变色**的动画效果。**不创建造型**，可以作为任何组节点的子节点。

> 接受时间->设置时间关键点&关键状态值->输出变化颜色

```vb
ColorInterpolator{
key                 []
keyValue            []
set_fraction
value_changed        
}
```

> key:时间关键点的列表。与接收到的set_fraction相对应。0-1之间取值，代表一个时间周期中的相对时刻，对应于时间传感器中的fraction_changed出事件，并要求依次递增排列。
>
> keyValue:设定一系列RGB颜色的关键色彩值。
>
> Set_fraction:入事件，用于不断接收来自时间传感器发出的时刻比例数值。每收到一个时刻值，颜色插补器就在时间关键点和其相应的关键色彩值的基础上计算出一个RGB值，并通过value_changed送出去。
>
> value_changed:输出计算后的色彩值。

```vb
例4-26：变色动画。
画一个倒置的圆锥体，它将产生红、绿、蓝三色交替变换的动画。循环播放 周期十秒
#VRML V2.0 utf8

Transform {children [Shape {geometry Cone {height 2 bottomRadius 1}appearance Appearance {material DEF D_COLOR Material {diffuseColor 1 0 0 }}}]rotation 1 0 0 3.14}
DEF TS TimeSensor {loop TRUE cycleInterval 10}
DEF CIP ColorInterpolator {key [0 0.33 0.67 1]keyValue [1 0 0 0 1 0 0 0 1 1 0 0]}
ROUTE TS.fraction_changed TO CIP.set_fraction
ROUTE CIP.value_changed	 TO	D_COLOR.diffuseColor
```

#### 三、PositionInerpolator位置插补器

产生场景造型位移的动画效果。不创建造型，可以作为任何组节点的子节点。

```vb
PositionInterpolator{
key                     []
keyValue            []
set_fraction
value_changed
}
```

```vb
例4-27：造型位移动画。时间周期为10秒，循环模式；利用位置插补器定位位移路线：从原点出发沿Z轴负向飞向远处，经左前方、右前方、上方，返回原点，循环往复运行。

```

#### 四、OrientationInterpolator朝向插补器

产生场景造型旋转的动画效果。不创建造型，可以作为任何组节点的子节点。

```vb
OrientationInterpolator{
key                     []
  keyValue            [] 
set_fraction
value_changed
}
```

```vb
例4-28：十字棒绕Z轴旋转。两根棒由同一个时间传感器控制时钟，时间周期为9秒，循环模式。两根银色棒分别由各自的朝向插补器控制旋转规律。
#VRML V2.0 utf8

DEF bb Transform {children [DEF BB Shape {
	geometry Cylinder {
		height 3
		radius 0.25
	}
	appearance Appearance {
		material Material {
			diffuseColor 0.5 0.5 0.5
		}
	}
}]}

DEF AA Transform{
  children [USE	bb
  ]
  rotation  1 0 0 1.57
}

DEF	time TimeSensor	{loop TRUE cycleInterval 9}
DEF ori OrientationInterpolator	{key [0 0.5 1]keyValue [0 1 0 0 0 1 0 3.14 0 1 0 6.28]}
ROUTE time.fraction_changed	TO ori.set_fraction
ROUTE ori.value_changed	TO AA.rotation

DEF	time TimeSensor	{loop TRUE cycleInterval 9}
DEF ori OrientationInterpolator	{key [0 0.5 1]keyValue [1 1 0 0 1 1 0 3.14 1 1 0 6.28]}
ROUTE time.fraction_changed	TO ori.set_fraction
ROUTE ori.value_changed	TO bb.rotation

例4-29：变色旋转的动画。

```

#### 六、ScalarInterpolator标量插补器

产生标量改变的动画。

适合用简单的浮点值定义的域值参数（如宽度、高度、半径、亮度和透明度）进行动画控制，例如改变造型的透明度。
不创建造型，可以作为任何组节点的子节点。

```jade
ScalarInterpolator{
key                     []
keyValue            []
set_fraction
value_changed
}
```

```
例4-30：造型旋转并改变透明度的动画。红色椭球体内有一个黄色小正方体，椭球体改变透明度的同时小正方体旋转。二者具有相同的时间周期和循环模式
```

#### 七、CoordinateInterpolator坐标插补器

用于产生基于坐标点的复杂造型(如线集、面集)的变形动画。
不创建造型，可以作为任何组节点的子节点。

```vb
CoordinateInterpolator{
key                     []
keyValue            []
set_fraction
value_changed
}
```

#### 八、NormalInterpolator法向量插补器

用于产生光线明暗变化的动画效果。
不创建造型，可以作为任何组节点的子节点。

```
NormalInterpolator{
key                     []
keyValue                []
set_fraction
value_changed
}
```

```
例4-31：光线明暗变化动画。将黄色四边形平面的法向量由(0 0 1)变化为(0 1 1),再变化至(0 1 0),观察效果。
```

### 交互:

**七种传感器节点**

**第一类：**

通过感知浏览者对鼠标的操作行为（移动、点击、拖动）触发并输出事件，实现交互。

> - TouchSensor
> - PlaneSensor
> -  CylinderSensor
> - SphereSensor

**第二类：**

通过感知浏览者在场景中的观察位置，即当视点与造型的接近程度达到一定范围时，触发并输出事件，实现交互。

> - ProximitySensor
> - VisibilitySensor
> - Collision

#### 一、TouchSensor触摸传感器

用于感知用户鼠标触发的动作。当用户鼠标触摸、单击、按下、松开被感应的造型时，将触发一个动画插补器节点，造型会产生各种动画效果。

```vbscript
TouchSensor{
enabled                      TRUE
isOver      rem鼠标放置触发
isActive	rem鼠标按下时激活输出true
touchTime   rem单机输出时间
hitPoint_changed
hitNormal_changed
hitTexCoord_changed
}
```

**isOver**:

> 当用户移动鼠标光标至被感应的三维造型上的时候，为TRUE，离开时，为FALSE；

**isActive**:

> 当用户在被感应的造型上按下鼠标时，为TRUE，松开时，为FALSE；

**touchTime**:

> 当isOver=TRUE, isActive=TRUE时，引发该事件，所发送的值是当前时间。经常用此事件来控制当用户点击鼠标左键放开后触发的动作。

**hitPoint_changed**:

> 当用户在被感应造型上(由isOver指定)单击鼠标时，发送该值。其值为造型上点击处的坐标。

**hitNormal_changed**:

> 当用户在被感应造型上(由isOver指定)单击鼠标时，发送该值。其值为造型上点击处的法向量。

**hitTexCoord_changed**:

> 当用户在被感应造型上(由isOver指定)单击鼠标时，发送该值。其值为造型上点击处的纹理坐标。

将touchsensor放入Transform的children[]中,进行绑定,可以实现只传感一个造型

#### 二、PlaneSensor平面传感器

用于感知用户在XOY平面上 **鼠标拖拽的动作。用户拖拽造型** 时，造型会按用户的动作在XOY平面上任意移动，但不能改变朝向。

```vbscript
PlaneSensor{
enabled                       TRUE
offset                            0 0 0 
autoOffset                  TRUE
minPosition                  0 0 
maxPosition                -1  -1
isActive
trackPoint_changed
translation_changed
}
```

**enabled**:

> 设定传感器的开与关。

**offset**:

> 设定造型的初始位移量。当用户首次在被感应的造型上点击鼠标时，造型移动位置的坐标值。默认值表示没有人为设置位移量。

**autoOffset**:

> 设定是否记忆上次移动的终点位置。

**minPosition**:

> 设定造型在X和Y轴上的最小移动位置。限制造型的移动范围只能在此点的上方和右侧。

**maxPosition**:

> 设定造型在X和Y轴上的最大移动位置。限制造型的移动范围只能在此点的下方和左侧。

**isActive**:

> 出事件。当用户在被感应造型上按下鼠标按键时，引发isActive=TRUE;当松开鼠标按键时，引发isActive=FALSE;

**trackPoint_changed**:

> 出事件。当用户在被感应造型上单击鼠标时，输出该事件。发送的事件值为造型上所点击的坐标。若使用此时件，则传感器将忽略minPosition和maxPosition域值对移动范围的限制。

**translation_changed**:

> 出事件。当用户用鼠标拖拽造型时，传感器不断输出该事件，发送的事件值为造型移动点的坐标。若使用此事件，则传感器将受minPosition和maxPosition域值对移动范围的限制。

#### 三、CylinderSensor圆柱体传感器(转轴)

用于感知用户绕中心轴拖拽旋转的动作。
当用户鼠标拖拽被感应造型时，造型会按用户的动作绕中心轴（一般是造型所在坐标系的Y轴）任意旋转，造型旋转的轨迹类似于圆柱体。

```vbscript
CylinderSensor{
enabled                      TRUE
offset                         0
autoOffset                   TRUE
minAngle                        0
maxAngle                       -1
diskAngle                     0.262
isActive
trackPoint_changed
rotation_changed
}
```

> 应用:门的开关

**offset**:

> 设定造型的初始旋转角度。

**autoOffset**:

> 设定是否自动记忆上次旋转的终点角度。

**minAngle**:

> 设定造型绕中心轴旋转的最小角度。

**maxAngle**:

> 设定造型绕中心轴旋转的最大角度。
> 注：若minAngle小于maxAngle,则造型绕中心轴旋转的角度限制在两个角度之间；
> 若minAngle等于maxAngle，则造型不能旋转；
> 若minAngle大于maxAngle，则造型可任意旋转；

**diskAngle**:

> 设定圆柱体传感器在圆柱和圆盘两种旋转行为之间的切换角度。该域值决定被感应造型绕中心轴旋转的轨迹像圆柱还是像圆盘。默认为15度。

**isActive**:

> 出事件。按下TRUE，松开FALSE。

**trackPoint_changed**:

> 出事件。在被感应造型上单击鼠标时，输出该事件，发送的事件值为造型上所击点的坐标。

**rotation_changed**:

> 出事件。用鼠标拖拽造型时，不断输出该事件，发送值为造型旋转的角度。

#### 五、SphereSensor球体传感器

用于感知用户绕中心点拖拽旋转的动作。
用户用鼠标拖拽被感应造型时，造型会按用户的动作绕中心点任意旋转，其轨迹类似于球体。

```vbscript
SphereSensor{
enabled                       TRUE
offset                         0 1 0 0
autoOffset                     TRUE
isActive           
trackPoint_changed
rotaiton_changed
}
```

**offset**:

> 设定造型的初始旋转角度。

**autoOffset**:

> 设定是否自动记忆上次旋转的终点角度。

**isActive**:

> 出事件。按下TRUE，松开FALSE。

**trackPoint_changed**:

> 出事件。在被感应造型上单击鼠标时，输出该事件，发送的事件值为造型上所击点的坐标。

**rotation_changed**:

> 出事件。用鼠标拖拽造型时，不断输出该事件，发送值为造型旋转的角度。

```vb
例4-38：首先使用内联节点引入米字造型，然后增加一个SphereSensor球体传感器节点，控制造型对用户的鼠标操作进行反应。可以用鼠标拖拽十字造型绕中心点任意旋转，无朝向限制。
```

#### 六、ProximitySensor接近传感器

用于从浏览者视点所在的方位，感知用户进入、退出设定的空间**长方体区域**的动作。
设定的空间长方体是传感器的感知区域。
当用户进入、退出感知区域时，造型会随用户与其接近程度的变化，触发动画效果。

```vbscript
ProximitySensor{
enabled                     TRUE
center                        0 0 0
size                          0 0 0 
isActive           
position_changed
orientation_changed
enterTime  rem进入的时间
exitTime   rem退出的时间
}
```

position_changed:

> 出事件，当浏览者进入、退出或在感知区域内移动时，输出该事件。发送的事件值为浏览者当前的位置。

orientation_changed:

> 出事件，当浏览者进入或在感知区域内移动时，输出该事件。发送的事件值为浏览者当前位置的坐标空间方向。

例4-39：利用ProximitySensor节点，创建一个自动开关感应门。感应门造型分三部分：金属门框、左右两扇固定的玻璃门和中间两扇活动玻璃门。

#### 七、VisibilitySensor可视传感器

用于从浏览者所在方位（包括位置和朝向），感知一个空间长方体区域，在当前场景中是否可以被看见，据此输出事件触发动画效果。

```vbscript
VisibilitySensor{
enabled                         TRUE
center                            0 0 0
size                                0 0 0 
isActive
enterTime
exitTime
}
```

#### 八、Collision碰撞传感器

用于从浏览者所在的方位，感知用户与该组中任何子节点造型发生碰撞动作。
具有编组和感知传感器双重功能。

```vbscript
Collision{
children               []
collide                 TRUE  rem检测碰撞
proxy                    NULL
bboxCenter           0 0 0
bboxSize               -1 -1 -1
collideTime
addChildren
removeChildren
}
```

> - Children:设定进行碰撞检测的子节点或子节点列表。若同时使用proxy域提供碰撞代体，则以碰撞代体替代children域设置的造型进行碰撞检测。
> - Proxy:设定碰撞代体。其域值可以是VRML中任意合法的组节点和子节点。
> - bboxCenter:设定包围Collision碰撞传感器节点所有子节点的包围盒的中心点坐标。
>
> 如果一个场景没有特别设置 Collision碰撞传感器节点，则VRML认为场景中的所有造型都有可能被碰撞。
>
> 浏览器在浏览时自动检测用户是否会与某个造型发生碰撞，碰撞时的反应由浏览器决定。
>
> 例如，当用户撞上一个实心造型时，浏览器可能将用户弹出此造型或停止其运动过程，如同实际生活中撞到墙壁无法穿越一样。

## 4.6 VRML的脚本节点及编程

### 4.6.1 脚本节点语法 

脚本节点：包括语言程序设计的节点，而且这个程序设计应该能够被浏览器解释并运行。

```javascript
DEF <节点名> Script{
域、输入事件、输出事件定义
url “脚本语言声明：
          脚本语言程序
”
}
```

注：
DEF <节点名>，在语法上不是必需的，但是实际应用中一般总要用到。
vrmlScript是javaScript的一个子集，应用时除特例外，一般和javaScript没有差别。
java的应用和上面的格式有差异。
域、输入输出事件的定义格式如下：

```javascript
field          <域类型>              <域名>        <默认值>
eventIn      <入事件类型>             <入事件名>
eventOut   <出事件类型>             <出事件名>
```



### 4.6.2 脚本节点工作原理

脚本可以由以下4个部分组成：

> (1)一定数目的eventIn, 当接收到事件时引发脚本的执行；
>
> (2)与eventIn对应的**同名函数**，当接收到一个eventIn时执行其中的脚本程序；函数可用于设置Script节点内部的域，实现复杂算法，以及向其他节点发送事件；
>
> (3)在脚本执行过程中，各个函数存储中间数据所使用的域；
>
> (4)在脚本执行过程中，各个函数所发送的eventOut.
>
> 
>
> **过程**:eventin->执行函数->eventout

```javascript
例4-44：一个红色圆柱体，单击鼠标，柱体颜色在红、蓝之间切换。
#VRML V2.0 utf8
DEF	OBJ Shape {
	geometry Sphere {
		radius 0.5
	}
	appearance Appearance {
		material DEF mat Material {
			diffuseColor 1 1 0
		}
	}
}
DEF	 touch TouchSensor {
}
#
DEF chagnecolor Script {
	eventIn SFTime  clicked
		eventOut  SFColor color_changed
		field SFColor blue 0 0 1 #set color blue 
		field SFColor red 1 0 0 #set color red
		field SFBool flag TRUE #sign
		url	"javascript:
	function clicked(){
	if(flag){color_changed=blue;}
	else{	color_changed=red;}
	flag=!flag;
}
"
}
ROUTE touch.touchTime TO chagnecolor.clicked
ROUTE chagnecolor.color_changed	TO mat.diffuseColor

```

```javascript
例4-45：家具选色。单击场景右下方的不同色块，查看与其对应的配色效果。

#VRML V2.0 utf8
DEF	OBJ Shape {geometry Sphere {radius 0.5}appearance Appearance {material DEF mat Material {diffuseColor 1 1 0}}}

Transform {translation -5 -2 0 children [DEF	 touch_red TouchSensor {} Shape {geometry Box {size 0.5 0.5 0.5}appearance Appearance {material Material {diffuseColor 1 0 0}}}]}
Transform {translation -3 -2 0 children [DEF	 touch_green TouchSensor {} Shape {geometry Box {size 0.5 0.5 0.5}appearance Appearance {material Material {diffuseColor 0 1 0}}}]}
Transform {translation -1 -2 0 children [DEF	 touch_blue TouchSensor {} Shape {geometry Box {size 0.5 0.5 0.5}appearance Appearance {material Material {diffuseColor 0 0 1}}}]}





DEF chagnecolor_blue Script {
	eventIn SFTime  clicked
	eventOut  SFColor color_changed
	field SFColor blue 0 0 1 #set color blue 
	url	"javascript:
	function clicked(){
		color_changed=blue;
}
"
}
ROUTE touch_blue.touchTime TO chagnecolor_blue.clicked
ROUTE chagnecolor_blue.color_changed	TO mat.diffuseColor

DEF chagnecolor_green Script {
	eventIn SFTime  clicked
	eventOut  SFColor color_changed
	field SFColor green 0 1 0 #set color 
	url	"javascript:
	function clicked(){
		color_changed=green;
}
"
}
ROUTE touch_green.touchTime TO chagnecolor_green.clicked
ROUTE chagnecolor_green.color_changed	TO mat.diffuseColor

DEF chagnecolor_red Script {
	eventIn SFTime  clicked
	eventOut  SFColor color_changed
	field SFColor red 1 0 0 #set color 
	url	"javascript:
	function clicked(){
		color_changed=red;
}
"
}
ROUTE touch_red.touchTime TO chagnecolor_red.clicked
ROUTE chagnecolor_red.color_changed	TO mat.diffuseColor


```

#### 参数传递：

一般每个节点的eventOut事件都会发出两个值：

- 事件值，即节点的域值；
- 时间值，即事件发出时的时间，从格林威治时间1970年1月1日0时到发出事件时所经过的秒数，绝对时间。

> touchtime发送两个值,事件和时间值是同一个

这两个值要作为参数传递给eventIn事件对应的函数。

### 4.6.3 vrmlScript语言

三、函数
1、脚本程序的几个默认函数
initialize(), print(), eventsProcessed(), shutdown().

2、字符和数值转换函数
parseInt(<字符表达式>，[radix])函数：
能将数值字符转换为整型数值，如果[radix]忽略，则字符表达式中的数值代表十进制数；如果[radix]是16或8，则为十六进制或八进制数。
如果开头字符是非数值字符，则停止转换。
parseFloat((<字符表达式>)函数：
能将数值字符转换为浮点型数值。
如果开头字符是非数值字符，则停止转换。

变量.toString()和变量.valueOf()：
分别能将变量的数值转换为字符串，变量的数值字符转换为数值。
如sz=123.45, 则sz.toString()结果为‘123.45’；
    zf=‘123.45’,则zf.valueOf()结果为123.45.
实际应用时，vrmlScript和javaScript一样有数据类型的自动转换能力。
如print(‘条件运算结果=’+（7>5?9:10）),在控制台上显示的是：条件运算结果=9，这时9已经被自动转换成字符了。

3、数据类型测试函数typeof(<变量名>)
此函数的测试结果可以是number(数值型)、string(字符型)、boolean(逻辑型)、object(对象或数组变量)、function(函数)及undefined(未定义)。

#### 函数

sin(n):n的正弦值.

cos(n):n的余弦值.

random():0.0到1.0间的随机数.

### 4.6.4 实例与练习

#### 上机4.2 颜色随机变化的米字

```javascript
#VRML V2.0 utf8

Shape {
	geometry Cylinder {
		height 3
		radius 0.25
	}
	appearance Appearance {
		material DEF mat1 Material {
			diffuseColor 0.5 0.5 0.5
		}
	}
}

Transform{
  children [
   Shape {
	geometry Cylinder {
		height 3
		radius 0.25
	}
	appearance Appearance {
		material  DEF mat2 Material {
			diffuseColor 0.5 0.5 0.5
		}
	}
}
  ]
  rotation  0 0 1 1.57
}



DEF time TimeSensor	{enabled  TRUE  loop TRUE }
#random script
DEF ColorRandom Script {
	field SFTime initial 0
	eventIn SFFloat  time_changed
	eventOut  SFColor color_changed
	url	"javascript:
	function time_changed(t1,t2){//t1 is useless in this function
		t=t2;
		if((t-initial)>0.1)
		{
			color_changed[0]=Math.random();//R
			color_changed[1]=Math.random();//G
			color_changed[2]=Math.random();//B
			initial=t;//set the initial again to continue the minus
		}
}
"
}
ROUTE time.fraction_changed	 TO	ColorRandom.time_changed
ROUTE ColorRandom.color_changed	TO mat1.diffuseColor
ROUTE ColorRandom.color_changed	TO mat2.diffuseColor


```

#### **上机4.3  颜色变化柱体沿着正弦曲线往返运动**

```javascript
#VRML V2.0 utf8

#VRML V2.0 utf8
DEF position Transform {translation 0 0 0 children [DEF	OBJ Shape {geometry Sphere {radius 0.2}appearance Appearance {material DEF mat Material {diffuseColor 1 1 0}}}]}
DEF time TimeSensor	{enabled  TRUE  loop TRUE }
#random color script
DEF ColorRandom Script {
	field SFTime initial 0
	eventIn SFFloat  time_changed
	eventOut  SFColor color_changed
	url	"javascript:
	function time_changed(t1,t2){//t1 is useless in this function
		t=t2;
		if((t-initial)>0.1)
		{
			color_changed[0]=Math.random();//R
			color_changed[1]=Math.random();//G
			color_changed[2]=Math.random();//B
			initial=t;//set the initial again to continue the minus
		}
}
"
}
ROUTE time.fraction_changed	 TO	ColorRandom.time_changed
ROUTE ColorRandom.color_changed	TO mat.diffuseColor

#cos motion
DEF	CosMotion Script {
	eventIn	SFFloat	time_changed
	eventOut SFVec3f position_changed
	field SFFloat x 0
	field SFTime initial 0	
	field SFInt32 direction 1

	url	"javascript:
	function time_changed(t1,t2){
		t=t2;
		if(direction==1){
			if((t-initial)>0.01){
				position_changed[0]=x;//x
				position_changed[1]=Math.cos(x);//y
				position_changed[2]=0;//z
				x=x+0.1;
				initial=t;
				if(x>5.0){
				direction=0;}
		}
		}
		else {
			if((t-initial)>0.01){
				position_changed[0]=x;//x
				position_changed[1]=Math.cos(x);//y
				position_changed[2]=0;//z
				x=x-0.1;
				initial=t;
				if(x<-5.0){
				direction=1;}
		}
	}}
	"
}
ROUTE time.fraction_changed	TO CosMotion.time_changed
ROUTE CosMotion.position_changed TO position.translation
```

#### 上机4.4  不断选择颜色不断变化的十字

```javascript
#VRML V2.0 utf8

DEF tran Transform {children [
Shape {
	geometry Cylinder {
		height 3
		radius 0.25
	}
	appearance Appearance {
		material DEF mat1 Material {
			diffuseColor 0.5 0.5 0.5
		}
	}
}

Transform{
  children [
   Shape {
	geometry Cylinder {
		height 3
		radius 0.25
	}
	appearance Appearance {
		material  DEF mat2 Material {
			diffuseColor 0.5 0.5 0.5
		}
	}
}
  ]
  rotation  0 0 1 1.57
}

]}


DEF time TimeSensor	{enabled  TRUE  loop TRUE }
#random script
DEF ColorRandom Script {
	field SFTime initial 0
	eventIn SFFloat  time_changed
	eventOut  SFColor color_changed
	url	"javascript:
	function time_changed(t1,t2){//t1 is useless in this function
		t=t2;
		if((t-initial)>0.1)
		{
			color_changed[0]=Math.random();//R
			color_changed[1]=Math.random();//G
			color_changed[2]=Math.random();//B
			initial=t;//set the initial again to continue the minus
		}
}
"
}

DEF ori OrientationInterpolator	{key [0 0.5 1]keyValue [0 1 0 0 0 1 0 3.14 0 1 0 6.28]}
ROUTE time.fraction_changed	 TO	ColorRandom.time_changed
ROUTE ColorRandom.color_changed	TO mat1.diffuseColor
ROUTE ColorRandom.color_changed	TO mat2.diffuseColor
ROUTE time.fraction_changed	TO ori.set_fraction
ROUTE ori.value_changed	TO tran.rotation

```

#### 上机4.5  自己联系灯泡开关脚本的实现

```javascript
#VRML V2.0 utf8
WorldInfo {
  title "Lightbulb - getting silly"
  info [ "Copyright 1999 by Bob Crispen " ]
}
NavigationInfo {
  type [ "EXAMINE" "ANY" ]
  headlight FALSE
}
Group {
  children [
    DEF Entry Viewpoint {#viewpoint
      description "Entry"
      position 0 0 1
    }
    DEF The_Box Transform {
      translation -0.2 -0.2 0
      rotation 0 1 0 0.78
      children [
	Shape {
	  appearance Appearance {
	    material Material {
	      diffuseColor 1 0 0
	      ambientIntensity 0
	    } 
	  }
	  geometry Box { size 0.1 0.1 0.1 }
	}
      ]
    }
    DEF Lightbulb Transform {
      scale 0.35 0.35 0.35
      children [
        # Just enough light so you can see the lightbulb
	# Because this light is grouped with the lightbulb, you shouldn't
	# be able to see the box.
	DEF Dim_Bulb DirectionalLight {
	  direction 0 0 -1
	  intensity 0.3
	}
	Transform {
	  scale 0.193 0.193 0.193
	  children [
	    DEF Light1 PointLight {
	      intensity 1
	      on FALSE
	    }
	    Shape {
	      appearance Appearance {
		material DEF Lightbulb_Color Material {
		  diffuseColor 1 1 1
		  specularColor 1 1 1
		}
	      }
	      geometry Sphere {
		radius 1.4
	      }
	    }
	  ]
	}
	Transform {
	  translation 0 -0.35 0
	  children [
	    Shape {
	      appearance Appearance {
		material DEF Base_Color Material {
		  diffuseColor 1 1 0
		  specularColor 1 1 0
		}
	      }
	      geometry Cylinder {
		height 0.3
		radius 0.135
	      }
	    }
	  ]
	}
	DEF Sensor1 TouchSensor { }
      ]
    }

    DEF Illuminator Script {
      eventIn SFBool touched
      eventIn SFBool mouseover
      field SFBool lit FALSE
      eventOut SFBool light_changed
      eventOut SFColor lightbulb_emissive_color
      eventOut SFColor base_emissive_color
      url [ "javascript:
	function touched(value) {
	  if (value) {
	    if (lit) {
	      lit = false;
	      light_changed = false;
	      lightbulb_emissive_color = new SFColor(0,0,0);
	      base_emissive_color = new SFColor(0,0,0);
	    } else {
	      lit = true;
	      light_changed = true;
	      lightbulb_emissive_color = new SFColor(1,1,1);
	      base_emissive_color = new SFColor(.4,.4,0);
	    }
	  }
	}
	function mouseover(value) {
	  if (value)
	    Browser.setDescription('Click me to turn the light '+
		(lit ? 'off' : 'on'));
	  else
	    Browser.setDescription('');
	}
    " ]
    } 
  ]
  ROUTE Sensor1.isActive TO Illuminator.touched
  ROUTE Sensor1.isOver TO Illuminator.mouseover
  ROUTE Illuminator.light_changed TO Light1.set_on
  ROUTE Illuminator.lightbulb_emissive_color TO Lightbulb_Color.set_emissiveColor
  ROUTE Illuminator.base_emissive_color TO Base_Color.set_emissiveColor
}
```

#### 作业1 

简述虚拟现实系统的工作原理（工作过程）。

> **用户通过操作输入系统，比如传统的鼠标、键盘，以及VR设备的手柄、手势、语音等，对计算机模拟系统完成信号输入。而模拟系统处理完这些信息后，通过输出系统向用户的感官传递信息，比如传统的显示屏、耳机音箱，以及更高级的3D、4D影像，甚至触觉和嗅觉。使用者作出动作时，电脑可以立即进行复杂的运算，将精确的3D世界影像传回，从而产生临场感。\**这个临场感由沉浸、交互与构想三种特性所体现。\****

#### 作业3

(1)为例4-2中由线集画出的四棱锥的轮廓线的每条折线赋予不同的颜色；

(2)为例4-3中由面集构造的四棱锥每个面赋予颜色渐变的效果.

```vbscript
(1)

#VRML V2.0 utf8

Shape {

  geometry IndexedLineSet {

    coord Coordinate{

      point[

        0 2 0

        -1 0 0

        0 0 1 

        1 0 0 

        0 0 -1

      ]

    }

    coordIndex [

      0 1 -1 

      0 2 -1

      0 3 -1

      0 4 -1

	  1 2 -1

	  2 3 -1

	  3 4 -1

	  4 1 -1

    ]

	color Color{

	color 

	[0 1 0

	1 0 0

	0 0 1

	1 1 0

	1 0 1

	0 1 1

	0.8 0.5 1

	0.1 0.1 0.1

	]

	}

	colorIndex [0 1 2 3 4 5 6 7 ]

	colorPerVertex FALSE

}

  

}



#########################################################################

(2)

#VRML V2.0 utf8

Shape {

  geometry IndexedFaceSet {

    coord Coordinate{

      point[

        0 2 0

        -1 0 0

        0 0 1 

        1 0 0 

        0 0 -1

      ]

    }

    coordIndex [

	0 1 2 -1

	0 2 3 -1

	0 3 4 -1

	0 4 1 -1

	1 4 3 2 -1

    ]

	color Color{

	color 

	[0 1 0

	1 0 0

	0 0 1

	1 1 0

	1 0 1

	]

	}

	colorIndex [0 1 2 3 4  ]

	colorPerVertex TRUE

}

}


```

#### 作业4

```vbscript
(1)

#VRML V2.0 utf8

Shape {geometry Box {size 4 4 0.5 }appearance Appearance {material Material {diffuseColor 0.5 0.5 0.5}}}



Transform {children [Shape{geometry Sphere {radius 0.25}}]translation 0 0 0.25}



Transform {children [Shape {geometry Cylinder {height 1.2 radius 0.2}appearance Appearance {material Material {diffuseColor 0.24 0.34 0.6}}}]translation 0 0.6 0.1}

Transform {children [Shape {geometry Cylinder {height 0.7 radius 0.22}appearance Appearance {material Material {diffuseColor 0.24 0.34 0.6}}}]translation 0.4 0 0.1  rotation 0 0 -1 1.57 }



DEF UHR Transform {children [Shape {geometry Sphere {radius 0.2}appearance Appearance {material Material {diffuseColor 1 1 0}}}]translation 0 1.65 0.1}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 0.524}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 1.048}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 1.572}



Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 2.096}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 2.62}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 3.144}



Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 3.668}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 4.192}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 4.716}



Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 5.24}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 5.764}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 6.288}





(2)

LOD{level [

Group {children [#VRML V2.0 utf8

Shape {geometry Box {size 4 4 0.5 }appearance Appearance {material Material {diffuseColor 0.5 0.5 0.5}}}



Transform {children [Shape{geometry Sphere {radius 0.25}}]translation 0 0 0.25}



Transform {children [Shape {geometry Cylinder {height 1.2 radius 0.2}appearance Appearance {material Material {diffuseColor 0.24 0.34 0.6}}}]translation 0 0.6 0.1}

Transform {children [Shape {geometry Cylinder {height 0.7 radius 0.22}appearance Appearance {material Material {diffuseColor 0.24 0.34 0.6}}}]translation 0.4 0 0.1  rotation 0 0 -1 1.57 }



DEF UHR Transform {children [Shape {geometry Sphere {radius 0.2}appearance Appearance {material Material {diffuseColor 1 1 0}}}]translation 0 1.65 0.1}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 0.524}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 1.048}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 1.572}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 2.096}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 2.62}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 3.144}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 3.668}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 4.192}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 4.716}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 5.24}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 5.764}

Transform {children [USE UHR ]center 0 0 0 rotation 0 0 -1 6.288}

]

}

Group {children [#VRML V2.0 utf8

Shape {geometry Box {size 4 4 0.5 }appearance Appearance {material Material {diffuseColor 0.5 0.5 0.5}}}



Transform {children [Shape{geometry Sphere {radius 0.25}}]translation 0 0 0.25}



Transform {children [Shape {geometry Cylinder {height 1.2 radius 0.2}appearance Appearance {material Material {diffuseColor 0.24 0.34 0.6}}}]translation 0 0.6 0.1}

Transform {children [Shape {geometry Cylinder {height 0.7 radius 0.22}appearance Appearance {material Material {diffuseColor 0.24 0.34 0.6}}}]translation 0.4 0 0.1  rotation 0 0 -1 1.57 }

]}

Group {children [#VRML V2.0 utf8

Shape {geometry Box {size 4 4 0.5 }appearance Appearance {material Material {diffuseColor 0.5 0.5 0.5}}}

]}





]range [20 40]}


```

#### 作业5

```
(1)

#VRML V2.0 utf8

DEF ts TimeSensor {loop TRUE cycleInterval 5}

Transform {children [Shape {geometry Sphere {radius 1}appearance Appearance { material DEF mt Material {diffuseColor 0 1 0 transparency 1}}}]scale 1 2 1}

DEF tra Transform {children [Shape {geometry Sphere {radius 0.25}appearance Appearance {material Material {diffuseColor 1 0 0}}}]}

ROUTE ts.fraction_changed TO mt.transparency

DEF or OrientationInterpolator	{key [0 0.33 0.67 1]keyValue [0 1 0 0 0 1 0 1.57 0 1 0 3.14 0 1 0 4.71 0 1 0 6.28 ]}

ROUTE ts.fraction_changed TO or.set_fraction

ROUTE or.value_changed TO  tra.rotation



(2)

#VRML V2.0 utf8

Shape {

   geometry IndexedFaceSet {

     coord  DEF coor Coordinate{

	#vertex

      point[

        0 2 0

        -1 0 0

        0 0 1 

        1 0 0 

        0 0 -1

      ]

    }

    coordIndex [

	0 1 2 -1

	0 2 3 -1

	0 3 4 -1

	0 4 1 -1

	1 4 3 2 -1

    ]



#槣俽

	color Color{

	color 

	[0 1 0

	1 0 0

	0 0 1

	1 1 0

	1 0 1

	]

	}

	colorIndex [0 1 2 3 4  ]

	colorPerVertex TRUE

}}

DEF dd CoordinateInterpolator {key [0 0.2 0.4 0.6 0.8 1]keyValue [

#0

      0 2 0

        -1 0 0

        0 0 1 

        1 0 0 

        0 0 -1

#1

        0 1 0

        0 0 0

        0 0 1

        1 0 0 

        0 0 -1

#2

        0 0 0

        -1 0 0

        0 0 0

        1 0 0 

        0 0 -1

#3

        0 0 0

        -1 0 0

        0 0 1 

        0 0 0 

        0 0 -1

#4

        0 1 0

        -1 0 0

        0 0 1 

        1 0 0 

        0 0 0

#5

         0 2 0

        -1 0 0

        0 0 1 

        1 0 0 

        0 0 -1

		]}

DEF ts TimeSensor {loop TRUE cycleInterval 5 }

ROUTE ts.fraction_changed TO dd.set_fraction

ROUTE dd.value_changed TO coor.point


```

#### 作业6

完成播放电影，影音同步，并设置3-4个视点切换（请包括顶底视图）

```
#VRML V2.0 utf8



Shape{

appearance Appearance	{

material Material {

diffuseColor 0.2 0.3 0.5}}

geometry Box {

size 4 3 0.1}}

Transform {children [Shape{

appearance Appearance {

texture MovieTexture {loop TRUE url ["kkx.mpg"] }}

geometry Box {

size 4 3 0.01}}]translation 0 0 0.05}

Sound {source MovieTexture {loop TRUE url ["kkx.mpg"]}}



Viewpoint {position 0 -10 0 orientation 1 0 0 1.57 description "v1"}



Viewpoint {position 0 10 0 orientation -1 0 0 1.57 description "v2"}



Viewpoint {position 10 0 0 orientation 0 1 0 1.57 description "v3"}



Viewpoint {position -10 0 0 orientation 0 1 0 -1.57 description "v4"}


```

#### 作业7

利用VisibilitySensor可视传感器节点，创建一个用紫红色小球是否可见控制白色正方体造型旋转的场景。紫红色小球的位置与VisibilitySensor可视传感器节点设定的感知区域基本相同，小球可作为感知区域的标志。一旦能够看到小球，正方体开始循环旋转动画；当看不到小球时，正方体旋转一个周期后自动停止运行。

```
#VRML V2.0 utf8
DEF time TimeSensor {cycleInterval 3  enabled TRUE loop TRUE }
DEF oriinter OrientationInterpolator {key [0 0.5 1]keyValue [0 1 0 0 0 1 0 3.14 0 1 0 6.28]}
DEF whitebox Transform  {children [
#boxShape
Shape {geometry Box {size 3 3 3 }}]}
##################################################
#ball_sensor
DEF vs_ball VisibilitySensor {size 0.2 0.2 0.2 center 0 0 7}
Transform {translation 0 0 7 children [
#ball
Shape {geometry Sphere {radius  0.1}appearance Appearance {material Material {diffuseColor 1 0 0.5}}}]}
##############################################
#check whether the ball can be seen
ROUTE vs_ball.isActive TO  time.loop
#run rotating
ROUTE time.fraction_changed TO oriinter.set_fraction
ROUTE oriinter.value_changed TO whitebox.rotation


```

#### 作业8

制作动画：一个球体沿余弦曲线在一个周期内往复循环运动的同时，球体颜色随机变化。

```javascript
#VRML V2.0 utf8
DEF position Transform {
	translation 0 0 0 children [Shape {
		geometry Sphere {
			radius 0.2
		}
		appearance Appearance {
			material DEF mat Material {
				diffuseColor 1 1 0
			}
		}
	}
	]
}
DEF time TimeSensor {
	enabled  TRUE  loop TRUE
}
#random color script
DEF ColorRandom Script {
	field SFTime initial 0
	 eventIn SFFloat  time_changed
	 eventOut  SFColor color_changed
	 url "javascript:
 function time_changed(t1,t2){//t1 is useless in this function
  t=t2;
  if((t-initial)>0.1)
  {
   color_changed[0]=Math.random();//R
   color_changed[1]=Math.random();//G
   color_changed[2]=Math.random();//B
   initial=t;//set the initial again to continue the minus
  }
}
"
}
ROUTE time.fraction_changed  TO ColorRandom.time_changed
ROUTE ColorRandom.color_changed TO mat.diffuseColor
#cos motion
DEF CosMotion Script {
	eventIn SFFloat time_changed
	 eventOut SFVec3f position_changed
	 field SFFloat x 0
	 field SFTime initial 0 
	 field SFInt32 direction 1
	 url "javascript:
 function time_changed(t1,t2){
  t=t2;
  if(direction==1){
   if((t-initial)>0.01){
    position_changed[0]=x;//x
    position_changed[1]=Math.cos(x);//y
    position_changed[2]=0;//z
    x=x+0.1;
    initial=t;
    if(x>5.0){
    direction=0;}
  }
  }
  else {
   if((t-initial)>0.01){
    position_changed[0]=x;//x
    position_changed[1]=Math.cos(x);//y
    position_changed[2]=0;//z
    x=x-0.1;
    initial=t;
    if(x<-5.0){
    direction=1;}
  }
 }}
 "
}
ROUTE time.fraction_changed TO CosMotion.time_changed
ROUTE CosMotion.position_changed TO position.translation
```

