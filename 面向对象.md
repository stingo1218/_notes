平时 30%

- 作业
- 上机
- 表现
- 测验

期末 70%

# 上机考点

![image-20220416151126132](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220416151126.png)

# 1.基本

**关系**

聚合：聚合关系表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，具有关联的导航性与多重性。

> 如：一台电脑由键盘、显示器、鼠标等组成，组成电脑的各个配件是可以从电脑上分离出的，使用带空心菱形的实线来表示。

依赖：[依赖关系](https://so.csdn.net/so/search?q=依赖关系&spm=1001.2101.3001.7020)是指类中用到了对方

泛化：泛化关系实际上就是继承关系，是依赖关系的特例

一般关联：一个对象使用另一个对象的服务

## 面向对象基本特征

1. 抽象
   - 对复杂世界的简单表示，忽略主题无关信息
2. 封装
   - 把数据和实现操作的代码集中起来放在对象内部，尽可能隐蔽内部细节
   - 只留下少量接口以便于与外界联系
   - 对象相互独立，互不干扰
3. 继承
   - 继承前者特性，并添加新特性
   - 哺乳动物--->狗
   - 简化认识
   - 减少代码冗余
   - 多继承
     - 一个子类继承了多个父类特性
4. 多态
   - 不同对象受到相同信息执行不同操作

# 2.C#程序和开发环境

## 2.1 Microsoft .NET技术

软件开发历程:

传统软件开发方法->组件化开发->.NET技术开发

传统:

- 面向过程
- 面向对象

组件化:

- 对象技术和组件技术的结合

.NET:

- 第三代因特网高分布式环境
- 全新跨语言开发平台
- 面向易购网络,硬件平台,操作系统
- 实现软件系统之间的智能交互和协同
- 提供标准化的,安全的,一致的模型和环境

## 2.2 .NET Framework

在Window平台的实现就是.NET Framework,包括

- .NET类库
  - 订了了功能丰富的类型集合,能提供共各种组件服务
- 公共语言运行时CLR
  - 停工.NET运行环境,负责管理代码执行,提供各种系统服务

特点:

- 定义了大量对象和组件,可快速开发
- 系统级操作由CLR负责
- 用户和系统创建都可在CL平台运行

.NET编译原理:

所有程序从源代码编译成与处理器无关的中间语言MSIL,只有运行时才在即时编辑器JIT编译成本机器代码运行,实现跨平台和可移植性

## 2.3 C#语言和特点

由C/C++发展而来

- 简单易学
- 类型安全
- 完全面向对象

C#与.NET关系:

- .NET是编程平台,C#是与.NET Framework一起使用的语言,不是.NET一部分
- .NET支持的一些特性,C#不支持,反之也是

## 2.4 C#程序基本结构

1. 类型

```c#
pbulic class Program
{}
```

2. 成员方法

 - 方法名
 - 返回类型
 - 方法代码

```C#
pbulic class Program
{
	public static void Main()
	{
        System.Console.WriteLine("欢迎光临!");
    }
}
```

3. 命名空间

- 类型调用

```C#
using System//使用命名空间
namespace P2_1//定义空间
{
    pbulic class Program//定义类和结构
  {
	public static void Main()//类中定义方法和成员变量
	{
        System.Console.WriteLine("欢迎光临!");//方法中执行语句
    }
  }
}
```

4. 程序主方法
5. 编译和执行
   - 在DOS环境下的命令方式
     1. 在记事本写入
     2. 配置环境变量
     3. 打开命令行
     4. cd
     5. 编译`csc P2_1.cs`
     6. 执行`P2_1.exe`

**常用成员方法**

| 方法      | 返回值 | 作用          |
| --------- | ------ | ------------- |
| Read      | 整数   | 读一个字符    |
| ReadKey   | 对象   | 读入一个字符  |
| ReadLine  | 字符串 | 读入一行      |
| Write     | 无     | 输出一行      |
| WriteLIne | 无     | 输出一行+换行 |

**C#成员组织**

- 程序集:编译生成程序模块
- 程序集类型
  - .dll文件动态链接库(Dynamic Linking Lib)
  - .exe
- 编译时程序集引用
  - `/refence:filename`
  - `/r:filename`

**C#程序基本结构**

1. 命名空间
   - 代码的基本组合形式,可以并列嵌套
   - 缺省命名空间取项目名称

2. 类型

   - ```c#
     [类修饰符]class[类名][基类或接口]
     {
     	[类体]
     }
     ```

3. 方法
4. 注释

**作业**:动态链接库

```c#
using System;
namespace P1
{
    public class P1
    {
        public static int add(int a, int b)
        {
            return a+b;
        }
    }
}
//写完保存为.dll
csc /t:library P1.cs
/***************/
using System;
namespace P2
{
    class P2
    {
        static void Main()
        {
            Console.WriteLine("请输入2个整数");
            int a=int.Parse(Console.ReadLine());
            int b=int.Parse(Console.ReadLine());
            int c=P1.P1.add(a,b);
            Console.WriteLine("{0}+{1}={2}",a,b,c);
        }
    }
}
//链接
csc /r:P1.dll P2.cs
```

# 3.C#语法基础

## 数据类型

对客观数据对象的抽象,它将数据和对数据的操作封装为一个整体

作用:

- 编译器判断是否参与运算,帮助减少语法错误
- 不同数据类型占用字节不同,节省空间

### 值类型

简单值类型:

- 整数
- ---每个整数类型都对应.NET类库中一个解耦股类型,遮羞结构在System程序集中定义,结构提供MinValue和MaxValue分别表示类型最小值和最大值
  - 单字节
    - 字节型sbyte
    - 无符号字节型byte
  - 双字节
    - 短整型short
    - 无符号短整型ushort
  - 四字节
    - int
      - `int x= new System.Int32();`
    - uint
  - 八字节
    - long
    - ulong
- 字符
- ---采用Unicode编码,一个字符占2个字节
- ---cahr对应于System.Char
  - \n 换行 光标移到下一行
  - \r 回车 光标回到本行开始
- 实数
  - float
    - System.Single
    - 有效位7
    - 4字节
  - double
    - System.Double
    - 有效15-16位
    - 8字节
    - 默认写出小数double
  - decimal
    - 16字节
    - System.Decimal
    - 有效19位
- 布尔
  - System.Boolean
  - true/false
  - 不能0/1

复合值类型:

- 结构

  - 不支持继承和多态

  - ```c#
    struct ComplexNumber
    {
    	public double a;
    	public double b;
    	public void Write()
        {
            Console.WriteLine("{0}+{1}i",a,b)
        }
    }
    ///
    Comlex Number c1;
    c1.a=1.5;
    c1.b=3;
    ///
    CompleNumber c1=new CompleNumber;
    c1.a=1.5;
    c1.b=3;
    ///
    CompleNumber c1=new CompleNumber{c1.a=1.5;c1.b=3};
    ```

- 枚举

  - ```C#
    enum Weekday
    {
        Mon,Tue,Wed,Thu,Fri,Sat,Sun
        //对应 0,1,2,..,6索引
    }
    //声明
    Weekday day1=Weekday.Mon;
    ```

### 引用类型

和值类型区别:赋值后指向同一个内存空间,修改一个变量会影响其他变量  值类型:赋值开辟新空间

- 类

  - string

    - 注意特例 s1=s2 不会指向同一个对象
    - 所有字符串仍是引用类型

  - 允许继承

    - 基类/父类

    - 子类/派生类

    - ```c#
      class Student
      {
          
      }
      class Graduate(父类):Sudent(子类)
      {
          
      }
      ```

    - 继承具有传递性

  - 两个重要类

    - object
      - 是所有类的基类
    - string

- 结构

- 委托

- 数组

  - 具有相同类型的一组对象的集合

  - 数组元素

    - 值类型
    - 引用类型

  - 可作为引用类型

    - 继承System.Array
    - Length
    - GetLength()

  - ```c#
    int[] nums;
    //长度
    nums=new int[3];
    ```

  - 元素存储方法

    - 值类型:直接存储值
    - 引用类型:存地址

      - ```c#
        using System;
        namespace P3_3
        {
            class Program
            {
                static void Main()
                {
                    ComplexNumber c1=new ComplexNumber();
                    c1.a=1.5; c1.b=3;
                    ComplexNumber[] cs=new ComplexNumber[4];
                    cs[0]=c1;
                    cs[1]=new ComplexNumber();
                    cs[1].a=4; cs[1].b=5;
                    cs[2]=c1; cs[3]
                }
            }
        }
        ```
        
        ![img](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220310084638.jpg)
        
        - 多维数组
          - 数组元素长度相等
          - 元素连续存放
          - 声明:
            - `int [,] 数组名`
          - 初始化
            - `a= new int [2,3]`
          - 声明,初始化,赋值同步
            - `int[,] a=new int[2,3]{{1,2,3},{4,5,6}}`
            - `int[,] a=new int[,]{{1,2,3},{4,5,6}}`
        - 数组对象Length属性
          - 整个数组长度
        - Getlength()方法
          - 参数1:第一维长度
          - 参数2:第二维长度
          - 调用:`数组.Getlength(0)`

**转换方式**

- 隐式转换
  - 系统默认,不加声明可转换
- 显式转换/强制转换
  - 要明确指定转换类型

**数值转换**

转换规则

- 低精度->高精度:<u>隐式</u>
- 高精度->低精度:<u>显式</u>
- 同精读无符号->同精读有符号:<u>显式</u>
- 字符->数值 输出ASCII码而不是字符代表数

**枚举转换**

- 转化视为整数
- 隐式:除了枚举变量赋值0以外,无隐式转换

**引用类型之间的转换**

- 类之间
  - 基本规则
    - 派生类->基类:隐式
    - 基类->派生类:显示(不一定成功)
- 类与接口
- 接口之间
- 委托之间
- 数组之间
  - 数组A1到A2转换规则
    - 维数相同
    - 元素均为引用类型
    - 存在从A1数组元素类型到A2数组元素类型的隐式引用转换
  - 显示转换
    - 维数相同
    - 数组元素都是引用类型
    - 存在从A1数组元素类型到A2数组元素类型的显式引用转换

**装箱和拆箱转换**

所有变量都是对象,所有类型都有一个基类---object

object本身是引用类型,素哟偶其他引用类型都可以和他进行交换,object还是所有值类型的基类,所有值类型的变量都可以与object类型转换

- 装箱
  - 值类型--->System.Object

- 拆箱
  - System.Object--->值类型

```c#
int i=123;
object o=i;
int j=(int)o;
```

**转换检查**

- 显示不一定成功
- 编译不检查显式转换,无法预料结果
  - 增加检查代码,避异常

### **操作符和表达式**

用途:处理数据

- 一元
  - ++i
  - i++
- 二元
  - a+b
- 三元
  - a?b:c
- 计算顺序
  - 右结合性:赋值
    - a=b=c=1

#### **算术操作符**

- 枚举变量可以和整数加减运算: 枚举->整数->参与运算->结果转为枚举
- 两个枚举可以相减不能相加
- 字符型可以和整数加减运算
  - `'a'+='b'`

#### **位操作符**

对数据按二进制进行运算的操作符

- 取反~:操作数各位二进制位取反(包括符号位)

  - ```c#
    byte x=20;//00010100(补码,原码)
    //~x=11101011(补码)
    //负数补码求原码规则↓
    //减一
    //取反(不包括符号位)
    //得(1)001 0101=-21
    sbyte y=-10;//11110110
    //~y=00001001=9
    ```

#### **赋值操作符**

- =
  - +=
  - -=
  - *=
  - /=

#### **关系操作符**

- < <= > >= == !=
  - 不支持连等比较

- is
  - 判断左操作数的类型是否是右操作数/右操作数的派生类型

#### 逻辑操作符

- 逻辑非
  - !
- 逻辑与
  - &&
- 逻辑或
  - ||

- 逻辑表达式的短路
  - c=a&&b(a=false--->c=false b不参与运算)

#### 条件操作符

- 操作符
  - ?:
- 表达式b?x:y
  - b true 答案x
  - b false 答案y
  - xy要么同类型,要么可以隐式转换
  - 不是同类型取**<u>精读高</u>**

### 选择结构

- if

- if-else

- if-else if-else

- switch

  - ```c#
    switch(表达式)
    {
        case 表达式1:
            语句1;break;//必须要有break c可以没有
        ...
        default:
            语句;break;
    }
    ```

### 控制结构

- `while`

  > - s=1+2+3+...
  > - s=1-2+3-4+...
  > - s=1+(1+2)+(1+2+3)
  > - s=1+1/2+1/3+...
  > - s=1-1/(1+2)+1/(1+2+3)-...

- `do-while`

  - ```c#
    do{}
    while();
    ```

- `for`

- `foreach`

  - ```c#
    foreach (int i in array)
    {
        语句;
    }
    ```

### 跳转

- `break`退出当前循环
- `continue` 继续下一个循环
- `return`

#### 统计字符中"a"出现次数

```c#
int i=0,max,min;
string x;
a[]=new int[1000];
do
{
    a[i]=Convert.ToInt32(Console.ReadLine());
}
while (Console.ReadLine()="end");
max=a[0];
min=a[0];
foreach(i in a)
{
    if (i>max)
    {
        max=i;
    }
}
foreach(i in a)
{
    if (i<min)
    {
        min=i;
    }
}
Console.Write("min:{0},max:{1}",min,max)
```

#### 找最大值

```c#

```

#### 九九乘法表

```c#
int row=1;
while (row<=9){
  col=1;
  while (col<=row){
    COnsole.Write ("{0}*{1}={2}",row,col,col*row);
    col+=1;
  }
  Console.Write("/r/n");
  row+=1;
}
```



### 作业:杨辉三角

```c#
using System;
namespace trangle
{
    class trangle
    {
        static void Main(string[] args)
        {
            int i = 0;
            int j = 0;
            int n = 0;
            Console.WriteLine("请输入n:");
            n = Convert.ToInt32(Console.ReadLine());
            Console.WriteLine("*********************");
            int[,] a = new int[n, n];
            for (i = 0; i <= n-1; i++)
            {
                for (j = 0; j <= i; j++)
                {
                    if (i == j || j == 0)
                        a[i, j] = 1;
                    else
                        a[i, j] = a[i - 1, j - 1] + a[i - 1, j];
                    Console.Write(a[i, j]+"\t");
                }
                Console.Write("\r\n");
            }
            Console.ReadLine();
        }
    }
}
```

### 练习*

```c#
int i=0,j=0;/*
i=3;		/*
j=(i++)+(++i);  */
Console.WriteLine(j); /*    */
//0  不是8  因为注释
```

```c#
Write("Enter int:");
string s=Console.Readline
int num=int.Parse(s);
in(num++>5)Console.WriteLine(num);
else
Console.Write(--num);
Console.Readkey();
//输入5
//输出5
```

```c#
int i,j,s;
for(i=100;i>=1;i--)
{
	s=0;
	for(j=1;j<=1;j++)
		s+=i+j;
}
Console.WriteLine(s);
//2
```

# 4.类和对象

## 类

```c#
修饰符 class 类名
{

}
```

### 修饰符:

- public:公共
- internal:同一个程序集才可以访问

### 继承

允许继承

所有非私有(private)成员均被继承

```c#
class 子类名:父类名
```

## 4.1成员概述

### 成员种类

- 数据成员
- 函数成员
- 嵌套成员

```c#
public string name//数据成员
public struct Address//嵌套成员
{
    
}
public void Write()//函数成员
{
    
}
```

### 成员访问限制修饰符

- private 私有
  - 只能在类的内部访问
- public 公有
- protected 保护
  - 只能在<u>该类</u>和<u>该类的派生类</u>中访问

-   internal 内部
  - 访问仅限于程序集中

### 静态成员与非静态成员

- 实例成员(非静态)
  - Console.WriteLine(`s1.name`);
- 静态成员
  - public `static` string name;
  - 通过类名访问
  - 首次使用该类即分配空间
  - 所有对象共享这一字段
  - 静态类不能使用new创建对象
  - 静态方法中的代码只能使用类的静态成员
    - 而非静态方法都可以使用

- 字段

  - 一般字段

  - 常量字段

    - ```c#
      public class xxx
      {
          public const double PI=3.14;
      }
      ```

    - 必须在定义时赋值,程序不能修改的字段

    - 默认静态

  - 只读字段

    - ```c#
      public readonly double PI=3.14;
      ```

## 4.2方法

### 方法声明

- 省略修饰符,默认private;
- 不返回结果,默认void
- return后面表达式类型必须和声明的类型相同或可以隐式转换

### 参数类型

- #### 值传递

- #### 引用传递

  - 对形参的修改作用于实参

  - ```c#
    public static void Swap(ref int x,ref int y)
    {
    
    }
    ```

- #### 输出型参数

  - 可将方法的返回结果放在输出型参数中

  - 采用引用传递

  - 输出型形参要求在方法返回之前必须被赋值

  - 期所对应的实参在使用时可以不进行初始化

  - ```c#
    public int SumProd(int x,int y,out int a)
    {
    
    }
    ```

- #### 数组型参数

  - 传递可以是一个数组,也可以是多个元素

    ```c#
    public int Sum (params int [] x)
    {
        return s;
    }
    int []x={1,3,5,7,9};
    int s1=Sum(x);
    int s2=Sum(2,4,6,8,10);
    ```

### 方法的重载

相同的操作统一起一个名字

但是参数不同,使用参数做区别

### 构造函数

- 函数名和类名一样
- 可以带形参
- 没有返回值
- 可以重载
- 在对象定义式自动调用
- 没有构造函数系统会自动生成
- 修饰符总是为public

**静态构造函数**

- <u>首次使用该类时调用</u>

- 没有参数
- 不能有有访问限制

### 析构函数

- 不接受参数
- 没有返回值
- 没有修饰符
- **撤销对象**时自动调用

**练习**  

> 1、定义有公有访问权限的Student类。该类包含私有字段xb（数据类型为bool，代表男生、女生）；私有字段name（数据类型为string，代表学生名字）；构造方法Student(bool xb, string name)；无返回值的方法Introduce()，用于介绍学生：当xb的值为真，方法返回一个字符串"我是男生”，当xb的值为假，方法返回一个字符串 "我是女生”。另外再定义一个类Test，包含有Main()方法，Main()方法中定义学生对象s，设置为女生，名字为张娜，执行Introduce方法。

```c#
using System;
namespace Student
{
    public class Student
    {
        private bool xb;
        private string name;
        public Student(bool xb, string name)
        {
            this.xb = xb;
            this.name = name;
        }
        public void Introduce()
        {
            if (xb == true)
            {
                Console.WriteLine("我是男生");
            }
            else
            {
                Console.WriteLine("我是女生");
            }
        }
    }
    public class Test
    {
        public static void Main()
        {
            Student s = new Student(false, "张娜");
            s.Introduce();
        }
    }
}
```

> 2、编写程序，完成点类和直线类的设计，要求：(1) 编写一个点类Point，描述平面上的点（点的坐标为私有字段，数据类型double）。要求含有无参和有参两个构造函数。(2) 编写一个直线类Line，含有2个点(2个点类对象为私有字段），及计算2点之间距离的方法（方法名Distance）。要求含有无参、将两个点的坐标作为参数、将两个点类对象作为参数的三个构造函数。(3) 在Main()函数中，利用直线类的三个构造函数分别定义直线类对象，并输出两个点的距离（保留小数点后两位小数）。

```c#
using System;
namespace pointandline
{
    class pointandline
    {
        public static void  Main()
        {
            Line l1=new Line();
            Console.WriteLine("l1长度:"+(l1.Distance()).ToString("f2"));
            Line l2=new Line(0,0,3,4);
            Console.WriteLine("l2长度:" + (l2.Distance()).ToString("f2"));

            Point p1 = new Point(0, 0);
            Point p2 = new Point(6, 8);
            Line l3=new Line( p1, p2);
            Console.WriteLine("l3长度:" + (l3.Distance()).ToString("f2"));
        }
    }
    
     public  class Point
    {
        private  double Coordinate_x;
        private  double Coordinate_y;
        public Point()
        {
            Coordinate_x = 0.00;
            Coordinate_y = 0.00;
        }
        public Point(double x,double y)
        {
            Coordinate_x = x;
            Coordinate_y = y;
        }
        public double Getx()//公有方法读取私有字段
        {
            return Coordinate_x;
        }
        public double Gety()//公有方法读取私有字段
        {
            return Coordinate_y;
        }

    }

    class Line
    {
        private Point p1=new Point ();
        private Point p2=new Point ();

        public double Distance()
        {
            double distance = Math.Sqrt((Math.Pow((p1.Getx() - p2.Getx()), 2.0) + Math.Pow((p1.Gety() - p2.Gety()), 2.0)));
            return distance;
        }
        public Line()
        {
            p1 = new Point();
            p2 = new Point();
        }
        public Line(double x1,double y1,double x2,double y2)
        {
            p1 = new Point(x1,y1);
            p2 = new Point(x2,y2);
        }
        public Line(Point pp1,Point pp2)
        {
            p1 = pp1;
            p2 = pp2;
        }
    }

}
```

### 类的特殊方法

#### 属性

控制对字段的访问

属性自身就是函数,但是没有括号

- get()没有参数,默认返回属性类型
- set()默认返回void,隐含了一个与属性类型相同的参数value,表示要传递给属性的值

```c#
public class Student
{
    private string name;
    private string Name//函数
    {
        get{return name;}
        set{name=value;}
    }
}

//调用 
Student s1=new Student();
s1.Name="张三";
```

**自动属性优缺点**

- 简便
- 无法使用私有字段,会随机分配一个未知的字段

#### 索引函数

属性进一步的扩展,以数组的方式控制对对象的多个字段的读写和访问

优点

- 使用时只要在对象名后的中括号指定下标

```c#
public class ClassmateList
{
    private string title;
    private Student [] classmates;
    public Student this[int j]
    {
        get{return classmates[j];}
        set{classmates[j]=value;}
    }
}
//进阶版
public class ClassmateList
{
    private string title;
    private Student [] classmates;
    public Student this[int j]
    {
        get
        {
            if(phone.Length<=4)
            	return classmates[j];
            else 
                return "学生名不正确";
        }
        set{classmates[j]=value;}
    }
}


//使用 对象+下标 访问,方便直观
ClassmateList clist=new ClassmateList("通讯录");
clist[0]=new Student("张三","1231245125");
```

#### 操作符重载

格式

- public **static** ComplexNumner `operator 操作符`

```c#
int x=2;
int y=3;
int z=x+y;
//复数相加
public static ComplexNumner operator +(ComplexNumber c1,ComplexNumber c2)
{
    return new ComplexNumber(c1.x+c2.x,c1.y+c2.y);
}
ComplexNumber c1=new ComplexNumber(2,4);
ComplexNumber c2=new ComplexNumber(2,4);
ComplexNumber c3=c1+c2;
```

##### 一元操作符包括

**++ --**  **！** **~ (T)** **ture** **false**

##### 二元操作符包括

**+ - \* /  % & | ^ << >> == != <= >= < >**

- 说明1：作为一种特殊的函数成员，被重载的操作符必须被声明为公有的和静态的，并通过在关键字operator后跟操作符来声明。   
- 说明2：重载的一元操作符要求有一个参数，且参数类型应与当前类型一致（相同或能进行隐式转换）；重载的二元操作符要求有两个参数，且至少有一个参数类型与当前类型一致（相同或能进行隐式转换）；
- 说明3：考虑到操作对称性，一元操作符true和false，二元操作符==和!=、>和<、以及>=和<=都要求被成对重载。

##### 程序示例1：（解决方案Complex1，项目Reload）

假设空间的某一点的坐标为(x,y,x)，规定为～(x,y,z)关于原点的对称。（需对一元运算符”～”进行重载）

```c#
public static Space operator ~(Space d1)
        {
            Space Neg = new Space();
            //Space Neg =new Space (0,0,0);
            Neg.x = (-1) * d1.x;
            Neg.y = (-1) * d1.y;
            Neg.z = (-1) * d1.z;
            return Neg;
        }
```

### 常用类型

#### object

所有类的基类

- string  ToString() ：获得对象的字符串表示 。
- Type  GetType()：获得对象的数据类型（实际类型）。

```c#
object o1 = new  object();
console.WriteLine(o1.GetType());
o1 = "abc";
Console.WriteLine(o1.GeType());
```

- bool  Equals(object  obj)：判断当前对象与对象obj是否相等（比较两个对象是否为同一引用）。  


```c#
object o1 = new  object();
Student s1 = new Student();
console.Write(o1.Equals(s1));
o1 = s1;
console.Write(o1.Equals(s1));
```

#### string

- 创建对象

  - ```c#
    string s1 = "Visual C#";
    string s2 = new string('M',3);//字符 M 重复复三次
    char[] v = {'V','i','s','u','a','l'};//字符数组
    string s3 = new string(v);//字符数组转字符串
    string s4 = new string(v,0,3);//字符数组v从0开始,取3个字符
    ```

- 字符串转为数组（ToCharArray()方法）

  - ```c#
    string s1 = "北京2008";//中文也占一个字符
    char[] v1 = s1.ToCharArray();
    Console.WriteLine(v1[5]);
    char[] v2=s1.ToCharArray(0,2);//从0开始,取两个
    Console.WriteLine(new string(v2);
    ```

- 字符串比较

  - ```c#
    string s1 = "北京Olympics ";
    int i=s1.CompareTo(" ");
    int j=s1.CompareTo("北京火车站 ");
    int k=s1.CompareTo("北京Olympics");
    ```

- 字符串连接

  - ```c#
    string s1 = "北京 ";
    string s2 = "Olympics ";
    string s3=s1+s2;
    ```

- 字符操作

  - ```c#
    string s1 = "Apple";
    int i = s1.IndexOf('p');//1
    i = s1.LastIndexOf('p');//2  从后往前找
    i = s1.IndexOf('p',2);//从索引2往后找 2
    i = s1.IndexOf('p',3,2);//-1(不包含你要索引的对象)  从索引3往后找两个
    s1 = s1.ToUpper();//"APPLE"
    s1 = s1.Replace('P','A');//"AAALE"
    ```

- 子串操作

  - ```c#
    string s1 = "Software";
    int i = s1.IndexOf("ware");
    string s2 = s1.SubString(0, 4);
    string s3 = s2.Insert(0, "Micro");//在索引0之前
    s1 = s3.Replace("soft", "sun");
    ```

- 格式化和解析

  - ```c#
    静态方法Format，对字符串进行参数格式化
    string s1 = string.Format("{0}年级{0}班",1,3);
    int x = 8;
    s1 = string.Format("{0}年{1}月", 2019, x);
    s1 = string.Format("{0:C3}元", 9999)
    ```

  - ```c#
    class ComplexNumber
    {
      double a, b;
      public override string ToString()
      {
        return string.Format("{0}+{1}i",a, b);    
      }  
      public static ComplexNumber Parse(string s)
      {
        string[] ss = s.Split(',');
        double a = double.Parse(ss[0]);
        double b = double.Parse(ss[1]);
        return new ComplexNumber(a, b); 
      }
    }
    ```

    **作业**
    
    ```c#
    using System;
    namespace Complex1
    {
        public class ComplexNumber
        {
            private double x, y;
            public double X //实数部分
           {
              get { return x;}
              set { x = value; }
            }
           public double Y //虚数部分
           {
              get { return y; }
              set { y = value; }
            }
          public ComplexNumber(double x1, double y1)
          {
               x = x1;
               y = y1;
           }
           public static ComplexNumber operator +(ComplexNumber c1, ComplexNumber c2)
           {
              return new ComplexNumber(c1.x + c2.x, c1.y + c2.y);
           }
           public static ComplexNumber operator - (ComplexNumber c1, ComplexNumber c2)
           {
                return new ComplexNumber(c1.x - c2.x, c1.y - c2.y);
            }
           public static bool operator == (ComplexNumber c1, ComplexNumber c2)
          {
                return (c1.x==c2.x) && (c1.y==c2.y);
           }
           public static bool operator !=(ComplexNumber c1, ComplexNumber c2)
           {
               return (c1.x != c2.x) || (c1.y != c2.y);
            }
           public static bool operator >(ComplexNumber c1, ComplexNumber c2)
           {
               double a = c1.x*c1.x + c1.y*c1.y;
               double b = c2.x*c2.x + c2.y*c2.y;
               return a > b;
            }
           public static bool operator >=(ComplexNumber c1, ComplexNumber c2)
           {
                return c1 == c2 || c1> c2;
           }
           public static bool operator <(ComplexNumber c1, ComplexNumber c2)
           {
               return !(c1 >= c2);
           }
           public static bool operator <=(ComplexNumber c1, ComplexNumber c2)
           {
               return !(c1 > c2);
           }
           public override string ToString()//使用关键字override重载方法
           {
               return string.Format("{0}+{1}i", x, y);
           }
           public static ComplexNumber Parse(string s) //输入(a,b)返回复数类型(a,b)
           {
               string[] ss = s.Split(',');
               double a = double.Parse(ss[0]);
               double b = double.Parse(ss[1]);
               return new ComplexNumber(a, b);
           }
        }
        class Program
        {
            static void Main(string[] args)
            {
                Console.WriteLine("请输入第1个复数的实部和虚部(a,b)：");
                ComplexNumber c1 = ComplexNumber.Parse(Console.ReadLine());
                Console.WriteLine("请输入第2个复数的实部和虚部(a,b)：");
                ComplexNumber c2 = ComplexNumber.Parse(Console.ReadLine());
                ComplexNumber c3 = c1 + c2;
                Console.WriteLine("({0})+({1})={2}",c1,c2,c3);
                Console.WriteLine(c1 <= c2);
                //其它比较操作略
                Console.ReadLine();
            }
        }
    }
    ```

#### StringBuilder

- ```c#
  //低性能
  string s1 = "";
  for(int i=0; i<100; i++)
    s1 += i.ToString()
  //高性能
  StringBuilder s1 = new StringBuilder();
  for(int i=0; i<100; i++)
    s1.Append(i);
  ```

#### Math(静态类)

- 取整函数:ABs,Ceiling,Floor,Round
- 指数和对数函数:Exp,Pow,Log,Log10
- 三角函数:Sin,Cos,Tan,Asin,Acos,Atan

#### DateTime结构类型

```c#
DateTime dt1=new DateTime(2022,3,22);
DateTime dt1=new DateTime(2022,3,22,10,8,18);
Year, Month, Day, Hour, Minute, Second  //实例属性
Now, Today  //静态属性
AddYears(), AddDays(), AddHours() ...  //实例方法
ToString(), Parse(), TryParse()    //实例方法
```

```c#
class Age
{
    public int GetAge(DateTime birthday)
    {
        int y=DateTime.Now>year;
        int m=DateTime.Now.Month;
        int d=DateTime.Now.Day;
        if(d<birthday.Day) m--;
        if(m<birthday.Month) y--;
        return y-birthday.year;
    }
}
```

# 5.继承和多态

## 5.1继承

### 基类和派生类

构造类的层次结构的方法

- 自顶向下的分解
  - 从基类向下分解，不断得到新的派生类型

- 自底向上的抽象
  - 对现有一组类型抽象，得到新的基类

#### .NET类库

![image-20220329095922884](C:\Users\syc\AppData\Roaming\Typora\typora-user-images\image-20220329095922884.png)



#### 例子

```C#
 class Animal
    {   private int weight;
        public int Weight{ get; set; }
        private int age;
        public int Age{ get; set; }
        public void output()
        {Console.WriteLine("Age:{0}", age);
         Console.WriteLine("Weight:{0}", weight);
        }
    }


 class Dog : Animal
    {  public void Speak()
        {    Console.WriteLine("汪汪...");    }
    }

 Dog d = new Dog();
 d.Age = 3;  d.Weight = 6;
 d.output(); d.Speak();
```

```c#
public class Automobile
{
  protected float speed = 100;//保护成员在子类中可用 //公有属性子类可以直接引用
  public float Run(float distance) {
    return distance/speed;
  }
}
public class Bus : Automobile
{
    Automobile a1 = new Automobile();
    a1.Run(1000);
    Bus b1 = new Bus();
    b1.Run(1000);
}
```

1.对基类的**私有字段**，在派生类中需要通过其**公有属性间接访问**。

2.对基类的**保护成员**，在**派生类**中可以**直接访问**，但在此基类及其所有的派生类以外，不能访问。

3.**基类的可访问性不应低于派生类**。即，如果外部程序集能够访问某个类，那么同时就能访问其基类。

### 隐藏基类成员

含义：派生类与基类成员同名，但希望提供不同的服务。

说明：

1.如果派生类中定义了与基类相同的成员（字段名称和类型相同；或是方法名称、参数列表和返回类型相同），默认情况下基类成员在派生类中会被隐藏。

2.为提高代码可读性，C#建议使用**new关键字**（此处是修饰符）来明确修饰派生类中的成员。

3.在成员隐藏时，调用哪一个成员取决于对象的声明类型。

```c#
Animal a=d;
a.output();//调用基类的方法,因为没有使用new来创建对象
d.output();//调用子类的方法
```

p5_2

```c#
using System;
namespace P5_2
{
    class Program
    {
        static void Main()
        {
            Truck t1 = new Truck();
            Console.WriteLine("卡车速度{0}公里/小时", t1.Speed);
            Console.WriteLine("卡车行驶1000公里需{0}小时", t1.Run(1000));
            Automobile a1 = t1;//派生类可以送给基类对象  a1实际类型是truck 声明类型atutomobile
            Console.WriteLine("汽车速度{0}公里/小时", a1.Speed);
            Console.WriteLine("汽车行驶1000公里需{0}小时", a1.Run(1000));
            Console.ReadLine();
        }
    }
    public class Automobile
    {
        protected float speed;
        public float Speed
        {
            get { return speed; }
            set { speed = value; }
        }
        private float weight;
        public float Weight
        {
            get { return weight; }
            set { weight = value; }
        }
        public float Run(float distance)
        {
            return distance / speed;
        }
    }
    public class Truck : Automobile
    {
        private float load;
        public float Load
        {
            get { return load; }
            set { load = value; }
        }
        public new float Speed  //修改Speed属性 new覆盖从基类继承过来的成员
        {
            get { return speed / (1 + load / Weight / 2); }
        }
        public Truck()//省略了 :base()    首先要执行:base()  ---基类的构造函数 执行完成再执行Truck() 
        {
            load = 30;
            speed = 50;
            Weight = 15;
        }
        public new float Run(float distance)   //修改Run方法
        {
            //return (1 + load / Weight / 2) * base.Run(distance);
            return (1 + load / Weight / 2) * distance/speed ;
            //return distance / Speed;
        }
    }
}
```

讨论

```c#
using System;
namespace shuchujieguo1
{   class Program
    {   static void Main(string[] args)
        {  A a = new A(); B b = new B(); A c = b;//a调用A方法  c的声明类型是A,实际类型B,所以调用A
            a.Method(); c.Method();    }    }
    class A
    {  public  void Method()
        { Console.Write("认真"); }  }
    class B : A
    {  public new void Method()
        { Console.Write("仔细");    }    }
}
//认真认真
```

### base关键字

功能：

1. 用以访问基类成员
2. 调用基类的构造函数

```c#
		public Truck():base()    //首先要执行:base()  ---基类的构造函数 执行完成再执行Truck() 
        {
            load = 30;
            speed = 50;
            Weight = 15;
        }

		public new float Run(float distance)   //修改Run方法
        {
            return (1 + load / Weight / 2) * base.Run(distance);//base.成员 调用积累的方法
            //return (1 + load / Weight / 2) * distance/speed ;
            //return distance / Speed;
        }
```

说明：
1.当派生类成员隐藏了基类成员时，在派生类中，直接写出成员名表示派生类的成员，而**增加了base引用的成员表示被隐藏的基类成员**。
2.如果派生类的方法是在基类方法的基础上增加功能，**通过base关键字能有效减少派生类中的代码量**。

### 对象生命周期

```c#
public class Vehicle {} 
public class Automobile : Vehicle {}
public class Car : Automobile {}
public class Limousine : Car {}
```

#### 构造函数执行顺序

**创建**Limousine对象时

![image-20220331092240736](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331092240.png)

#### 析构函数

**销毁**Limousine对象时

![image-20220331092403377](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331092403.png)

**p5_3**

```c#
using System;

namespace P5_3
{
    class Program
    {
        public static void Main()
        {
            Son s1 = new Son();
            //System.GC.Collect();//强制执行析构函数
            Console.ReadLine();
         }
        
    }

    public class Grandsire
    {
        public Grandsire()
        {
            Console.WriteLine("调用Grandsire的构造函数");
        }

        ~Grandsire()
        {
            Console.WriteLine("调用Grandsire的析构函数"); 
        }
    }

    public class Father : Grandsire
    {
        public Father()
        {
            Console.WriteLine("调用Father的构造函数");
        }

        ~Father()
        {
            Console.WriteLine("调用Father的析构函数");
        }
    }

    public class Son : Father
    {
        public Son()
        {
            Console.WriteLine("调用Son的构造函数");
        }

        ~Son()
        {
            Console.WriteLine("调用Son的析构函数");
        }
    }
}
```

可见，当用派生类创建对象时，将依次执行基类（从上至下）的构造函数，最后执行自身的构造函数。
**那么，当基类有多个构造函数时，到底执行哪一个？**

解决方法：
在派生类构造函数的定义中，通过base关键字指定创建对象时要调用的基类构造函数。

```c#
假设Automobile类定义了如下3个构造函数：
Public Automobile()
{  }
Public Automobile(float speed)
{ this.speed=speed; }
Public Automobile(float speed, float weight)
{ this.speed=speed;  this.weight=weight; }

那么，对于如下的派生类Truck的构造函数，使用其创建对象时将调用基类的第2个构造函数：
Public Truck(float speed) : base(speed)//第一个speed是形参 第二个speed实参
{load=30;Weight=15;}

而如果改为下面写法，将调用基类的第3个构造函数：
Public Truck(float speed) : base(speed，15)
{load=30;}
```

说明：
1.此时base的作用是指代基类的构造函数，**这种方式只能出现在派生类的构造函数中**，而不允许出现在方法代码中。

2.如果派生类的构造函数中没有出现base关键字，那么**默认调用的是基类的无参构造函数**。

3**.如果基类中只定义了带参数的构造函数**，那么，派生类的构造函数定义时，**必须通过base关键字来指明继承的是哪一个基类的带参构造函数**。

**事例演示**

```c#
using System;

namespace P5_3_1
{
    class Program
    {
        static void Main()
        {
            Truck t1 = new Truck(50);
            //Truck t1 = new Truck();
            Console.WriteLine("卡车速度{0}公里/小时", t1.Speed);
            Console.WriteLine("卡车行驶1000公里需{0}小时", t1.Run(1000));
            Automobile a1 = t1;
            Console.WriteLine("汽车速度{0}公里/小时", a1.Speed);
            Console.WriteLine("汽车行驶1000公里需{0}小时", a1.Run(1000));
            Console.ReadLine();
        }
    }

    public class Automobile
    {
        protected float speed;
        public float Speed
        {
            get { return speed; }
            set { speed = value; }
        }

        private float weight;
        public float Weight
        {
            get { return weight; }
            set { weight = value; }
        }

        public Automobile()
        {
            speed = 60;
            weight = 10;
            Console.WriteLine("基类无参构造函数");
        }

        public Automobile(float speed)
        {
            this.speed = speed;
            Console.WriteLine("基类一个参数构造函数");
        }

        public Automobile(float speed, float weight)
        {
            this.speed = speed;
            this.weight = weight;
            Console.WriteLine("基类两个参数构造函数");
        }

        public float Run(float distance)
        {  return distance / speed;  }
    }

    public class Truck : Automobile
    {
        private float load;
        public float Load
        {
            get { return load; }
            set { load = value; }
        }

        public new float Speed
        {  get { return speed / (1 + load / Weight / 2); }   }

        public Truck(float speed)
            : base(speed, 15)  //如果将: base(speed, 15)注释掉，如何分析结果？//会等于public Truck(float speed):base()   speed传进来50 调用基类构造函数成60 最终为60   weight为基类的10
        {
            load = 30;
            //Weight = 15;
        }
        public Truck()//:base()      //先执行基类构造函数 speed=60 接着调用自身构造函数 speed=50 
        { load = 30; speed = 50; Weight = 15; }

        //public Truck(float speed) : base(speed)
        //{
        //    load = 30;
        //    Weight = 15;
        //}

        public Truck(float load, float speed, int w)
        {
            this.load = load;
            this.speed = speed;
            Weight = w;
        }
        public new float Run(float distance)
        {
            //return (1 + load / Weight / 2) * base.Run(distance);
            return (1 + load / Weight / 2) * distance / speed;
        }
    }
}

```

## 5.2多态性

- 基类：普通成员
- 派生类：隐藏基类成员

```c#
public class Automobile
{
  protected float speed;
  protected float weight; 
  public float Run(float distance) {
    return distance/speed;
  }
}
public class Car : Automobile
{
  public new float Run(float distance) {
    return (1+weight/100) * distance/speed;
  }
}
```

隐藏（覆盖）：<u>根据**声明类型**决定成员调用</u>----**new**

![image-20220331101041316](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331101041.png)

### **必考考点**

同名方法不同对象做不同动作

#### 基类：虚拟方法

```c#
public class Automobile
{
  protected float speed;
  protected float weight; 
  public virtual float Run(float distance) {
    return distance/speed;
  }
}
```

#### 派生类：重载方法

<u>重载：根据**实际类型**决定成员调用</u>----**override**

![image-20220331102050493](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331102050.png)

```c#
using System;
namespace shuchujieguo1
{   class Program
    {   static void Main(string[] args)
        {  A a = new A(); B b = new B(); a = b;//a实际类型为B
            a.Method(); b.Method(); Console.ReadLine();   }    }
    class A
    {  public virtual void Method()
        { Console.Write("老师"); }  }
    class B : A
    {  public override void Method()
        { Console.Write("学生); } }
}
//学生学生
```

**案例**

```c#
using System;

namespace P5_4
{
    class Program
    {
        static void Main()
        {
            foreach (Automobile a in GetAutos())
            {
                    a.Speak();
                    Console.WriteLine("{0}行驶1000公里需{1}小时", a.Name, a.Run(1000));
             }

            Console.ReadLine();
        }

        static Automobile[] GetAutos()
        {
            Automobile[] autos = new Automobile[4];
            autos[0] = new Bus(20);
            autos[1] = new Truck(30);
            autos[1].Name = "卡车甲";
            autos[2] = new Truck(45);
            autos[2].Name = "卡车乙";
            autos[3] = new Automobile(80, 3);
            return autos;
        }
    }

    public class Automobile  //汽车类
    {
        private string name;
        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        private float speed;
        public float Speed
        {
            get { return speed; }
            set { speed = value; }
        }

        private float weight;
        public float Weight
        {
            get { return weight; }
            set { weight = value; }
        }

        public Automobile(float speed, float weight)
        {
            name = "汽车";
            this.speed = speed;
            this.weight = weight;
        }

        public     float Run(float distance)   //Automobile类的Run方法
        {
            return distance / speed;
        }

        public  virtual void Speak()      //Automobile类的Speak方法
        {
            Console.WriteLine("汽车鸣笛...");
        }
    }

    public class Bus : Automobile
    {
        private int passengers;
        public int Passengers
        {
            get { return passengers; }
            set { passengers = value; }
        }

        public Bus(int passengers) : base(60, 10)
        {
            Name = "客车";
            this.passengers = passengers;
        }

        public new  void Speak()      //Bus类的Speak方法
        {
            Console.WriteLine("客车嘀...嘀....");
        }
    }

    public class Truck : Automobile
    {
        private float load;
        public float Load
        {
            get { return load; }
            set { load = value; }
        }

        public Truck(int load): base(50, 15)
        {
            Name = "卡车";
            this.load = load;
        }

        public new  float Run(float distance)    //Truck类的Run方法
        {
            return (1 + load / Weight / 2) * base.Run(distance);
        }

        public new void Speak()          //Truck类的Speak方法
        {
            Console.WriteLine("卡车叭...叭...");
        }
    }
}
```

### 抽象类

现实生活中有很多抽象概念，它本身不与具体的对象相联系，但可以为其派生类提供一个公共的界面。这类概念可定义为抽象类，用abstract关键字来修饰。如图形，每一个图形对象都是其派生类的实例。

**抽象方法**:<u>写不出具体代码</u>

```c#
public abstract class Automobile
{
  protected float speed;
  protected float weight; 
  public abstract float Run(float distance);
}
```

- **说明1:不能用new创建(定义)抽象类对象**

![image-20220405092533888](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405092533.png)

**但是**

```c#
Autobile a1=new Car();//可以接受派生类对象
```

抽象类常会有这种情况：其所有派生类都应提供某个方法，但无法为这些方法定义一个统一的实现形式。C#使用abstract关键字将此类方法定义为抽象方法，抽象方法没有实现代码。

- **说明2：一个抽象类的<u>非抽象</u>的派生类，必须重载基类中的所有抽象方法，并为这些方法提供具体实现。**

- **说明2：一个抽象类的<u>抽象的</u>派生类，也必须<u>重载</u>基类中的所有抽象方法，且重载方法要么提供具体实现，要么也是抽象的（同时使用override和abstract修饰符）。**

![image-20220405092938071](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405092938.png)

```c#
using System;

namespace P5_5
{
    class Program
    {
        static void Main()
        {
            Vehicle v1 = new Train();
            v1.Speak();
            Console.WriteLine("行驶1000公里需{0}小时", v1.Run(1000));
            v1 = new Truck(16, 32);
            v1.Speak();
            Console.WriteLine("行驶1000公里需{0}小时", v1.Run(1000));
            Console.ReadLine();
        }
    }

    public   abstract class Vehicle  //抽象类
    {
        private float speed;
        public float Speed
        {
            get { return speed; }
            set { speed = value; }
        }

        public Vehicle(float speed)
        {
            this.speed = speed;
        }

        public virtual float Run(float distance) //虚拟方法
        {
            return distance / speed;
        }

        public abstract  void Speak(); //抽象方法：无执行代码
    }

    public class Train : Vehicle  //派生类
    {
        public Train() : base(200)
        { }

        public override void Speak() //重载方法
        {
            Console.WriteLine("呜......");
        }
    }

    public abstract class Automobile : Vehicle
    //一个抽象类的抽象的派生类，也必须重载基类中的所有抽象方法，
    //且重载方法要么提供具体实现，要么也是抽象的（同时使用override和abstract修饰符）。
    {
        public Automobile(float speed): base(speed)
        { }

        public override abstract void Speak(); //重载+抽象
    }

    public class Truck : Automobile
    {
        private float weight;
        public float Weight
        {
            get { return weight; }
        }

        private float load;
        public float Load
        {
            get { return load; }
        }

        public Truck(int weight, int load) : base(50)
        {
            this.weight = weight;
            this.load = load;
        }

        public override float Run(float distance) //重载
        {
            return (1 + load / Weight / 2) * base.Run(distance);
        }

        public override void Speak() //重载
        {
            Console.WriteLine("叭...叭...");
        }
    }
}
```

### 密封类和密封方法

如果某个类不允许或是**不需要再有派生类型**，在C#中可用sealed修饰符将其定义为密封类。

```c#
public sealed class Truck : Automobile
{
  private float load;
  public override float Run(float distance){
    return base.Run(1+(load+weight)/100);
  }
}
```

![image-20220405100059065](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405100059.png)



#### 密封方法

```c#
public class Truck : Automobile
{
  private float load;
  public sealed override float Run(float distance){
    return base.Run(1+(load+weight)/100);
  }
}
```

![image-20220405100410202](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405100410.png)



# 第6章  委托和事件

## 委托封装方法

示例程序P6_0：输入2个数据，根据用户需要，输出和、差、积、商

委托是一种特殊的引用类型，它将方法也作为特殊的对象封装起来，从而将方法作为变量或参数进行传递。

**一个方法的方法名作为另一个方法的参数**

### 第一步:委托类型定义

委托是一种特殊的引用类型

```c#
delegate void DualFunction(int x, int y);//与要绑定的方法原型一致

public static void Add(int x, int y) 
{
  Console.WriteLine("{0}+{1}={2}", x, y, x+y);
} 
```

### 第二步:委托对象创建

```c#
delegate void DualFunction(int x, int y);

public static void Add(int x, int y) 
{
  Console.WriteLine("{0}+{1}={2}", x, y, x+y);
}

public static void Main()
{
  DualFunction fun1 = new DualFunction(Add); 
}
```

### 第三步:调用方法

```c#
delegate void DualFunction(int x, int y);
public static void Add(int x, int y) 
{Console.WriteLine("{0}+{1}={2}", x, y, x+y);
}
public static void Main()
{
 DualFunction fun1 = new DualFunction(Add); 
 Add(1, 2);
 fun1(1, 2);
}
```

## 委托封装方法

```C#
DualFunction fun1 = new DualFunction(Add);
```

![image-20220407090941415](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407090949.png)

程序中，通过委托调用当前类的静态方法，因此在创建表达式中只需写出方法名；如果是调用外部类型的静态方法，那么应写出方法所属的类；如果调用的是非静态方法，那么还应指出方法所属的对象名。

```c#
//将加减乘除方法放到类Method中,示例程序P6_1_1
DualFunction fun1 = new DualFunction(Method.Add);
fun1(2,3);
fun1 = new DualFunction(Method.Sub);
```

### 说明

1. C#允许将方法名直接写在委托赋值表达式的等号右边，而不必写出完整的委托。

	```c#
	DualFunction fun1 = new DualFunction(Add);
	fun1(2,3);
	fun1 = Sub;
	```

2. 可以将一组委托对象放在一个数组中

   ```c#
    static void Main()
   {
    DualFunction[] fun1=new DualFunction []{Add,Sub,Mul,Div};
    Console.Write("请输入a的值：");
    double a = double.Parse(Console.ReadLine());
    Console.Write("请输入b的值：");
    double b = double.Parse(Console.ReadLine());
    Console.Write("请选择函数（加0，减1，乘2，除3）:");
    int i = int.Parse(Console.ReadLine());
    fun1[i](a, b);
   ```

### 委托加减（合并删除）

```c#
DualFunction fun1 = new DualFunction(Add);
fun1(2,3);
//以下用一个委托对象封装多个方法
fun1 = new DualFunction(Sub);
fun1 += new DualFunction(Mul);
```

**PS:减掉没有封装的方法:没有任何影响**

**![image-20220407093418570](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407093418.png)**

#### 说明：

- 加法操作符实现了委托对象的合并，即封装多个方法；
- 减法操作符能够将方法从已合并的委托对象中删除；
- 可以使用复合赋值运算符；
- 参与加减运算的委托对象必须属于同一个委托类型；
- 通过空的委托对象null调用方法会引发程序异常；
- 安全的做法是先判断该委托对象是否为空；
- 加减null值对委托对象不会产生任何效果。

### 传递委托对象

#### 作为方法返回值

```c#
using System;

namespace P6_1_2
{
    //将委托对象作为其它方法的返回值
    delegate void DualFunction(double x, double y);
    class P6_1_2
    {
        static void Main()
        {
            DualFunction fun1;
            Console.Write("请输入a的值：");
            double a = double.Parse(Console.ReadLine());
            Console.Write("请输入b的值：");
            double b = double.Parse(Console.ReadLine());
            Console.Write("请选择函数（加0，减1，乘2，除3）:");
            int i = int.Parse(Console.ReadLine());
            fun1=GetDualFunction (i);
            fun1(a, b);
            Console.ReadLine();
        }

        static DualFunction GetDualFunction(int i)
        {
            if (i == 1)
                return new DualFunction(Sub);
            else if (i == 2)
                return new DualFunction(Mul);
            else if (i == 3)
                return new DualFunction(Div);
            else
                return new DualFunction(Add);
        }

        static void Add(double x, double y)
        {
            Console.WriteLine("{0}+{1}={2}", x, y, x + y);
        }
        static void Sub(double x, double y)
        {
            Console.WriteLine("{0}-{1}={2}", x, y, x - y);
        }
        static void Mul(double x, double y)
        {
            Console.WriteLine("{0}*{1}={2}", x, y, x * y);
        }
        static void Div(double x, double y)
        {
            Console.WriteLine("{0}/{1}={2}", x, y, x / y);
        }

    }
}
```

#### 作为方法参数

```c#
using System;

namespace P6_2
{
    public delegate int CompareFunction(Student s1, Student s2);//嵌套
    class Program
    {
        static void Main()
        {
            Student[] students = new Student[5];
            students[0] = new Student("王小红", 20, 1);
            students[1] = new Student("周军", 23, 2);
            students[2] = new Student("方小白", 21, 2);
            students[3] = new Student("高强", 25, 3);
            students[4] = new Student("王浩", 22, 3);
            CompareFunction compare;
            Console.WriteLine("请选择排序方式: A姓名 B年龄 C年级");
            char ch = Console.ReadKey().KeyChar;
            if (ch == 'B' || ch == 'b')
                compare = CompareAge;

            else if (ch == 'C' || ch == 'c')
                compare = CompareGrade;
            else
                compare = CompareName;
            Student.SortAndPrint(students, compare);//将委托对象作为参数传递 1.数组名2.委托对象
            Console.ReadLine();
        }

        static int CompareName(Student s1, Student s2)
        {
            return s1.Name.CompareTo(s2.Name);
        }

        static int CompareAge(Student s1, Student s2)
        {
            return s1.Age - s2.Age;
        }

        static int CompareGrade(Student s1, Student s2)
        {
            return s1.Grade - s2.Grade;
        }
    }

    public class Student
    {
        private string name;
        public string Name
        {
            get { return name; }
        }

        private int age;
        public int Age
        {
            get { return age; }
        }

        private int grade;
        public int Grade
        {
            get { return grade; }
            set { grade = value; }
        }

        public Student(string name, int age, int grade)
        {
            this.name = name;
            this.age = age;
            this.grade = grade;
        }

        public static void SortAndPrint(Student[] students, CompareFunction compare)//委托对象作为参数
        {
            for (int i = students.Length - 1; i > 0; i--)
                for (int j = 0; j < i; j++)
                    if (compare(students[j], students[j + 1]) > 0)
                    {
                        Student s = students[j];
                        students[j] = students[j + 1];
                        students[j + 1] = s;
                    }
            foreach (Student s in students)
                Console.WriteLine(s);
        }

        public override string ToString()
        {
            return string.Format("{0} {1}岁 {2}年级", name, age, grade);
        }

        
    }
}
```

**作业**

```c#
static int comparemul(student s1,student s2)
{
    if(comparegrade(s1,s2)!=0) return s1.grade-s2.grade;
    else if (comparename(s1,s2)!=0  )return s1.name-s2.name;
    else if (compareage(s1,s2)!=0)return s1.age-s2.age;
}
```

## 匿名方法

### 定义和调用匿名方法

相对于命名方法来说

本质上是系统给一个用户不知道的名字

如果一个方法只是通过委托进行调用，那么在C#中允许不写出该方法的定义，而是将方法的执行代码直接写在委托对象的创建表达式中，此时被封装的方法叫匿名方法（对应地，使用常规方式定义的方法成员叫作命名方法 ）。

```c#
//命名方法
public static void Add(int x, int y) 
{
  Console.WriteLine("{0}+{1}={2}", x, y, x+y);
}
......
DualFunction fun1 = new DualFunction(Add); 

//匿名方法
DualFunction fun1 = delegate(int x, int y) 
{
  Console.WriteLine("{0}+{1}={2}", x, y, x+y);
};//不写出方法定义，将方法的执行代码直接写在委托对象的创建表达式中
```

### Lambda表达式替换匿名方法表达式

形式更加简便

左侧输入   右侧计算体

```c#
Student.CompareFunction  compare = 
  (Student s1, Student s2)=> { return s1.Age- s2.Age;};  
//以下形式也是正确的
(Student s1, Student s2)=> { return s1.Age- s2.Age;};
(Student s1, Student s2)=>  s1.Age- s2.Age; 
(s1,  s2)=> { return s1.Age- s2.Age;};
(s1,  s2)=> s1.Age- s2.Age;
```

### 外部变量

由于匿名方法总是定义在另一个方法的执行代码中，因此匿名方法的参数名就可能和外部代码发生冲突。C#规定：匿名方法的参数名不能和已有的外部变量名相同；如果匿名方法执行体中的局部变量名和外部变量名相同，那么它们代表同一变量，此时称外部变量被匿名方法所"捕获”。

```c#
double x=2.5, y=2;
DualFunction fun1 = delegate(double x, double y) //错误
 {  Console.WriteLine("{0}+{1}={2}”,x,y,x+y);};
fun1(x,y);
```

```c#
double a=2.5, b=2;
DualFunction fun1 = delegate(double x, double y) 
 {  Console.WriteLine("{0}+{1}={2}”,x,y,x+y);//参数传递
     Console.WriteLine("{0}+{1}={2}”,a,b,a+b);//捕获外部变量
 };
fun1(a,b);
```

```c#
namespace P6_3
{   public delegate int OneDelegate(int x);
    class Program
    {
        static void Main()
        {
           int x = 0;
           OneDelegate dg1 = new OneDelegate(Increment); //封装命名方法
           Console.WriteLine(dg1(x));//1   
            Console.WriteLine(x);//0
           Console.WriteLine(dg1(x));//1   
            Console.WriteLine(x);//0
           dg1 = delegate { return ++x; }; //封装匿名方法
           Console.WriteLine(dg1(x));//1   
            Console.WriteLine(x);//1
           Console.WriteLine(dg1(x));//2   
            Console.WriteLine(x);//2
           Console.ReadLine();
        }
        public static int Increment(int x)
        {  return ++x;    }
    }
}
```

## 事件处理

### 委托发布和订阅

![image-20220412094917148](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220412094917.png)

#### 发布者

```c#
delegate void LightEvent(bool color);//委托类型定义
public class TrafficLight
{
  private bool color=false;
  public LightEvent OnColorChange; //委托成员声明
  public void ChangeColor() {//委托激发方法
    color = !color;
    if(OnColorChange != null)
      OnColorChange(color);//调用委托处理方法
  }
} 
```

#### 订阅者

```c#
public class Car
{
  private bool bRun=true;
  public void Enter(TrafficLight light)   {
 light.OnColorChange += LightColorChange;//委托绑定
} 
  public void LightColorChange(bool color) {//委托处理方法
    if(bRun && color) {
      bRun = false;
      Console.WriteLine("停车");  }
  }
} 
```

```c#
using System;
namespace P6_4_1
{
    class Program
    {
        static void Main()
        {
            TrafficLight light = new TrafficLight();
            Car car1 = new Car();
            light.ChangeColor();
            light.ChangeColor();
            Console.ReadLine();
        }
    }
    public class TrafficLight
    {
        private bool color = false;
        public bool Color
        {
            get { return color; }
        }
            //委托对象为TrafficLight类型的公有成员；委托发布
        public void ChangeColor( )
        {
            color = !color;
            Console.WriteLine(color ? "红灯亮" : "绿灯亮");
        }
    }
    public class Car
    {
        private bool bRun = true;
        public virtual void LightColorChange(bool color)
        {
            if (bRun && color)
            {
                bRun = false;
                Console.WriteLine("{0}停车", this);
            }
            else if (!bRun && !color)
            {
                bRun = true;
                Console.WriteLine("{0}启动", this);
            }
        }
    }
    public class Ambulance : Car
       {
           private bool emergent = false;
           public bool Emergent
           {
               get { return emergent; }
               set { emergent = value; }
           }
           public override void LightColorChange(bool color)
           {
               if (emergent)
                   Console.WriteLine("{0}紧急行驶", this);
               else
                   base.LightColorChange(color);
           }
       }
    public class Truck
       {
           private bool bRun = true;
           public void Enter(TrafficLight light)
           {
               light.OnColorChange += LightColorChange;//委托订阅
           }
           public void Leave(TrafficLight light)
           {
               light.OnColorChange -= LightColorChange;//取消委托订阅
           }
           public virtual void LightColorChange(bool color)
           {
               if (bRun && color)
               {
                   bRun = false;
                   Console.WriteLine("{0}停车", this);
               }
               else if (!bRun && !color)
               {
                   bRun = true;
                   Console.WriteLine("{0}启动", this);
               }
           }
       }
    }
```

### event

```c#
delegate void LightEvent(bool color);

public class TrafficLight
{
  private bool color;
  public event LightEvent OnColorChange; 

  public void ChangeColor() {
    color = !color;
    if(OnColorChange != null)
      OnColorChange(color); }
} 
```

### 使用EventHandler委托类型

在事件发布和订阅的过程中，定义事件的原型委托常常是一件重复性的工作。为此，.NET类库中定义了一个EventHandler委托类型，并建议尽量使用该类型作为事件的原型。该委托类型的定义为：

**参数sender：表示引发事件的对象。由于事件成员只能由类型本身触发，因此其值通常为 this.**

**参数e：表示事件中包含的数据。如果发布者还要向订阅者传递额外的事件数据，就需要定义EventArgs类型的派生类。**

```c#
public  delegate void EventHandler(object  sender, EventArgs e)
```

##### 发布者

```c#
public class TrafficLight
{
  private bool color;
  public EventHandler OnColorChange; 

  public void ChangeColor() {
    color = !color;
    if(OnColorChange != null)
      OnColorChange(this, null);
  }
} 
```

##### 订阅者

```c#
public class Car
{
  private bool bRun;

  public void Enter(TrafficLight light) {
    light.OnColorChange += LightColorChange; }
  
  public void LightColorChange(object sender, EventArgs e) 
  { TrafficLight light = (TrafficLight)sender;
    if(bRun && light.Color) {
      bRun = false;
      Console.WriteLine("停车");  }  }
} 
```

### 控件事件

事件在Windows这样的图形界面程序中有着极其广泛的应用。用户的很多操作，如单击鼠标、输入文本框内容、选择菜单命令等，都可以触发相关的控件事件；此时如果在程序中定义了相应的事件处理方法，则能够执行其中的代码。

#### 按钮控件Button

Click成员：是一个EventHandler类型的事件。其定义为

```c#
 public  event  EventHandler  Click;
```

OnClick成员方法：其定义为

```c#
protected  virtual  void  OnClick(EventArgs  e)
{     if (Click!=null) 
    Click ( this, e);
}
```

用户单击按钮时，Button对象将自动调用其OnClick方法，并通过它触发Click事件。如果此时Click事件关联了处理方法（事件订阅），则自动执行关联方法中的代码。

#### 响应Windows控件事件

# 第8章  对象持久性—文件管理

## 8.1 文件和流

### File类（静态类）==导入using System.IO==

- 复制文件
- 替换文件
- 移动文件
- 删除文件
- 创建文件
- 判断文件是否存在

```c#
File.Copy("C:\\a.txt", "d:\\b.txt"); 
File.Replace("C:\\a.txt", "D:\\b.txt","d:\\c.txt"); //b先备份为c,再用a替换b
File.Move("C:\\a.txt", "D:\\b.txt");  
File.Delete("C:\\b.txt");
File.Create ("C:\\a.txt");
File.Exists("c:\\a.txt") ;
```

- 时间属性

  - GetCreationTime（创建时间）
  - GetLastAccessTime(最后一次访问时间）

  - GetLastWriteTime（最后一次修改时间）

  - Set......

- 文档属性 FileAttributes(枚举型)  GetAttributes()方法 SetAttributes()方法

  - Normal普通文件
  - Achive存档文件
  - Readonly制度文件
  - Hidden... 隐藏文件

  ```c#
  //判断文档属性
  string s = "d:\\w3.txt";
  FileAttributes fa1 = File.GetAttributes(s);
  if ((fa1& FileAttributes.ReadOnly)  == FileAttributes.ReadOnly)
      Console.WriteLine("只读文件");
  if ((fa1 & FileAttributes.Hidden )== FileAttributes.Hidden)
      Console.WriteLine("隐藏文件");
  ```

- 读写文本

  - ReadAllText, WriteAllText, 
  - ReadAllLines, WriteAllLines 

  - ReadAllBytes, WriteAllBytes
  - **File类的ReadAllText 和WriteAllText等方法，都只能一次性处理全部文件内容。要想读写文件的指定部分，就要用到文件流对象FileStream。**

### FileStream

- 创建

  - ```c#
    FileStream fsl = File.Creat("C:\\a.txt");
    ```

- 写入

  - ```c#
    FileStream fsl = File.Creat("C:\\a.txt");
    for (byte  x=1;x<=10;x++)
       fsl.WriteByte(x);
    for (byte  x=65;x<=74;x++)
       fsl.WriteByte(x);
    //将整数作为ASCII值，写入其对应字符
    string s1 = "2011-3-30 8:30am";
    for (int i = 0; i < s1.Length; i++)
       fs1.WriteByte((byte)(s1[i]));
    //写入字符串的每一个字符，只适合ASCII字符
    ```

- 关闭

  - ```c#
    FileStream fsl = File.Creat("C:\\a.txt");
    for (byte  x=1;x<=10;x++)
       fsl.WriteByte(x);
    string s1 = "2011-3-30 8:30am";
    for (int i = 0; i < s1.Length; i++)
       fs1.WriteByte((byte)(s1[i]));
    fsl.close();
    ```

- 打开文件
  创建并打开文件
  追加文件

  - ```c#
    FileStream fs1 = File.Open("C:\\a.txt", FileMode.Open); //第二个参数为FileMode枚举类型；文件不存在发生异常
    fs1 = File.Open("C:\\a.txt", FileMode.OpenOrCreate);
    fs1 = File.Open("C:\\a.txt", FileMode.CreateNew);//文件已存在发生异常
    fs1 = File.Open("C:\\a.txt", FileMode.Create);
    fs1 = File.Open("C:\\a.txt", FileMode.Append);
    ```

- 读写方式: 通过File.Open的第三个参数设置，其类型为FileAccess枚举，取值可为Read, Write, ReadWrite
  - ```c#
    fs1 = File.Open("C:\\a.txt", FileMode.Open,FileAccess.Write); 
    ```

- Read/Write方法：将读/写的内容放在一个byte[ ]数组型的参数中，并通过第二、第三个参数来分别指定数组中读/写的开始位置以及要读/写的字节数。

  - ```c#
    fs1 = File.Open("C:\\a.txt", FileMode.Open， FileAccess.Write); 
    Byte[] bs1= {65,66,67,68,69,70,71};
    if (fs1.CanWrite)
       fs1.Write(bs1,3,4);//写入 DEFG
    fs1.Close();
    ```

- 读写位置

  - ```c#
    fs1 = File.Open("C:\\a.txt", FileMode.Open);
    ```

  - 无论是读是写，FileStream对象都是从流的“当前”位置开始操作。 FileStream对象的Position属性用于指示流的当前位置。

  - **看不清，去PPT看**

  - ![image-20220420121127952](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220420121128.png)

    


## 8.2 流的读写器

直接使用文件流对象在文件中读写字节的效率较高，但要处理其他各种类型数据，使用与文件流相配套的读写器类型会更方便。

System.IO命名空间中提供的与文件流相配套的读写器类型主要是：

- BinaryWriter（以二进制方式对流进行写操作）
- BinaryReader（以二进制方式对流进行读操作）
- StreamWriter（以文本方式对流进行写操作）
- StreamReader（以文本方式对流进行读操作）

### 流的读写器（二进制读写器）

#### BinaryWriter（以二进制方式对流进行写操作）

##### 创建

```c#
FileStream fsl = File.Creat("C:\\a.txt");
BinaryWriter bw1 = new BinaryWriter(fs1);
```

#####  写入

BinaryWriter的Write方法用于向流中写入数据，由于该方法有多种重载形式，可**接受多种类型的参数。**

```c#
FileStream fsl = File.Creat("C:\\a.txt");
BinaryWriter bw1 = new BinaryWriter(fs1);
bw1.Write(1000);
bw1.Write(3.14);
bw1.Write('z');
bw1.Write("ABC");
```

##### 关闭

```c#
FileStream fsl = File.Creat("C:\\a.txt");
BinaryWriter bw1 = new BinaryWriter(fs1);
bw1.Write(1000);
bw1.Write(3.14);
bw1.Write('z');
bw1.Write("ABC");
bw1.Close();//先关写器
fs1.Close();//再关文件流
```

#### BinaryReader （以二进制方式对流进行读操作）

需要明白类型

##### 创建

```c#
FileStream fsl = File.Open("C:\\a.txt");
BinaryReader br1 = new BinaryReader(fs1);
```

##### 读取

```c#
FileStream fsl = File.Open("C:\\a.txt");
BinaryReader br1 = new BinaryReader(fs1);
int x = br1.ReadInt32();
double y = br1.ReadDouble();
char a = br1.ReadChar();
string s=new string(br1.ReadChars(6));//读取指定长度
string s = br1.ReadString();
```

##### 关闭

```c#
FileStream fsl = File.Open("C:\\a.txt");
BinaryReader br1 = new BinaryReader(fs1);
int x = br1.ReadInt32();
double y = br1.ReadDouble();
char a = br1.ReadChar();
string s=new string(br1.ReadChars(6));
string s = br1.ReadString();
br1.Close();
fs1.Close();
```

#### StreamWriter（以文本方式对流进行写操作）

##### 创建、写入、关闭

和二进制区别：**支持参数格式化**

```c#
FileStream fsl = File.Creat("C:\\a.txt");
StreamWriter sw1 = new StreamWriter(fs1);

sw1.Write(1000);
sw1.Write(3.14);
sw1.Write('z');
sw1.Write("{0}年{1}月",2008,8);
//写入字符串时，支持参数的格式化
sw1.Close();
fs1.Close();
```

###### Encoding类

位于System.Text命名空间下，表示字符编码，其静态属性有ASCII、UTF7、**UTF8默认**、Unicode等，不指定默认为UTF8。

```c#
FileStream fsl = File.Creat("C:\\a.txt");
StreamWriter sw1 = new StreamWriter(fs1,Encoding.ASCII);
//构造函数的第二个参数来指定写入文本的编码格式
sw1.Write(“tangshan唐山”);//唐山 显示为 ？？ 因为ASCII不支持汉字
sw1.Close();
fs1.Close();
```

#### StreamReader（以文本方式对流进行读操作）

##### 创建、读取、关闭

```c#
FileStream fsl = File.Open("C:\\a.txt");
StreamReader sr1 = new StreamReader(fs1);

char x = sr1.Read(); //读取单个字符
char[] chs = new char[3];
sr1.Read(chs, 0, 3); //也可读取一组字符
string s = sr1.ReadLine();  //读取一行字符串
String s1=sr1.ReadToEnd();//读到文件流的末尾

sr1.Close();
fs1.Close();
```

> #### 流的读写
>
> ```c#
> using System;
> using System.IO;
> 
> namespace P8_4
> {
>     class P8_4
>     {
>         static void Main()
>         {
>             FileStream fs1 = new FileStream("d:\\Test.txt", FileMode.Create, FileAccess.ReadWrite);
>             BinaryWriter bw1 = new BinaryWriter(fs1);
>             for (byte i = 65; i < 72; i++)
>                 bw1.Write(i);  //写入ABCDEFG
>             bw1.Write('\n');
>             for (byte i = 72; i < 79; i++)
>                 bw1.Write(i); //写入HIJKLMN
>             bw1.Flush();  //Flush方法将系统缓冲区存放的数据，强制写入文件   强制写/提前写
>             fs1.Position = 0;
>             char[] chs = new char[3];
>             StreamReader sr1 = new StreamReader(fs1);
>             sr1.Read(chs, 0, 3);
>             Console.WriteLine(new string(chs)); //输出"ABC"
>             Console.WriteLine(sr1.ReadLine()); //输出"DEFG"
>             Console.WriteLine(sr1.ReadToEnd()); //输出" HIJKLMN"
>             bw1.Close();
>             sr1.Close();
>             fs1.Close();
>             Console.ReadLine();
>         }
>     }
> }
> ```

### 文件对话框

![image-20220421112238808](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220421112239.png)

#### 保存

```c#
OpenFileDialog dlg1 = new OpenFileDialog();
dlg1.Filter = "文本文件(*.txt)|*.txt";
if (dlg1.ShowDialog() == DialogResult.OK)
  FileStream fs1 = File.Open(dlg1.FileName);
```

#### 打开

```c#
SaveFileDialog dlg1 = new SaveFileDialog();
dlg1.Filter = "网页文件(*.htm;*.html)|*.hml;*.html";
if (dlg1.ShowDialog() == DialogResult.OK)
  FileStream fs1 = File.Create(dlg1.FileName);
```

### 对象持久性

**把对象字段的值存入文件**

在面向对象的程序中，如果把对象信息（主要是成员字段值）保存到文件等永久性介质中，那么就可以在再次运行程序时载入对象信息，这称为对象的持久性。

对象的持久性，既可以手动编写代码实现，也可以用.NET中的自动持久性支持来实现。

#### .NET自动持久性

串行化（或序列化）技术：使用.NET定义的格式化工具Formatter，通过它自动获取对象所有字段的名称和值，并将其写入到文件流中；或是从文件流中解析出各字段的名称和值，并以此为依据来创建对象。

##### 自动保存字段信息

在类的定义前使用**Serializable**标记，表示其对象可串行。

```c#
[Serializable()]
public class Student
{
  private string department;
  public string  Department
  {
    get {return name;}
    set {name = value;}   
  }
  ......
}
```

##### 无需保存的字段

如果**不希望某个字段自动存取**，在字段前使用标记**NonSerializable**

```c#
[Serializable()]
public class Student
{
  private string department;
  public string  Department
  {
    get {return name;}
    set {name = value;}   
  }
  ......
  [NonSerializable()]
  private string department;
}
```

##### 串行化

对于可串行的对象，可使用.NET提供的格式化工具进行文件存取。其中`System.Runtime.Serialization.Formatters.Binary`命名空间中的`BinaryFormatter`类就是一个二进制格式化工具。其`Serialize`方法用于将对象的字段值写入文件流。

```c#
Student s1 = new Student(800001,"王小红");
FileStream fs1 = new Filestream("a.txt",FileMode.Create);
BinaryFormatter bf1 = new BinaryFormatter();
bf1.Serialize(fs1, s1);
fs1.Close();
```

##### 反串行化

`BinaryFormatter`类的`Deserialize`方法用于从文件中读取字段值并创建对象。

```c#
FileStream fs1 = new FileStream("a1.txt",FileMode.Open);
BinaryFormatter bf1 = new BinaryFormatter();
Student s1 = bf1.Deserialize(fs1);
fs1.Close();
```

对于可串行的对象，还可使用.NET提供的格式化工具`SoapFormatter`类,其使用的是**XML**格式，在

`System.Runtime.Serialization.Formatters.Soap`

命名空间中定义。使用方法和`BinaryFormatter`基本类似。

```c#
FileStream fs1 = new FileStream("a1.txt",
    FileMode.Open);
SoapFormatter bf1 = new SoapFormatter();
Student s1 = bf1.Deserialize(fs1);
fs1.Close();
```

> 学生类Student.cs
>
> ```c#
> using System;
> using System.IO;
> using System.Linq;
> using System.Text;
> 
> namespace P8_5_2
> {
>   
>     public class Student
>     {
>         private int id;
>         public int ID //学号
>         {
>             get { return id; }
>             set { id = value; }
>         }
> 
>         private string name;
>         public string Name //姓名
>         {
>             get { return name; }
>             set { name = value; }
>         }
> 
>         private bool gender;
>         public bool Gender //性别
>         {
>             get { return gender; }
>             set { gender = value; }
>         }
> 
>         private string department;
>         public string Department //院系
>         {
>             get { return department; }
>             set { department = value; }
>         }
> 
>         private byte grade;
>         public byte Grade //年级
>         {
>             get { return grade; }
>             set { grade = value; }
>         }
> 
>         public Student()
>         { ;}
> 
>         public Student(int id, string name)
>         {
>             this.id = id;
>             this.name = name;
>         }
> 
>         public Student(int id, string name, char gender, string department, byte grade)
>         {
>             this.id = id;
>             this.name = name;
>             this.gender = gender == '男' ? true : false;
>             this.department = department;
>             this.grade = grade;
> 
>         }
> 
>         public void SaveB(BinaryWriter w1)
>         {
>             w1.Write(id);
>             w1.Write(name);
>             w1.Write(gender);
>             w1.Write(department);
>             w1.Write(grade);
>         }
> 
>         public void SaveS(StreamWriter w1)
>         {
>             w1.WriteLine(id);
>             w1.WriteLine(name);
>             w1.WriteLine(gender);
>             w1.WriteLine(department);
>             w1.WriteLine(grade);
>         }
> 
>         public static Student LoadB(BinaryReader r1)
>         {
>             int id = r1.ReadInt32();
>             string name = r1.ReadString();
>             Student s1 = new Student(id, name);
>             s1.gender = r1.ReadBoolean();
>             s1.department = r1.ReadString();
>             s1.grade = r1.ReadByte();
>             return s1;
>         }
> 
>         public static Student LoadS(StreamReader r1)
>         {
>             int id = int.Parse(r1.ReadLine());
>             string name = r1.ReadLine();
>             Student s1 = new Student(id, name);
>             s1.gender = bool.Parse(r1.ReadLine());
>             s1.department = r1.ReadLine();
>             s1.grade = byte.Parse(r1.ReadLine());
>             return s1;
>         }
> 
>         public override string ToString()
>         {
>             return string.Format("{0}  {1}  {2}  {3}系{4}级", id, name, gender ? '男' : '女', department, grade);
>         }
> 
>     }
> }
> ```
>
> 主程序
>
> ```c#
> using System;
> using System.IO;
> using System.Text;
> 
> namespace P8_5_2
> {
>     class Program
>     {
>         static void Main(string[] args)
>         {
>             {
>                 Student[] students = new Student[2];
>                 students[0] = new Student(1001, "张三", '男', "计算机", 1);
>                 students[1] = new Student(1002, "李梅", '女', "数学", 2);
>                 Console.WriteLine("请选择 R 读文件   W 写文件");
>                 char ch = Console.ReadKey().KeyChar;
>                 if (ch == 'R')
>                 {
>                     FileStream fs1 = new FileStream("c:\\students2.bin", FileMode.Open);
>                     BinaryReader br1 = new BinaryReader(fs1);
>                     //StreamReader br1 = new StreamReader(fs1);
>                    
>                     Console.WriteLine();
>                     for (int i = 0; i < students.Length; i++)
>                     {
>                         students[i] = Student.LoadB(br1);
>                         //students[i] = Student.LoadS(br1);
>                         
>                         
>                         Console.WriteLine(students[i]);
>                     }
>                     Console.ReadLine();
>                     br1.Close();
>                     fs1.Close();
>                 }
>                 else if (ch == 'W')
>                 {
>                     FileStream fs1 = new FileStream("c:\\students2.bin", FileMode.OpenOrCreate);
>                     BinaryWriter bw1 = new BinaryWriter(fs1);
>                     //StreamWriter bw1 = new StreamWriter(fs1);
>                    
>                     foreach (Student s in students)
>                         s.SaveB(bw1);
>                         //s.SaveS(bw1);
>                         
>                     Console.WriteLine("写文件成功！");
>                     bw1.Close();
>                     fs1.Close();
>                 }
>             }
>         }
>     }
> }
> ```
>
> 

# 9 异常处理

## 异常的基本概念

![image-20220426085539636](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426085539.png)

## 异常处理结构

### try-catch

当程序在try代码段的某条语句上发生错误后，程序控制权就转入catch代码段，而try代码段中剩余的代码会被忽略。

#### 捕获异常

```c#
try 
{
  int x = int.Parse(Console.ReadLine());
  int y = 100 / x;
}
catch 
{
  Console.WriteLine("输入错误");
}
```

#### 获取异常信息

```C#
try 
{
  int x = int.Parse(Console.ReadLine());
  int y = 100 / x;
}
catch (Exception exp) 
{
  Console.WriteLine("输入错误:" + exp.Message);//"尝试除以零"
}
```

- .NET异常处理技术的**基本思路**是：当出现异常时，创建一个异常对象，然后根据程序流程，将异常对象传递给一段特定的代码。用.NET术语来讲，则是由一段代码抛出异常对象，由另一个代码段捕获并处理。
- 异常处理的一般过程为：引发异常后，先根据定义判断是哪种类型的异常，然后执行这种类型的异常处理程序段。
-  实际上，异常是一个类实例，即C#语言中的异常都是异常类的对象。.NET框架类库中预定义了大量的异常类，每个异常类代表了一种异常错误。
  所有的异常都派生自System.Exception类。

#### 捕获多种异常

应先捕获更“**具体**”的对象，再捕获更“**一般**”的对象。

```c#
try {
  int x = int.Parse(Console.ReadLine());
  int y = 100 / x;
}
catch (FormatException) {
  Console.WriteLine("输入格式错误");
}
catch (DivideByZeroException) {
  Console.WriteLine("不能除以0");
}
catch (Exception exp) {
  Console.WriteLine("程序错误:" + exp.Message);
}
```

catch关键字后指定的异常对象类似于方法的参数，它是catch代码段中的局部变量，在该代码段外无效；

如果catch代码段中没有使用到异常对象，那么在catch关键字后的括号里可以只写出异常的类型，而不必写出异常对象的名称；

如果只写出catch关键字，那么默认捕获的异常类型是Exception(**捕获所有异常**)。

### try-catch-finally

```c#
int n = 0;
while(true) 
{
  try 
  {
    int x = int.Parse(Console.ReadLine());
    if(x ^ 13 == 9999) 
    {
      Console.WriteLine("输入正确"); break;   
    }
  }
  catch 
  {
    Console.WriteLine("输入错误");
  }
  finally 
  {
    n++;  
  }
  if(n==10) 
  {
    Console.WriteLine("输入次数超过10次"); break;  
  }
}
```

- 此结构对异常的捕获和处理方式与try-catch结构相同，但不论程序在执行过程中是否发生异常，finally代码段总是会被执行；
- finally语句具有强制执行的特性，即使在前面的try代码段或catch代码段中遇到break、continue、goto等转移语句，finally代码段也不会被跳过；
- finally代码段中不允许使用return语句；
- 如果在finally代码段中使用了break、continue、goto等语句，那么该转移语句的目的地也必须在此代码段中。

#### try-finally

```c#
int n = 0;
while(true) {
  try {
    int x = int.Parse(Console.ReadLine());
    if(x ^ 13 == 9999) {
      Console.WriteLine("输入正确"); break;  }
  }
  finally {
    n++;
  }
  if(n==10) {
    Console.WriteLine("输入次数超过10次"); break;
  }
}
```

- 此结构只“捕获”而不“处理”异常；
- finally代码段总是会被执行。
- 如果没有catch块，那么finally块必须要有。

## 异常的捕获和传播

### 异常传播:

程序引发异常后，程序的控制权将在异常处理结构中转移，直至找到一个能够处理该异常的catch语句，否则程序终止运行，这个过程叫作异常传播。

![image-20220426095014275](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426095014.png)

### Exception类的常用属性

Exception类的属性成员描述了该类对应异常的详细信息，通过它们可以获取异常对象的基本信息。常用属性成员有：

- **Message**：string类型，获取描述当前异常的消息。
- **Source**：string类型，获取导致错误的应用程序或对象的名称。
- **TargetSite**：System.Reflection.MethodBase类型，获取引发当前异常的方法。
- **StackTrace**：对异常传播的方法调用堆栈的描述。
- **InnerException**：Exception类型，获取导致当前异常的Exception 实例。

### Exception类的常用方法

GetType( )：获取最具体的异常类型。

### Exception类的构造函数

C#语言中，异常类中都定义有多个构造函数。Exception类中常用的构造函数有：
public Exception( )  //默认构造函数 
public Exception (string message)

### 继承层次

![image-20220426100909075](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426100909.png)

![image-20220426100541715](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426100542.png)

## 自定义异常

### 主动引发异常

throw语句用于引发一个异常，异常对象应跟在throw关键字之后。程序执行到这里就会引发并传播异常，之后的语句不再执行；如果异常没有被捕获，整个程序就会终止。这就能防止非法的Student对象被创建。

<img src="https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426101604.png" alt="image-20220426101538975"  />

### 自定义异常类

- C#语言中，编程人员除了使用框架类库中定义的异常类外，还可能需要定义自己的异常类，以便指出自己编写的程序中可能存在的特定异常。==自定义==异常类时，应该使之==派生于ApplicationException类==。
- 按照约定，自定义异常类名应以Exception结尾。

```c#
class CountIsZeroException : ApplicationException //派生于ApplicationException
    {
        public CountIsZeroException(string message):       base(message)
        { }
    }


class Calculator
    {
        int sum = 0;
        int count = 0;
        float average;
        
        public void DoAverage()
        {
            if (count == 0)
                throw (new CountIsZeroException("Zero count in DoAverage"));
            else average = sum / count;
        }
    }
```

### 习题

- Convert.ToInt32会引发 **FormatException**(格式异常)
- 所有异常类的基类  **System.Exception**

判断正误，如果错误，请说明原因。

(1) 当前方法产生的异常总是由当前的方法来处理。
(2)用户自定义的异常应该从SystemException类继承
(3)当访问数组的索引越界时，会有异常引发。
(4)如果在try块后没有任何catch块，那么finally块也是可选的。 

3 .编程改错题
执行以下语句，验证输出语句有无执行，并解释理由。

```c#
using System;
public class ThrowTest 
{
    static void Main() 
    {  string s = null;
        if (s == null)   
            throw new ArgumentNullException();//只抛出,没捕获,等待处理     
       Console.Write("The string s is null");//得不到处理
    }
}
```

# 第10章  基于接口的程序设计

```c#
public class Automobile
    {  public void Speak() //基类方法
        {   Console.WriteLine("汽车鸣笛...");   }
    }
 public class Bus : Automobile
    {  public new void Speak() //隐藏基类方法
        {   Console.WriteLine("公共汽车嘀...嘀...."); }
    }

Automobile a1 = new Automobile(); a1.Speak(); 
Bus b1 = new Bus();b1.Speak();
Bus b2 = new Bus(); Automobile a2 = b2; 
a2.Speak(); b2.Speak();  
//汽车 公交车
```

```c#
public class Automobile
    {  public virtual void Speak() //基类方法
        {   Console.WriteLine("汽车鸣笛...");   }
    }
 public class Bus : Automobile
    {  public override void Speak() //隐藏基类方法
        {   Console.WriteLine("公共汽车嘀...嘀...."); }
    }

Automobile a1 = new Automobile(); a1.Speak(); 
Bus b1 = new Bus();b1.Speak();
Bus b2 = new Bus(); Automobile a2 = b2; 
a2.Speak(); b2.Speak();  
//公交车 公交车
```

#### 问题1

派生类可以隐藏基类的方法，也可以重载基类的方法。但上述2种方法不能同时存在，那么，如何汲取两者的优点？

**解决方法：利用接口来实现多态性，就可以达到“鱼和熊掌兼得”的效果。**    

#### 问题2：多继承

类的单继承

<u>缺点</u>：单继承在表达能力上有一定的限制。例如，并不是所有的银行卡都能在POS机上消费，那么消费功能的描述就需要在BankAccount的派生类中重复多次。

![image-20220428091815498](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220428091815.png)

解决方法：类的多继承将消费功能抽象在一个Payer类中。

![image-20220428091918188](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220428091918.png)

缺点：

- 带来二义性问题；
- 基类过多，严重影响程序性能

**正确的解决方法：利用接口实现多继承**

![image-20220428092612729](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220428092612.png)

接口是比抽象类更为“抽象”的一种数据类型，它所描述的是功能契约，即“能够提供什么服务”，而不考虑与实现有关的任何因素。

**等价于一个抽象类只有一个抽象方法**

## 接口的定义和使用

- 关键字为interface，成员不能有字段和构造函数；
- 接口和抽象类都不能创建实例，其接口方法和抽象方法也一样没有执行代码；
- 接口方法不能是静态的，也不能使用任何访问限制修饰符（默认public）；
- 可以把接口看成是只包含抽象方法的抽象类，其中每个接口方法都表示一项“服务契约”。

### 继承

```c#
public interface IDrawable
{
  bool Draw(decimal money);
}

public interface IDepositDraw : IDrawable 
{
  void Deposit(decimal money);
}
```

- 接口之间可以继承，且存在传递性；
- 一个类可以从接口继承，但一个接口不能从类派生；

```c#
public interface IDrawable
{
  bool Draw(decimal money);
}

public class BankAccount : IDrawable
{
  private decimal balance = 1000;//余额
  public bool Draw(decimal money)
  {
    if(balance >= money) {
      balance -= money;
      return true
    }
    else  return false;
  }
} 
```

- 如果一个类声明支持某个接口，它就必须履行该接口的契约，即支持该接口中定义的所有方法。
- 如果支持接口的类型是非抽象的，那么它必须支持接口中的所有方法，并为这些方法提供具体实现；
- 如果支持接口的类型是抽象类，那么它必须支持接口中的所有方法，且这些方法要么提供具体实现，要么是抽象的。

- 如果一个类声明支持某个接口，它就必须履行该接口的契约，即支持该接口中定义的所有方法。

- 如果一个类声明支持某个接口，那么它的所有派生类也就自动支持该接口。

##### 隐式实现

说明：隐式实现接口方法时，既可以通过类的实例进行方法调用，也可以隐式转换为接口实例再进行方法调用。

```c#
public interface IDrawable
{
  bool Draw(decimal money);
}

public class BankAccount : IDrawable
{
  private decimal balance = 1000;
  public bool Draw(decimal money)//公有成员方法实现接口称作隐式实现
  {
    if(balance >= money) {
      balance -= money;
      return true
    }
    else  return false;
  }
}
BankAccount a1=new BankAccount();
a1.Draw(500); 
IDrawable I1=a1;
I1.Draw(600);
```

##### 显式实现

说明：显式实现接口方法时，在方法名前加上接口名，且接口名必须是定义方法的原始接口；此时方法不能使用任何修饰符，且不能通过类的实例访问，只能将类的实例转换为接口实例才能使用。

```c#
public interface IDrawable
{
  bool Draw(decimal money);
}

public class BankAccount : IDrawable
{
  private decimal balance = 1000;
  bool IDrawable.Draw(decimal money)//私有方法实现显示实现
  {
    if(balance >= money) {
      balance -= money;
      return true
    }
    else  return false;
  }
}
IDrawable  i1=new BankAccount();//接口对象调用类的实例
i1.Draw(600);
```

继承时,**类名要写在接口之前**

## 接口与多态

### 基于接口的多态性

含义：对接口的实例直接调用其方法，程序能够根据实现接口的实际对象类型来决定调用哪一个方法

```c#
public interface IPayable
{
  bool Pay(decimal money);
}

public class BankAccount : IPayable
{
  private decimal balance = 1000;
  public virtual bool Pay(decimal money)
  { ... }
}

public class CreditCard : BankAccount
{
  public override bool Pay(decimal money)
  { ... }
}
```

> 示例程序：P10_1
>
> 题目：银行账户(BankAccount)、信用卡(CreditCard)、借记卡(DebitCard)都可以完成支付功能。
>
> ![image-20220428100023124](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220428100023.png)
>
> ```c#
> using System;
> 
> namespace P10_1
> {
>     class Program
>     {
>         static void Main()
>         {
>             IPayable[] payers = new IPayable[4];
>             payers[0] = new BankAccount(3000);
>             payers[1] = new BankAccount(5000);
>             payers[2] = new CreditCard(5000);
>             payers[3] = new DebitCard((BankAccount)payers[1]);
>             foreach (IPayable payer in payers)
>             {
>                 Receive(payer, 1500);
>                 Receive(payer, 2000);
>             }
>             Console.ReadLine();
>         }
> 
>         static void Receive(IPayable payer, decimal money)
>         {
>             if (payer.Pay(money))
>                 Console.WriteLine("{0}成功付款{1}元", payer, money);
>             else
>                 Console.WriteLine("{0}付款失败", payer);
>         }
>     }
> 
>     public interface IPayable
>     {
>         bool Pay(decimal money);
>     }
> 
>     public class BankAccount : IPayable
>     {
>         protected decimal balance = 0;
>         public decimal Balance
>         {
>             get { return balance; }
>             set { balance = value; }
>         }
> 
>         public BankAccount(decimal balance)
>         {
>             this.balance = balance;
>         }
> 
>         public virtual bool Pay(decimal money)
>         {
>             //Pay方法的实现代码
>             if (balance >= money)
>             {
>                 balance -= money;
>                 return true;
>             }
>             else
>                 return false;
>         }
>     }
> 
>     public class CreditCard : BankAccount
>     {
>         private decimal credit;
>         public decimal Credit
>         {
>             get { return credit; }
>         }
> 
>         public CreditCard(decimal credit) : base(0)
>         {
>             this.credit = credit;
>         }
> 
>         public override bool Pay(decimal money)
>         {
>             if (balance +credit >= money)
>             {
>                 balance -= money;
>                 return true;
>             }
>             else
>                 return false;
>         }
>     }
> 
>     public class DebitCard : IPayable
>     {
>         private BankAccount account;
> 
>         public DebitCard(BankAccount account)
>         {
>             this.account = account;
>         }
> 
>         public bool Pay(decimal money)
>         {
>             //Pay方法的实现代码
>             return account.Pay(money);
>         }
>     } 
> }
> ```

利用接口来实现多态性，就可以达到“鱼和熊掌兼得”的效果，其关键就在于接口方法的隐式实现和显式实现可以并存

### 区分对象方法和接口方法

说明：显式实现的方法是对接口方法的真正实现，而隐式实现的方法可以看作是对原接口方法的覆盖。此时，通过接口实例调用的是显式实现的方法，而通过对象实例调用的则是隐式实现的方法

```c#
public interface IPayable
{
  bool Pay(decimal money);
}

public class BankAccount : IPayable
{
  private decimal balance = 1000;
  public virtual bool Pay(decimal money)//隐式 等价与 new(覆盖)
  { ... }
  bool IPayable.Pay(decimal money)//显示
  { ... }
}

public class CreditCard : BankAccount
{
  public override bool Pay(decimal money)
  { ... }
}
```

## 接口与多继承接口与多继承

### 类的单继承

- 缺点：单继承在表达能力上有一定的限制。例如，并不是所有的银行卡都能在POS机上消费，那么消费功能的描述就需要在BankAccount的派生类中重复多次。

### 多继承概述

将消费功能抽象在一个Payer类中。

- 缺点：
  - 带来二义性问题；
  - 基类过多，严重影响程序性能

C#规定：一个类只能有一个直接基类，但可以同时支持多个接口

![image-20220503090548426](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503090610.png)

### 基于接口的多继承

使用接口技术。如将消费功能抽象在一个IPayable接口中。

![image-20220503090811340](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503090811.png)

优点:
与类的多继承相比，C#基于接口的继承是轻量级的:接口之间的继承只是“契约”继承，不需要提供实现；当一个类支持多个接口时，它也只是实现各接口的“契约”服务，而不需要处理多重构造函数和重载方法等复杂情况。

#### 1.一个接口可以有多个父接口

```c#
public interface IA
{
  void FA();
}
public interface IB
{
  void FB();
}
public interface IC : IA, IB
{
  void FC();
}
```

#### 2.一个类可以支持多个接口；

如果同时存在类继承，基类应出现在所有接口之前

```c#
public class CA:IA, IB
{
  void IA.FA(){}
  void IB.FB(){} 
}
public class CC:CA,IC
{
  void IC.FC(){}
}
```

### 解决二义性

方法：通过显式实现明确方法来自于哪一个接口

```c#
public interface IA
{  void F();}

public interface IB
{  void F();}

public class CA
{
  public virtual void F()
  { Console.WriteLine(“类CA的F方法”);}
}
```

假定CA的派生类CB同时还支持接口IA和IB，那么CB对基类方法的继承以及对接口方法的实现分以下情况：

1. 如果CB没有定义方法F，那么它从CA继承的方法F就是对接口IA和IB的方法的隐式实现；

   ![image-20220503091623722](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503091624.png)

```c#
CB cb = new CB();
cb.F();
//((CA)cb).F();
CA ca = cb; 
ca.F();
//((IA)cb).F();
IA ia = cb;
ia.F();
//((IB)cb).F();
IB ib = cb; 
ib.F();
Console.ReadLine();
```

2. 如果CB只重载或隐藏了CA中的方法F，那么CB定义的成员方法F就是对接口方法的隐式实现；

   ![image-20220503092258359](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503092258.png)

```c#
CB cb = new CB();
cb.F();
//((CA)cb).F();
CA ca = cb; 
ca.F()//override根据实际类型调用 调用cb.F()  new根据声明类型调用ca.F()
//((IA)cb).F();
IA ia = cb;
ia.F();
//((IB)cb).F();
IB ib = cb; 
ib.F();
Console.ReadLine();

```

(3) 否则，CB可通过显式实现的方法来明确指定所实现的接口方法，但这不会影响到它对基类方法的继承或重载。

​	![image-20220503093432131](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503093432.png)

```c#
 public class CA
    {
        public  virtual void F()
        {
            Console.WriteLine("类CA的F方法");
        }
    }

    public class CB : CA, IA, IB
    {
        public override void F()   //如果将override改为new，输出什么？
        {
           Console.WriteLine("类CB的F方法");
        }

        void IA.F()
        {
           Console.WriteLine("接口IA的F方法");
        }
        void IB.F()
        {
           Console.WriteLine("接口IB的F方法");
        }
    }

static void Main(string[] args)
        {
            CB cb = new CB();
            cb.F();//cb
            CA ca = cb; 
            ca.F();//cb
            IA ia = cb;
            ia.F();//ia
            IB ib = cb; 
            ib.F();//ib
            Console.ReadLine();
        }
```

```c#
 public class CA
    {
        public  virtual void F()
        {
            Console.WriteLine("类CA的F方法");
        }
    }

    public class CB : CA, IA, IB
    {
        public new void F()   //如果将override改为new，输出什么？
        {
           Console.WriteLine("类CB的F方法");
        }

        void IA.F()
        {
           Console.WriteLine("接口IA的F方法");
        }
        void IB.F()
        {
           Console.WriteLine("接口IB的F方法");
        }
    }

static void Main(string[] args)
        {
            CB cb = new CB();
            cb.F();//cb
            CA ca = cb; 
            ca.F();//ca
            IA ia = cb;
            ia.F();//ia
            IB ib = cb; 
            ib.F();//ib
            Console.ReadLine();
        }
```

> 银行卡的实现
>
> ![image-20220503094611425](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503094611.png)

> ![image-20220503095823757](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503095824.png)
>
> ```c#
> using System;
> 
> namespace P10_4
> {
>     class Program
>     {
>         static void Main()
>         {
>             Seaplane plane = new Seaplane();
>             IFlyable flyer = plane;
>             Console.WriteLine("{0}空中飞行1000公里需{1}小时", flyer, flyer.Run(1000));
>             ISwimmable swimmer = plane;
>             Console.WriteLine("{0}水上航行1000公里需{1}小时", swimmer, swimmer.Run(1000));
>             Amphicar car = new Amphicar(80);
>             Console.WriteLine("{0}地面行驶1000公里需{1}小时", car, car.Run(1000));
>             swimmer =car;
>             Console.WriteLine("{0}水上航行1000公里需{1}小时", swimmer, swimmer.Run(1000));
>             Console.ReadLine();
>         }
>     }
> 
>     public interface IFlyable
>     {
>         float Run(float distance);
>     }
> 
>     public interface ISwimmable
>     {
>         float Run(float distance);
>     }
> 
>     public class Seaplane : IFlyable, ISwimmable
>     {
>         float ISwimmable.Run(float distance)
>         {
>             return distance / 50;
>         }
> 
>         float IFlyable.Run(float distance)
>         {
>             return distance / 400;
>         }
>     }
> 
>     public class Automobile
>     {
>         private float speed;
>         public float Speed
>         {
>             get { return speed; }
>         }
> 
>         public virtual float Run(float distance)
>         {
>             return distance / speed;
>         }
> 
>         public Automobile(float speed)
>         {
>             this.speed = speed;
>         }
>     }
> 
>     public class Amphicar : Automobile, ISwimmable  //基类在前，接口在后
>     {
>         public Amphicar(float speed): base(speed)
>         { }
>         float ISwimmable.Run(float distance)
>         {
>             return base.Run(distance) * 3;
>         
>         }
>     }
> 
> }
> ```

## 接口与集合

### 集合型接口及其实现

像列表、堆栈、队列等集合类型在计算机程序中有着广泛的应用。.NET类库的System.Collections命名空间下定义了一组与集合有关的接口，并通过在预定义集合类型中支持不同的接口来提供相关服务。

### .NET类库中与集合有关的常用接口类型

![image-20220503100114123](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503100114.png)

### .NET类库中主要集合类型 

![image-20220503100612914](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503100613.png)

#### ArrayList类

其实现了IList接口的各个方法，并由此提供了动态数组的功能。集合的大小会自动调整。
int  Add(object)                          void   Clear();
bool  Contains(object)                void  Insert(int ,object)
int  IndexOf(object)                    void  Remove(object)
void  RemoveAt(int)
object  this[int index]{get;set;}
ArrayList自定义成员方法
BinarySearch和Sort可用于集合元素的查找和排序。

```c#
static void Main()
        {
            ArrayList al1 = new ArrayList();
            al1.Add("王小红");
            al1.Add("周军");
            al1.Insert(0, "方小白");
            al1.Add("Smith");
            al1.Insert(1, "Jerry");
            Console.WriteLine("排序前: ");
            foreach (object obj in al1)
            {
                Console.Write(obj);
                Console.Write(' ');
            }
            al1.Sort();
            Console.WriteLine("\n排序后: ");
            foreach (object obj in al1)
            {
                Console.Write(obj);
                Console.Write(' ');
            }
            Console.ReadLine();
    //
排序前:
方小白 Jerry 王小红 周军 Smith
排序后:
Jerry Smith 方小白 王小红 周军
```

#### Queue类

```c#
 static void Main( )
 {         Queue q1 = new Queue();
            q1.Enqueue(10);
            q1.Enqueue("河北联合大学");
            q1.Enqueue(DayOfWeek.Sunday);
            while (q1.Count > 0)
                Console.WriteLine(q1.Dequeue());
}
```

#### Stack类

常用方法：
Clear：从 Stack 中移除所有对象
Pop：移除并返回位于 Stack 顶部的对象
Push：将对象插入 Stack 的顶部
Peek：返回位于 Stack 顶部的对象但不将其移除
Stack类将它的对象存储在数组。只要数组足够大到可以存储新的对象，调用Push方法就是非常有效的。

```c#
  static void  Main( )
  {        Stack s1 = new Stack();
            s1.Push(10);
            s1.Push("河北联合大学");
            s1.Push(DayOfWeek.Sunday);
            while (s1.Count > 0)
            {     Console.WriteLine(s1.Pop());    }
  }
```

#### ArrayList、Queue和Stack类

除了默认的无参构造函数外，它们都提供了以ICollection为参数类型的构造函数，它表示在创建集合对象的同时从指定的集合复制元素，这样就能在这些集合类型以及数组之间方便地进行数据交换。

```c#
示例程序：利用链表和堆栈对一维数组进行排序（paixu）
int[]  x={5,9,6,3,-6};
ArrayList all =new ArrayList(x);//从数组x创建链表对象 
all.Sort();
foreach(int i in all)Console.WriteLine(i);//顺序输出
Stack s1=new Stack(all)
foreach(int i in s1) Console.WriteLine(i);//逆序输出
```

# 第11章  泛型程序设计

#### Stack类

Stack类以object为元素类型，从而支持在Stack中存储任意类型的对象。

```c#
using   System;
Using  System.Collections;
static void  Main( )
  {        Stack s1 = new Stack();
            s1.Push(10);
            s1.Push("河北联合大学");
            s1.Push(DayOfWeek.Sunday);
            while (s1.Count > 0)
            {     Console.WriteLine(s1.Pop());    }
  }
```

在实际应用中，把不同类型的对象存放在一个集合中没有太多的意义。人们更感兴趣的是同一类型的对象集合，比如整数的集合、学生对象的集合等。如下面的程序将利用堆栈处理整数。

```c#
 static void Main( )
{
  int[] x1 = { 5, -6, 10, 3, 88 };
  Stack s1 = new Stack();
  for (int i = 0; i < x1.Length; i++)
      s1.Push(x1[i]);//装箱 数值->引用  (降低性能)
  int[] x2 = new int[x1.Length];
  for (int i = 0; i < x2.Length; i++)
      x2[i] = (int)s1.Pop();//拆箱 引用->整形  (降低性能)

  foreach (int i in x2)
  Console.Write(i + "  ");
 }
```

**解决**

```c#
public class IntStack
{
  private int[] items = new int[100];
  private int current = 0;
  public void Push(int x) {
    items[current++] = x;  }
  public int Pop() {return items[--current];  }
}

public static void Main()
{
   IntStack st = new IntStack();
   for (int i = 1; i <= 10; i++) st.Push(i);//无装箱
   for (int i = 1; i <= 10; i++)
   {   int x = st.Pop();//无拆箱
       Console.WriteLine(x);
   }   
}
```

```c#
public class StringStack
{
  private string[] items = new string[100];
  private int current = 0;
  public void Push(string x) {
    items[current++] = x;
  }
  public string Pop() {
    return items[--current];
  }
}

public static void Main()
{
  StringStack st = new StringStack();
  for(int i=1; i<=10; i++)
    st.Push(new string(‘a’,i));
  string y = st.Pop();
}
```

```c#
public class DoubleStack
{ …… }

public class DateTimeStack
{ …… }

public class StudentStack
{ …… }

public class TeacherStack
{ …… }
```

**但是，为每一种元素类型都定义一个新的堆栈类型，代码的可复用性太差。更好的方法是？**

## 泛型类

```c#
public class Stack<T>//T:抽象数据类型/类型参数
{
  private T[] items = new T[100];
  private int current = 0;
  public void Push(T x) { items[current++] = x; }
  public T Pop() { return items[--current]; }
}

public static void Main()
{
  Stack<int> st1 = new Stack<int>();//使用时要具体化、实例化  实例化后->构造类型
  Stack<string> st2 = new Stack<string>();
  for(int i=1; i<=10; i++) {
    st1.Push(i);
    st2.Push(new string(‘a’,i));
  }
  for (int i = 1; i <= 10; i++)
  { int x = st1.Pop(); Console.WriteLine(x);
    string y = st2.Pop(); Console.WriteLine(y);
  }
}
```

**泛型**:使算法与数据结构脱离

在 .NET下，`System.Collections.Generic`命名空间下已经定义好了泛型类`Stack<T>`，我们可以直接使用。

#### 泛型的优越性

- 更高层次上的抽象性
- 对算法和数据结构更强的表达能力
- 更为方便的复用：参数替换
- 类型安全性：无需装箱/拆箱
- 不损害程序性能而实现更高的灵活性

### 声明

类名+类型参数

```c#
public class Stack<T>
{
}
```

类型参数T表示一个抽象数据类型，在使用时可被不同的具体类型所替代。

### 定义

使用类型参数指代类型

```c#
public class Stack<T>
{
  private T[] items = new T[100];
  private int current = 0;
  public void Push(T x)
  {
    items[current++] = x;
  }
}
```

### 使用

类型参数代入具体类型

```c#
public class Stack<T>
{
  private T[] items = new T[100];
  private int current = 0;
  public void Push(T x)
  {
    items[current++] = x;
  }
}

public static void Main()
{
  Stack<int> st1 =new Stack<int>();//称Stack<int>为Stack<T>的构造类型
  for(int i=1; i<=10; i++)
    st1.Push(i);
}
```

### 说明

- 泛型类本身不能创建对象；
  `Stack<T>  s1=new  Stack<T>( ); ❌` 
- 由泛型类的构造类型创建对象；
  `Stack<int>  s1=new  Stack<int>( );✔️`

类是对一组对象的抽象，而泛型类是对一组普通类的抽象。在具体使用时，由其他数据类型替换类型参数。

- 类型参数使用场合
  - 字段和属性类型
  - 方法的参数类型和返回类型
  - 方法代码中的局部变量类型

- 操作符重载
  - 被重载的操作符必须被声明为公有的和静态的，并通过在关键字operator后跟操作符来声明
  - 重载一元操作符时，参数类型应为当前泛型类；
  - 重载二元操作符时，至少有一个参数类型应为当前泛型类；
  - 重载类型转换操作符时，还可以使用类型参数来指代转换的目标类型。

#### 使用“抽象型”变量

含义：抽象型变量指使用类型参数定义的变量（如程序示例中的data）。

说明：在定义泛型时，我们并不能确定类型参数会被替换为哪种具体类型。因此在泛型类的方法代码中，对抽象型变量，不能随意进行赋值和成员调用。

`public static bool operator ==(LinkNode<T> node1, LinkNode<T> node2)`
`{`
    `return  (node1.datanode2.data);`:x:
`}`

`public static bool operator !=(LinkNode<T> node1, LinkNode<T> node2)`
`{`
    `return  (node1.data!=node2.data);`:x:
`}`

`public static bool operator ==(LinkNode<T> node1, LinkNode<T> node2)`
`{`
    `return  (node1.data.Equals(node2.data));`:heavy_check_mark:
`}`

`public static bool operator !=(LinkNode<T> node1, LinkNode<T> node2)`
`{`
    `return !(node1.data.Equals(node2.data));`:heavy_check_mark:
`}`

如果在LinkNode<T>的定义中，出现

`public T data=null;`      :x:

`public LinkNode()`
`{`
    `data=0;`:x:
`}`

`public LinkNode()`
`{`
 `data=default(T); //通过关键字default可获得抽象型变量的默认值`:heavy_check_mark:

`}`

#### 多个类型参数

```c#
public class Stack { }

public class Stack<T> { }

public class Stack<S, T> { }

public class Stack<R, S, T> { }
//在程序中，同时定义这四个同名的泛型类正确
```

```c#
public class Stack<S> { }

public class Stack<T> { }

public class Stack<A, B> { }

public class Stack<S, T> { }
//泛型类的类型参数的名称仅仅是一个指代作用，而不能区分不同的类型。
```

```c#
 public class Pair<L,R>
    {   public L Left;
        public R Right;

        public Pair(L left,R right)
        {   Left=left;
            Right = right; } 

        public void SetValue(L l)
        {   Left = l;      }

        public void SetValue(R r)
        {   Right = r;     }
    }
//说明1：泛型类的类型参数足以区分不同的方法成员，因此成员方法可以重名。
```

```c#
Pair<int,string> p1 = new Pair<int,string>(0,null);
p1.SetValue(5); //调用SetValue(L l)
p1.SetValue("王小红"); //调用SetValue(R r)
```

说明1：虽然成员方法可以重名，但如果因类型参数的替换而导致出现两个标识相同的方法成员，则不能通过编译。

``Pair<int,int> p1 = new Pair<int,int>(0,0);`

`p1.SetValue(5);`

`//错误：存在歧义`:x:

说明2：当两个方法重名时，如果一个方法的原型使用了类型参数，而另外一个没有，此时不会引起歧义，程序总是调用后者。

`Pair<int> p1 = new Pair<int>(0);`
`p1.SetValue(5); //调用SetValue(int i)`
`Pair<string> p2 = new Pair<string>("");`
`p2.SetValue(5); //调用SetValue(int i)`
`p2.SetValue("王小红"); //调用SetValue(T t)`:heavy_check_mark:

## 类型限制

### 无限制的类型参数T

可见，如果对类型参数T不加以限制，容易引发错误。

`T t1 = 0;`

`T t2 = null;`

`if (t1 == t2)`

  `Console.Write(typeof(T));`:x:

### 主要限制

主要限制是指类型参数只能被替换为值类型或引用类型。

- struct: 值类型
- class: 引用类型

```c#
public class Stack<T>
 where T : class
{ }
T t1 = null;
T t2 = null;
if (t1 == t2)
  Console.Write(typeof(T));
```

可以对多个类型参数进行限制，此时，使用多个where限制子句，之间通过空格或换行符进行分隔。

```c#
public class Pair<L,R>
 where L : class  where R : struct
{ }
```

### 次要限制

次要限制是将类型参数的目标类型限制为指定的基类或接口继承，声明方式为在where子句的冒号后面跟基类或接口的名字。

#### 基类限制

可见，只要对类型参数进行了基类限制，那么就能够对相应的“抽象型”变量调用这些基类的成员。

```c#
public class A
{
  public int GetValue() {}
  public static A operator ++ (A a) {}
}

public class Stack<T> where T : A
{ }
//泛型类调用基类方法
T t1 = null;
int x = t1.GetValue()++;
T t2 = t1++;
```

#### 接口限制

可见，次要限制能够给程序带来很大方便，因为只要对类型参数进行了基类和接口限制，那么就能够对相应的“抽象型”变量调用这些基类和接口的成员。

```c#
public class Pair<L,R> where R:IComparable
{ public L Left;
  public R Right;
  public Pair(L left, R right)
  { Left=left;  Right=right;  }
  public static bool operator >(Pair<L,R> p1, Pair<L,R> p2)
  { return (p1.Right.CompareTo(p2.Right)>0);  }
  public static bool operator >(Pair<L,R> p1, Pair<L,R> p2)
  { return (p1.Right.CompareTo(p2.Right)<0);  }
}
```

#### 次要限制其它说明

```c#
public class Student{//……};
public class Pair<L,R> where R : Student , IComparable
{ //……
}
```

次要限制中最多只能有一个基类（C#支持类的单继承），但可以有多个接口（ C#支持接口的多继承），之间以逗号分隔。

如果存在基类限制，那么基类应该写在所有接口之前。

#### 构造函数限制

构造函数限制也叫作new限制，它要求类型参数的目标类型必须提供一个无参的构造函数。书写格式是new关键字加一对括号，并应写在其它所有限制之后。

```c#
public class Pair<L , R>  where R : IComparable , new()
{  public L Left;
   public R Right;

   public Pair()
   {  Left=default(L);  Right=new R();    }

   public Pair(L left , R right)
   {  Left=left;  Right=right;  }
}
```

