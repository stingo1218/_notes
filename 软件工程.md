平时40%

- 课堂活动20%
- 作业30%
- 上机30%
- 随测20%

考试60%

# 1.概述

软件的特点 

- 逻辑实体
- 没有明显的制造过程
- 没有硬件那样的机械磨损，老化问题
- 软件的开发和运行常受到计算机系统的限制，对计算机系统有着不同程度的依赖性。这导致了软件移植问题。
- 软件本身是复杂的
  - 实际问题的复杂性
  - 程序逻辑结构的复杂性 
- 软件大多是定制的。而不是装配的。
- 软件成本相当昂贵
- 相当多的软件工作涉及到社会因素

软件发展趋势

（1）遗留软件将继续发挥作用
（2）软件应用范围将继续扩大，成为信息社会的物理设施
（3）网络化软件将是发展重点
（4）软件的可靠性与安全性日趋重要
（5）工业化生产是必由之路

## 1.1软件危机

在计算机软件的开发和维护过程中所遇到的一系列严重问题。主要包含两方面：

- 如何开发软件，以满足不断增长，日趋复杂的需求；
- 如何维护数量不断膨胀的软件产品。

软件危机的典型表现:

- 软件开发成本和进度估算常常很不准确
- 用户对软件功能难以满足-沟通困难
- 软件产品质量无法保证
- 软件产品难以维护
- 软件缺少文档资料
- 软件成本在计算机系统总成本所占比例不断提高。 
- 软件开发生产率的提高赶不上人们需求的增长

中国软件存在的问题:

- 缺乏资金,规模小
- 认识与实际成本不吻合
- 盗版严重
- 缺少技术管理型人才
- 不重视人才市场
- 重复式开发,质量差
- 技术封锁互相抄袭

原因:

- 软件是逻辑产品,运行之前无法掌握进展,带来管理和控制不便
- 受实际问题的复杂性影响
- 软件产品使用寿命很长,维护费用占总费用55%~70%
- 开发人员与用户的矛盾
- 急于求成,降低成本

### 1.1.3消除软件危机的途径

- 树立对软件的正确认识
- 团队协作,不要单打独斗
- 总结经验,研究方法
- 积极开发使用辅助工具

## 1.2软件工程

应用计算机科学理论和技术和工程管理原则和方法,按预算进度,实现和满足用户要求的软件产品的定义开发发布和维护的工程或进行研究的学科

软件具有的本质特性:

- 专注大型程序的构造
- 中心课题是控制复杂性
- 经常变化
- 效率很重要
- 合作是关键
- 必须有效支持用户
- 学习用户领域知识

### 1.2.2 软件工程基本原理

1. 用分阶段的生命周期计划严格管理
2. 坚持进行阶段评审
3. 实行严格的产品控制
4. 使用现代化程序设计技术
5. 明确责任
6. 用人少而精
7. 承认不断改进软件工程实践的必要性
   - 总结开发经验

**主要研究内容**

1. 软件开发技术
   1. 软件开发方法学
      - 研究开发高质量软件的方法
      - 提供<u>软件开发模型</u>和<u>软件产品描述模型</u>
   2. 软件工具
      - 研究软件工具开发的理论和技术
      - 支持计算机软件的开发/维护/模拟/移植
   3. 软件工程开发环境
      - 相关的软件工具的集合
2. 软件管理技术
   1. 软件管理学
      - 对开发项目进行管理
   2. 软件工程经济学
      - 节省成本

**软件工程技术特点**:

1. 规范化
2. 文档化

**软件工程四要素**

1. 方法
   - 构造软件的技术
2. 语言
   - 支持软件的分析设计和实现
3. 工具
   - 提供自动或半自动支持
4. 过程
   - 任务框架,规定各项任务的工作步骤

### 1.2.3 软件工程方法学

1. 传统方法学
   - 生命周期方法学/结构化范型
   - 划分生命周期为阶段
   - 阶段末尾审查
   - 高质量文档资料,保证结束时有准完整确的软件配置交付使用
   - 大大提高开发成功率
2. 面向对象方法学
   - 把数据和对数据的操作紧密结合
   - 四个要点
   - 模拟人类习惯的思维方式
   - 优点
     - 降低软件复杂性
     - 提高可理解性
     - 简化开发和维护工作
     - 提高可重用性

## 1.3 软件生存周期

**生存期**:从开始研制到被废弃不用的时间

**生存周期**:将生存期划分为若干阶段

1. 软件定义
   - 问题定义
     - 要解决的问题是什么
   - 可行性研究
     - 对于上一个阶段确定的问题有行得通的解决办法吗
   - 需求分析
     - 为了解决这个问题，目标系统必须做什么
2. 软件开发
   - 总体设计
     - 概括地说，应该怎样实现目标系统
   - 详细设计
     - 应该怎样具体实现目标系统
   - 编码和单元测试
     - 关键任务是写出正确的容易理解、容易维护的程序模块，并仔细测试每个编写出的模块。 
   - 综合测试
     - 关键任务是通过各种类型的测试（及相应的调试）使软件达到预定的要求。 
3. 运行维护
   - 主要任务是通过各种必要的维护活动，使系统持久地满足用户需要

## 1.4软件过程

软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。软件过程描述为了开发出客户需要的软件，什么人(who)、在什么时候(when)、做什么事(what)以及怎样(how)做这些事以实现某一个特定的具体目标。

 **ISO 9000定义**：<u>软件工程过程是把输入转化为输出的一组彼此相关的资源和活动。从软件开发的观点看，它就是使用适当的资源（包括人员、硬软件工具、时间等），为开发软件进行的一组开发活动，在过程结束时将输入（用户要求）转化为输出（软件产品）。</u>

**软件工程过程包含四种基本的过程活动**：

-  plan : 软件规格说明
-  do : 软件开发
-  check : 软件确认
-  action : 软件演进

### 1.4.1  瀑布模型

瀑布模型一直是唯一被广泛采用的生命周期模型，现在它仍然是软件工程中应用得最广泛的过程模型。如下图所示为传统的瀑布模型

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308141722.png" alt="image-20220308141722347" style="zoom:50%;" />

**特点**:

- 阶段间具有顺序性和依赖性
- 推迟实现的观点
- 质量保证的观点

**优点:**

- 可强迫开发人员采用规范的方法（例如，结构化技术）；
-  严格地规定了每个阶段必须提交的文档；
- 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。



### 带反馈环的瀑布模型

![image-20220308141951973](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308141952.png)

1、图中实线箭头表示开发过程，虚线箭头表示维护过程。
2、实际的瀑布模型当在后面阶段发现前面阶段的错误时，需要沿图中左侧的反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。

### 1.4.2. 快速原型模型

快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。

![image-20220308142103107](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151057.png)

**优点:**

快速原型模型是不带反馈环的，这正是这种过程模型的主要优点： 软件产品的开发基本上是线性顺序进行的

**原因:**

（1） 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。

（2） 开发人员通过建立原型系统已经学到了许多东西，因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。

### 1.4.3. 增量模型

增量模型也称为渐增模型。使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能

![image-20220308142211228](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308142211.png)

**优点:**

- 能在较短时间内向用户提交可完成部分工作的产品。
- 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。

**困难:**

- 在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。
- 必须把软件的体系结构设计得便于按这种方式进行扩充，向现有产品中加入新构件的过程必须简单、方便，也就是说，软件体系结构必须是开放的。

### 风险更大的增量模型：

![image-20220308142308834](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308142308.png)

## 1.4.4 螺旋模型

螺旋模型的基本思想是，使用原型及其他方法来尽量降低风险。理解这种模型的一个简便方法，是把它看作在每个阶段之前都增加了风险分析过程的快速原型模型

**简化版**:

![image-20220308142507069](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308142507.png)

**完整版**:

![image-20220308142520557](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308142520.png)

### 1.4.5. 喷泉模型

“喷泉”这个词体现了面向对象软件开发过程迭代和无缝的特性。迭代是软件开发过程中普遍存在的一种内在属性。用面向对象方法学开发软件时，工作重点应该放在生命周期中的分析阶段。

![image-20220308142602410](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308142602.png)

**特点**:

- 迭代
- 无间隙

### 1.4.6. Rational统一过程

#### 1.统一过程

Rational统一过程（Rational Unified Process,RUP）是由Rational软件公司推出的一种完整而且完美的软件过程

1. 迭代式开发

   迭代式开发允许在每次迭代过程中需求都可以有变化，这种开发方法通过一系列细化来加深对问题的理解，因此能更容易地容纳需求的变更。

2. 管理需求

   RUP描述了如何提取、组织系统的功能性需求和约束条件并把它们文档化。

3. 使用基于构件的体系结构

   RUP提供了使用现有的或新开发的构件定义体系结构的系统化方法，从而有助于降低软件开发的复杂性，提高软件重用率。

4. 可视化建模

   与可视化建模语言UML紧密地联系在一起，在开发过程中建立起软件系统的可视化模型，可以帮助人们提高管理软件复杂性的能力。

5. 验证软件质量
       软件质量评估不再是事后型的或由单独小组进行的孤立活动，而是内建在贯穿于整个开发过程的、由全体成员参与的所有活动中。
6. 控制软件变更
       RUP描述了如何控制、跟踪和监控修改，以确保迭代开发的成功。

### 2. RUP软件开发生命周期

RUP软件开发生命周期是一个二维的生命周期模型，如下图1.10所示。图中纵轴代表核心工作流，横轴代表时间。
（1）核心工作流
RUP中有9个核心工作流，其中前6个为核心过程工作流程，后3个为核心支持工作流程。

![image-20220308142904433](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308142904.png)

**核心过程工作流程**

1）**业务建模工作流**：描述业务过程的本质和执行情形。
2）**需求工作流**：定义系统构想，使用用例模型和补充规格说明定义系统软件需求，管理系统范围和需求变更。
3）**分析和设计工作流**：研究实现环境和系统构件的效用，定义软件的组织结构，把需求获取结果转化为实现规格。

4）**实现工作流**:建立代码的分层结构，实现类和对象，进行单元测试和系统集成。
5）**测试工作流**：根据事先定义的度量和准则检查产品，确认产品是否满足或者超出事先定义并被一致接受的需求。
6）**实施工作流**：在实际使用环境中测试软件、包装要交付的软件、发布软件产品、培训最终用户及销售人员。

**核心支持工作流程**

1）配置与变更管理:跟踪并维护在软件开发过程中产生的所有制品的完整性和一致性。
2）项目管理：提供项目管理框架，为软件开发项目制定计划、人员配备、执行和监督等方面的实用准则，并为风险管理提供框架。
3）环境：向软件开发机构提供软件开发环境，包括过程管理和工具支持。

**工作阶段**

RUP把软件生命周期划分成4个连续的阶段。每个阶段都有明确的目标，并且定义了用来评估是否达到这些目标的里程碑。每个阶段的目标通过一次或多次迭代来完成。

![image-20220308143104770](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308143104.png)

1. **初始阶段**：确定最终产品的构想及其用例，定义项目范围。
2. **细化阶段**：计划需要完成的活动和资源，详细说明产品特性并设计软件体系结构。
3. **构造阶段**：构造整个产品，逐步完善软件体系结构和计划，直到产品（完整的构想）已完全准备好交付给用户。
4. **移交阶段**：移交产品给用户，包括交付，培训，支持及维护产品。

**RUP迭代式开发**

RUP重复一系列组成软件生命周期的循环。每次循环都经历一个完整的生命周期，每次循环结束都向用户交付产品的一个可运行的版本。每个阶段又进一步细分为一次或多次迭代过程。

![image-20220308143159299](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308143159.png)

### 1.4.7.敏捷过程与极限编程

**敏捷过程**为了使软件开发团队具有高效工作和快速响应变化的能力，17位著名的软件专家于2001年2月联合起草了敏捷软件开发宣言。敏捷软件开发宣言由下述4个简单的价值观声明组成。

- 个体和交互胜过过程和工具
- 可以工作的软件胜过面面俱到的文档
- 客户合作胜过合同谈判
- 响应变化胜过遵循计划

**极限编程**（eXtreme Programming,XP）是敏捷过程中最富盛名的一个，其名称中“极限”二字的含义是指把好的开发实践运用到极致。应用于需求模糊且经常改变的场合

 （1）极限编程的有效实践
＊计划游戏：客户、开发人员通过故事卡功能卡进行沟通 
＊小版本：获得来自生产环境的直接反馈
＊隐喻：通过众所周知的故事指导开发
＊简单设计：当然，写复杂代码肯定不利于程序员间的沟通 
＊结对编程：两个程序员坐在一个屏幕前直接就如何编写代码沟通 
＊集体所有权：任何人任何时候对任何代码都有修改权，基于代码的沟通，当然，要求代码好读是必须的，简单设计起到了很好的作用 
＊现场客户：客户回答程序员提出的问题
＊编码标准：是一种开发团队遵循的沟通规则

**极限编程的整体开发过程**

![image-20220308143314179](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151058.png)

![image-20220308143322253](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151059.png)

### 1.4.8. 微软过程

1.**微软过程准则**：
    项目计划应该兼顾未来的不确定因素。
 用有效的风险管理来减少不确定因素的影响。
 经常生成并快速地测试软件的过渡版本，从而提高产品的稳定性和可预测性。
 采用快速循环、递进的开发过程。
 用创造性的工作来平衡产品特性和产品成本。
 项目进度表应该具有较高稳定性和权威性。
 使用小型项目组并发地完成开发工作。
 在项目早期把软件配置项基线化，项目后期则冻结产品。
 使用原型验证概念，对项目进行早期论证。
 把零缺陷作为追求的目标。
 里程碑评审会的目的是改进工作，切忌相互指责。

2.**微软软件生命周期**：

- 规划阶段
- 设计阶段
- 开发阶段
- 稳定阶段
- 发布阶段

![image-20220308143415648](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308143415.png)

3.**微软过程模型**：

微软过程的每一个生命周期发布一个递进的软件版本，各个生命周期持续、快速地迭代循环

![image-20220308143433895](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308143433.png)

**软件工程项目的基本目标有**：

1. 付出较低的开发成本
2. 达到要求的软件功能
3. 取得较好的软件性能
4. 开发的软件易于移植
5. 需要较低的维护费用
6. 能按时完成开发工作，及时交付使用

**软件工程目标之间的关系**

![image-20220308143514504](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308143514.png)

# 2.可行性研究

## 2.1 可行性研究的任务

 用最小的代价在尽可能短的时间内确定问题是否能够并且值得解决。

**可行性研究分析过程：**

首先，进一步分析和澄清问题定义
然后，分析员应该导出系统的逻辑模型
最后，探索若干种可供选择的主要解法

1. 问题定义的基本任务

核心主题是：需要回答“要解决的问题是什么？”
    主要内容：软件开发背景，待开发系统的现状，软件开发的条件，问题求解的范围和类型，最终目标以及实现目标的可能方案。

   开发者和用户一起，讨论待开发的软件项目的类型，项目的性质，项目的目标（软件最主要的使用功能），软件规模，项目负责人（开发方，用户方）等问题，最后简明扼要写出书面问题定义报告，并且双方对问题报告签字生效。

2. 问题定义报告内容

- 待开发项目的名称
- 软件项目使用单位和部门
- 软件项目开发单位
- 对问题的概括定义
- 软件项目的用途和目标
- 软件项目的类型和规模
- 软件项目开发的开始时间以及大致的交付时间
- 软件项目开发可能投入的经费
- 软件项目使用单位和开发单位全称及其盖章
- 软件项目使用单位和开发单位双方负责人签字

| **用户单位**                                           | **XXXXX****水利局、地震局**                                  |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| **用户负责人**                                         | **XXX**                                                      |
| **开发单位**                                           | **XX****软件开发公司**                                       |
| **开发单位负责人**                                     | **XXX**                                                      |
| **项目名称**                                           | **三防决策系统**                                             |
| **问题描述**                                           | **手工无法完成防风、防汛、防震的事务，也无法预测某些地区在某些时间段内三防的具体情况****……****（其他的主要问题）** |
| **项目目标**                                           | **开发一个效率较高的三防决策系统，便于相关部门能及时地掌握三防实时动态，并能根据历史情况进行较为准确的预测，为该部门提供准确有力的参考数据从而进行判断。** |
| **项目规模**                                           | **开发成本约****X****万元**                                  |
| **可行性研究**                                         | **建议进行三个月，费用不超过****XXX****元**                  |
| **XXXX****年****XX****月****XX****日   签字：****XXX** |                                                              |

**至少应该从下述4个方面研究每种解法的可行性**

1. 技术可行性：使用现有的技术能实现这个系统吗？
   - 技术解决方案的实用性
   - 技术资源的可用性
2. 经济可行性：这个系统的经济效益能超过它的开发成本吗？
   - 系统经济效益=新系统增加的收入＋新系统节省的费用
   - 考虑：成本——效益分析、长期的公司经营策略、对其他单位或产品的影响、开发所需的成本和资源、潜在的市场前景
3. 操作可行性：系统的操作方式在用户组织内行得通吗？
   - 用户类型：外行型／熟练型／专家型
   - 操作习惯
   - 使用单位的计算机使用情况
   - 使用单位的规章制度
4. 法律可行性（侵权和责任问题）
   - 专利法
   - 著作权法
   - 软件保护条例

## 2.2 可行性研究过程

![image-20220308144250264](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308144250.png)

1.**复查系统规模和目标**

分析员访问关键人员，仔细阅读和分析有关的材料，以便对问题定义阶段书写的关于规模和目标的报告书进一步复查确认，改正含糊或不确切的叙述，清晰地描述对目标系统的一切限制和约束。这个步骤的工作，实质上是为了确保分析员正在解决的问题确实是要求他解决的问题。

2.**研究目前正在使用的系统**

现有的系统是信息的重要来源。显然，如果目前有一个系统正被人使用，那么这个系统必定能完成某些有用的工作，因此，新的目标系统必须也能完成它的基本功能；另一方面，如果现有的系统是完美无缺的，用户自然不会提出开发新系统的要求，因此，现有的系统必然有某些缺点，新系统必须能解决旧系统中存在的问题。
应该仔细阅读分析现有系统的文档资料和使用手册，也要实地考察现有的系统。
常见的错误做法是花费过多时间去分析现有的系统。
没有一个系统是在“真空”中运行的，绝大多数系统都和其他系统有联系。

3.**导出新系统的高层逻辑模型**

优秀的设计过程通常是从现有的物理系统出发，导出现有系统的逻辑模型，再参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。

4.**进一步定义问题**

可行性研究的前4个步骤实质上构成一个循环。分析员定义问题，分析这个问题，导出一个试探性的解；在此基础上再次定义问题，再一次分析这个问题，修改这个解；继续这个循环过程，直到提出的逻辑模型完全符合系统目标。

5.**导出和评价供选择的解法**

分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的物理解法供比较和选择。
其次可以考虑操作方面的可行性。分析员应该根据使用部门处理事务的原则和习惯检查技术上可行的那些方案，去掉其中从操作方式或操作过程的角度看用户不能接受的方案。
接下来应该考虑经济方面的可行性。分析员应该估计余下的每个可能的系统的开发成本和运行费用，并且估计相对于现有的系统而言这个系统可以节省的开支或可以增加的收入。
最后为每个在技术、操作和经济等方面都可行的系统制定实现进度表，这个进度表不需要制定得很详细，通常只需要估计生命周期每个阶段的工作量。

6.**推荐行动方针**

根据可行性研究结果应该决定的一个关键性问题是： 是否继续进行这项开发工程？分析员必须清楚地表明他对这个关键性决定的建议。如果分析员认为值得继续进行这项开发工程，那么他应该选择一种最好的解法，并且说明选择这个解决方案的理由。通常客户主要根据经济上是否划算决定是否投资于一项开发工程，因此分析员对于所推荐的系统必须进行比较仔细的成本/效益分析。

7.**草拟开发计划**

分析员应该为所推荐的方案草拟一份开发计划，除了制定工程进度表之外还应该估计对各类开发人员和各种资源的需要情况，应该指明什么时候使用以及使用多长时间。此外还应该估计系统生命周期每个阶段的成本。最后应该给出下一个阶段(需求分析)的详细进度表和成本估计。

8.**书写文档提交审查**

应该把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。

## 2.3 系统流程图

系统流程图是概括地描绘物理系统的传统工具。

**基本思想**：
    用图形符号以黑盒子形式描绘组成系统的每个部件(程序、文档、数据库、人工过程等)。

系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而不是程序流程图。

### 2.3.1符号

利用符号可以把一个广义的输入输出操作具体化为读写存储在特殊设备上的文件（或数据库），把抽象处理具体化为特定的程序或手工操作等。

![image-20220308145445135](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308145445.png)

![image-20220308145452447](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308145452.png)

### 2.3.2 示例

某装配厂有一座存放零件的仓库，仓库中现有的各种零件的数量以及每种零件的库存量临界值等数据记录在库存清单主文件中。当仓库中零件数量有变化时，应该及时修改库存清单主文件，如果哪种零件的库存量少于它的库存量临界值，则应该报告给采购部门以便订货，规定每天向采购部门送一次订货报告。

该装配厂使用一台小型计算机处理更新库存清单主文件和产生订货报告的任务。零件库存量的每一次变化称为一个事务，由放在仓库中的CRT终端输入到计算机中；系统中的库存清单程序对事务进行处理，更新存储在磁盘上的库存清单主文件，并且把必要的订货信息写在磁带上。最后，每天由报告生成程序读一次磁带，并且打印出订货报告。
如下图所示。

![image-20220308145515156](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308145515.png)

### 2.3.3 分层

描绘复杂系统时，一采取分层次地描绘的方法
   第一步:建立高层次的系统流程图，描绘系统总体概貌，表明系统的关键功能。
   第二步:分别对每个关键功能进行扩展，到合适的详细程度，画在单独的一页纸上。
   第三步：可以多次扩展，直到描述完整。
优点：便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。

## 2.4 数据流图

 数据流图(DFD)是一种图形化技术，描述数据处理过程的工具。
 通过图形的方法，从数据传递和数据处理的角度，刻画数据流从输入到输出的移动变换过程。
数据流图的基本要点是描绘“做什么”，而不考虑“怎样做”。

#### 1.数据流

用箭头表示数据流，箭头方向表示数据流向，数据流名标在数据流线上面。 
数据流三个重要属性：

- 数据流名字
- 数据组成
- 流向

#### 2.加工

加工也称为数据处理，或称为变换，是对数据进行处理的单元。 

#### 3.数据存储

数据存储是由若干数据元素组成的，它为数据处理提供数据处理所需要的输入流或为数据处理的输出数据流提供储存“仓库”。 

#### 4.数据源点和终点

任何一个系统的边界定义后，就有系统内外之分，一个系统总会与系统外部的实体有联系。这种联系的重要形式就是数据。数据源点和终点是软件系统外部环境中的实体（包括人员、组织或其他软件系统），统称外部实体

### 2.4.1 符号

![image-20220308145807356](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308145807.png)

![image-20220308145817757](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151100.png)

![image-20220308145823584](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151101.png)

**数据流图的层次结构**

- 于大型系统，往往采用自顶向下逐层分解的方法，用分层数据流图表示所有数据流和加工。
- 对任何一个数据流图来说，它的上层图为父图，在它的下一层的图为子图。
- 在多层数据流图中，顶层流图仅包含一个数据处理，它代表被开发系统。它的输入流是该系统的输入数据，输出流是系统所输出数据
- 底层流图是指其数据处理不需再做分解的数据流图，它处在最底层
- 中间层流图则表示对其上层父图的细化。它的每一数据处理可能继续细化，形成子图。

![image-20220308145845330](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308145845.png)

### 2.4.2  例子

假设一家工厂的采购部每天需要一张订货报表，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据：零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为事务，通过放在仓库中的CRT终端把事务报告给订货系统。当某种零件的库存数量少于库存量临界值时就应该再次订货。

第一步可以从问题描述中提取数据流图的4种成分： 

首先考虑数据的源点和终点，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的CRT终端把事务报告给订货系统”，所以采购员是数据终点，而仓库管理员是数据源点。

第二步：再一次阅读问题描述，“采购部需要报表”

因此必须有一个用于产生报表的处理。事务的后果是改变零件库存量，然而任何改变数据的操作都是处理，因此对事务进行的加工是另一个处理。注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。

第三步：考虑数据流和数据存储

系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配——每当有一个事务发生时立即处理它，然而每天只产生一次订货报表。因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储。

步骤一：

![image-20220308145938057](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308145938.png)

步骤二：

​    任何系统的基本模型都由若干个数据源点/终点以及一个处理组成，这个处理就代表了系统对数据加工变换的基本功能 

![image-20220308150025675](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308150025.png)

步骤三：

把基本系统模型细化，描绘系统的主要功能

![image-20220308150036065](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308150036.png)

步骤四：

对功能级数据流图中描绘的系统主要功能进一步细化

![image-20220308150055850](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308150055.png)

**数据流图绘制的主要步骤**

① 确定所开发的系统的外部项(外部实体)，即系统的数据来源和去处。
② 确定整个系统的输出数据流和输入数据流，把系统作为一个加工环节，画出顶层图关联图。
③ 确定系统的主要处理功能，按此将整个系统分解成几个加工环节(子系统)。确定每个加工的输出与输入数据流以及与这些加工有关的数据存储。将外部项，各加工，数据存储环节用数据流连接起来，命名、编号，这样就形成所开发系统的数据流图 (总图)的草图。
④分解数据流图草图
⑤ 重复步骤，直到逐层分解结束。

⑥ 对草图进行检查和合理布局，对错误与不当之处进行修改。
⑦ 和用户进行交流，在用户完全理解数据图的内容的基础上征求用户的意见．和用户讨论，系统分析人员根据与用户讨论的结果对数据流图的草图进行修订。
⑧ 用计算机或其他制图、编辑工具画出正规的数据流图。
⑨ 将正规的数据流图提交系统分析负责人复审。若有修改之处，则组织人员修改，否则，通过复审，数据流图绘制过程结束。

**实例考务处理系统的功能**

(1) 对考生送来的报名单进行检查;

(2) 对合格的报名单编好准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站;

(3) 对阅卷站送来的成绩单进行检查，并根据考试中心制定的合格标准审定合格者;

(4) 制作考生通知单 (含成绩及合格/不合格标志) 送给考生;

(5) 按地区进行成绩分类统计和试题难度分析，产生统计分析表。

![image-20220308211737860](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308211745.png)

- 根据考务处理业务，画出顶层数据流图，以反映最主要业务处理流程及系统与外界的关系。
- 经过分析，考务业务处理的主要功能应当有登记报名单、统计成绩两个主要数据流。输入的源点和输出终点是考生、考试中心和阅卷站。
- 然后从输入端开始，根据考务业务工作流，画出数据流流经的各加工框，逐步画到输出端，得到第 0 层数据流图。



![image-20220308211917962](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308211918.png)

![image-20220308211924055](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308211924.png)

![image-20220308211931079](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308211931.png)

练习1：请根据以下描述画出某简化的工资管理系统的数据流图。该子系统共有三个加工，其数据处理过程是：(1)首先是“填制工资档案”：根据人事变动单、考勤表两个输入单据，经过处理输出形成工资文件；(2)然后是“汇总工资”：从工资文件输入数据，按部门汇总后形成工资汇总表文件，(3)最后“发放工资”加工单元从工资卡片文件打印出工资条。

![image-20220308211954100](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308211954.png)

练习2：某银行储蓄所存(取)款过程如下：
    储户将填好的存(取)单及存折送交分类处理处。分类处理处按三种不同情况分别处理。如果存折不符或存(取)单不合格，则将存折及存(取)单直接退还储户重新填写；如果是存款，则将存折及存款单送交存款处处理。存款处理处取出底账登记后，将存折退还给储户；如果是取款，则将存折及取款单送交取款处理处，该服务台取出底账及现金，记账后将存折与现金退给储户。从而完成存(取)款处理过程。试按此画出数据流程图。

![image-20220308212011577](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212011.png)

 练习3：学籍管理包括三个处理过程：“学生成绩管理”，“学生奖惩管理”，“学生异动管理”。由“异动管理”处理招生办送来的新生名单，同时在学籍表中记载新生注册信息，并定期输出各种统计报表送教委，也要负责向用人单位提供毕业生信息。“成绩管理”处理由教师送来的成绩单，并在学籍表中记载学生成绩，同时每年年底要对学籍表中的学生成绩汇总分析，按照学校的有关规定打印出应该留学退学的学生名单和奖学金候选人名单，分别交“异动管理” 和“奖惩管理”处理过程处理。“奖惩管理”处理过程根据奖学金候选人名单及其所在系提供的相应思想品德情况报告得出最终获得奖学金人员名单，并在学籍表中记载下来。

![image-20220308212052896](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212052.png)

**画数据流图注意事项**

在软件的系统分析之前，系统的技术负责要制订一个系统的标准。其内容之一就是画数据流图的规范。画数据流图要注意以下几点：
（1）命名：在画数据流图中，不论数据流、数据存储还是加工的命名要合适，要易于理解其含义。
（2）在画数据流图时要注意不要画控制流。   

![image-20220308212247740](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212247.png)

（3）每个加工至少有一个输入数据流和一个输出数据流，反映出此加工数据的来源与加工的结果。
        数据流必须要么从某个加工流出、要么流入某个加工，而不能直接从外部项流向数据存储等等。

**几种错误(1)**

![image-20220308212358379](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212358.png)

**几种错误(2)**

![image-20220308212604562](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212604.png)

（4）加工点的编号：如果一张数据流图中的某个加工点要分解成另一张数据流图时，则上层图为父图，直接下层图为子图，父、子图上的所有加工都应编号。
      父项与子项的编号要体现数据流图分解的完整性与一致性的原则，如父项编号为 F1或D1，则其子项分别为F1.1，F1.2，…，或D1.1，D1.2，…等。

**父图与子图的编号** 

![image-20220308212704285](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212704.png)

（5）系统分析中要区别物流和数据流。
（6）在数据流图表示系统的数据流向时，一般都要用到父图与子图来描述不同的层次。要注意父图与子图的平衡 

**父图与子图的平衡** 

![image-20220308212735342](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212735.png)

**父图-子图平衡补充说明**

![image-20220308212821753](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212821.png)

**父图与子图不平衡**

![image-20220308212832385](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212832.png)

（7）在分层处理的过程中，当某层数据流图中的数据存储不是父图中相应加工的外部接口，而只是本图中某些加工之间的数据接口，则称这些数据存储为局部数据存储。
（8）数据流图作为以后设计和与用户交流的基础，其易理解性极为重要。 

**局部数据存储的使用**

![image-20220308212855093](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308212855.png)



### 2.4.4  用途

![image-20220308213029293](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213029.png)

![image-20220308213040049](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213040.png)



## 2.5 数据字典

**概念**

   **数据字典**（DD） ：是对数据流图中包含的所有元素的定义的集合，使得每个图形元素的名字都有一个精确的、严格的定义。
   其作用是为系统人员在系统分析、系统设计和系统维护过程中提供关于数据的描述信息。
   数据流图和数据字典共同构成系统的逻辑模型，共同构成系统的规格说明。

### 2.5.1 内容

一般说来，数据字典应该由对下列4类元素的定义组成。

![image-20220308213143614](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213143.png)

词条描述——对于在模型中每一个被命名的图形元素，均加以定义，其内容有:   名字，别名或编号，分类，描述，定义，位置，其它，等

（1）数据流词条描述
数据流名：
说明：简要介绍它产生的原因和结果
数据流来源：来自何方
数据流去向：去向何处
数据流组成：数据结构
数据量流通量：数据量，流通量

（2）数据元素词条描述
类型：数字(离散值，连续值)，文字(编码类型)长度
取值范围：
相关的数据元素及数据结构：
（3）数据文件词条描述
数据文件名：
简述：存放的是什么数据
输入／输出数据：
数据文件组成：数据结构
存储方式：顺序，直接，关键码
存取频率：

（4）加工逻辑词条描述
加工名：
加工编号：反映该加工的层次
简要描述：加工逻辑及功能简述
输入／输出数据流：
加工逻辑：简述加工程序，加工顺序
（5）数据源及数据池词条描述
 名称：外部实体名
 简要描述：什么外部实体
 有关数据流：
 数目：

### 2.5.2 定义数据的方法

由数据元素组成数据的方式只有下述3种基本类型：

- 顺序即以确定次序连接两个或多个分量。
- 选择即从两个或多个可能的元素中选取一个。
- 重复即把指定的分量重复零次或多次。

![image-20220308213531199](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213630.png)

![image-20220308213645501](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213645.png)

**课堂练习**

某旅馆的电话服务如下：
可以拨分机号和外线号码。分机号是从7201至7299。外线号码先拨9，然后是市话号码或长话号码。长话号码是以区号和市话号码组成。区号是从100到300中任意的数字串。市话号码是以局号和分局号组成。局号可以是455,466,888，552中任意一个号码。分局号是任意长度为4的数字串。
用2.5.2小节讲述的定义数据的方法，定义上述的电话号码。

**练习解答**

电话号码=[分机号｜外线号码]
分机号=7201...7299
外线号码=9+［市话号码｜长话号码］
长话号码=区号+市话号码
区号=100...300
市话号码=局号+分局号
局号=［455｜466｜888｜552］
分局号=4{数字}4

### 2.5.3  数据字典的用途

- 数据字典最重要的用途是作为分析阶段的工具
- 数据字典中包含的每个数据元素的控制信息是很有价值的
- 数据字典是开发数据库的第一步，而且是很有价值的一步。

### 2.5.4  数据字典的实现

目前，数据字典几乎总是作为CASE“结构化分析与设计工具”的一部分实现的。在开发大型软件系统的过程中，数据字典的规模和复杂程度迅速增加，人工维护数据字典几乎是不可能的。

在开发小型软件系统时暂时没有数据字典处理程序，建议采用卡片形式书写数据字典，每张卡片上保存描述一个数据的信息。
下面给出第2.4节的例子中几个数据元素的数据字典卡片，以具体说明数据字典卡片中上述几项内容的含义。

数据词典数据流举例

![image-20220308213920944](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213921.png)

![image-20220308213928455](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213928.png)

![image-20220308213939298](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213939.png)

![image-20220308213943586](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213943.png)

![image-20220308213950232](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213950.png)

![image-20220308213954981](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308213955.png)

**基本加工逻辑说明**

对数据流图的每一个基本加工，必须有一个基本加工逻辑说明。
基本加工逻辑说明必须描述基本加工如何把输入数据流变换为输出数据流的加工规则。
加工逻辑说明必须描述实现加工的策略而不是实现加工的细节。
加工逻辑说明中包含的信息应是充足的，完备的，有用的，无冗余的。
描述加工逻辑说明的工具：结构化语言、决策表、决策树。

结构化语言是一种伪码，它的词汇表由
命令动词
数据字典中定义的名字
有限的自定义词
逻辑关系词 IF_THEN_ELSE、SWITCH、WHILE_DO、FOR、DO_WHILE等组成。
它是一种介于自然语言和形式化语言之间的语言。用以消除在语法上的歧义性。

语言的正文用基本控制结构进行分割，加工中的操作用自然语言短语来表示。
其基本控制结构有三种：
简单陈述句结构：避免复合语句；
重复结构：while_do、for_do或do_while结构。
判定结构：if_then_else 或switch_do 结构；
用结构化语言描述的规格说明的正文可以在计算机上编辑，不必过多地考虑语言的在语法上的限制，使得分析员可以集中考虑加工的策略或规则。

**商店业务处理系统中“检查发货单”**

```pascal
if 发货单金额超过$500 then
      if 欠款超过了60天 then
              在偿还欠款前不予批准
      else （欠款未超期）
              发批准书，发货单      
else （发货单金额未超过$500）
      if 欠款超过60天 then
              发批准书，发货单及赊欠报告
      else （欠款未超期）
              发批准书，发货单      
```

**(2) 决策表**

如果数据流图的加工需要依赖于多个逻辑条件的取值，使用决策表来描述比较合适。

![image-20220308214124986](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214125.png)

**以“检查发货单”为例**

![image-20220308214155046](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214155.png)

**(3) 判定树**

判定树也是用来表达加工逻辑的一种工具。有时侯它比判定表更直观。

![image-20220308214217459](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214217.png)

**数据字典的实现** 

数据字典除了概念和技术上的问题外，工作量是非常大的。由于是系统的一项基础工作，所以数据字典的实现因环境的不同而采用不同的实现方法。早期人们用手工建立数据字典，现在一般是利用计算机辅助建立并维护数据字典。
１．手工编写．

> 数据词典可用一叠卡片来构造,其建立方法如下：
> 1）按软件开发规范规定的格式、印制数据流、文件和数据项的词典条目卡片
> 2)为数据流图的所有成分,分别填写相应的卡片。
> 3)条目按图号排序存放,同一图号的所有条目按数据流、数据项、文件和加工的先后次序分别存放。
> 4）同一图号中的同一类卡片。（如数据流卡片）则按名称作为关键字顺序存放。
> 5)同一成分在父图与子图中均出现时,则只在父图上定义。
> 6)要建立索引目录。

２．计算机辅助编写是指在计算机辅助绘制数据流图的同时，随着数据流图的逐层分解，计算机系统生成数据词典的某些条目，人工进行修改与补充。

> 手工方式建立的数据词典难于使用,更不易维护,一致性才完整性和正确性均难以保证。因此一般均倾向于自动或半自动实现数据词典。
> 全自动方式是开发一个"词典管理程序"来自动负责数据词典(包括由每个基本加工的小说明所构成的一组小说明)生成、使用和维护工作。
> 一个词典管理程序应具有以下功能:
> 1)按软件开发规范所规定的数据词典条目的格式,作为其一组语法。
> 2)用上述的格式,编制语法制导的输入编辑程序,以接受词典条目的输入。
> 3)具有对词典条目进行插入、删除和修改的功能
>
> 4)具有一定的一致性、完整性的检查能力
> 5)能产生所需的各类查询报告和清单等。例如:
> ①将所有的元素按数据流、文件、数据项和加工的名称，按字母顺序分类列表。
> ②列出与某一类项目有关的所有元素。如列出与某加工有关的数据流、数据项等。

最后利用已有的数据库开发工具，针对数据字典建立一个数据库文件，可将数据流、数据项、数据存储和加工分别以矩阵表的形式来描述各个表项的内容，如数据流的矩阵表为：

![image-20220308214320614](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214320.png)

然后使用开发工具建成数据文件，便于修改、查询，并可随时打印出来。另外，有的DBMS本身包含一个数据字典子系统，建库时能自动生成数据字典。
目前一些软件开发小组都习惯于用计算机中小的数据库软件作为数据字典的实现工具。最方便的可以用微软的Access和Excel。计算机辅助开发数据字典比手工建立数据字典有更多的优点，能保证数据的一致性和完整性，使用也方便。
而半自动方式则是利用正文编辑程序和报表生成程序等已有的软件工具来帮助人工编制数据字典。

## 2.6 成本/效益分析

经济可行性 成本–效益分析
成本–效益分析是影响系统开发决策的一个重要因素。依据是：获得效益必须等于或大于建议系统的开发与运营成本。

![image-20220308214412337](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214412.png)

### 2.6.1  成本估计

软件开发成本主要表现为人力消耗(乘以平均工资则得到开发费用)。成本估计不是精确的科学，因此应该使用几种不同的估计技术以便相互校验。
下面简单介绍3种估算技术。

1. 代码行技术
2. 任务分解技术
3. 自动估计成本技术

1.代码行技术
把开发每个软件功能的成本和实现这个功能需要用的源代码行数联系起来。通常根据经验和历史数据估计实现一个功能需要的源程序行数。
估计出源代码行数以后，用每行代码的平均成本乘以行数就可以确定软件的成本。每行代码的平均成本主要取决于软件的复杂程度和工资水平。

2.任务分解技术
任务分解技术最常用的办法是按开发阶段划分任务。再分别估计每个单独的开发任务的成本，最后累加起来得出软件开发工程的总成本。典型环境下各个开发阶段需要使用的人力的百分比大致如下表所示:

![image-20220308214502027](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214502.png)

3.自动估计成本技术
采用自动估计成本的软件工具可以减轻人的劳动，并且使得估计的结果更客观。但是，采用这种技术必须有长期搜集的大量历史数据为基础，并且需要有良好的数据库系统支持。

### 2.6.2  成本/效益分析的方法

成本/效益分析方法主要从四个方面考虑

- 货币的时间价值
- 投资回收期
- 纯收入
- 投资回收率

1. 货币的时间价值

![image-20220308214545616](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214545.png)

 例如，修改一个已有的库存清单系统，使它能在每天送给采购员一份订货报表。修改已有的库存清单程序并且编写产生报表的程序，估计共需5000元；系统修改后能及时订货，这将消除零件短缺问题，估计因此每年可以节省2500元，5年共可节省12500元。但是，不能简单地把5000元和12500元相比较，因为前者是现在投资的钱，后者是若干年以后节省的钱。

 假定年利率为12%，利用上面计算货币现在价值的公式可以算出修改库存清单系统后每年预计节省的钱的现在价值，如下表所示。

![image-20220308214612945](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214613.png)

2. 投资回收期

![image-20220308214629953](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214630.png)

3. 纯收入

![image-20220308214656914](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214656.png)

4. 投资回收率

![image-20220308214719907](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214719.png)

![image-20220308214740409](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214740.png)

![image-20220308214749520](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220308214749.png)



## 作业

银行计算机储蓄系统的工作过程大致如下：储户填写的存款单或取款单由业务员键入系统，如果是存款则系统记录存款人姓名、住址(或电话号码)、身份证号码、存款类型、存款日期、到期日期、利率及密码(可选)等信息，并印出存单给储户；如果是取款而且存款时留有密码，则系统首先核对储户密码，若密码正确或存款时未留密码，则系统计算利息并印出利息清单给储户。

请用数据流图分层描绘本系统的功能，并用实体-联系图描绘系统中的数据对象。

 

注意：图要求拍照上传（上传要求见本系统提交作业说明）

> 

# 第3章需求分析

为了开发出真正满足用户需求的软件产品，首先必须知道用户的需求。对软件需求的深入理解是软件开发工作获得成功的前提条件，不论人们把设计和编码工作做得如何出色，不能真正满足用户需求的程序只会令用户失望，给开发者带来烦恼。

尽管目前有许多不同的用于需求分析的结构化分析方法，但是，所有这些分析方法都遵守下述准则。

- 必须理解并描述问题的信息域，根据这条准则应该建立数据模型。

- 必须定义软件应完成的功能，这条准则要求建立功能模型。
- 必须描述作为外部事件结果的软件行为，这条准则要求建立行为模型
- 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。

## 3.1需求分析的任务

虽然功能需求是对软件系统的一项基本需求，但却并不是唯一的需求。通常对软件系统有下述几方面的综合要求。

- 功能需求
  - 这方面的需求指定系统必须提供的服务。通过需求分析应该划分出系统必须完成的所有功能
- 性能需求
  - 性能需求指定系统必须满足的定时约束或容量约束，通常包括速度(响应时间)、信息量速率、主存容量、磁盘容量、安全性等方面的需求。
- 可靠性和可用性需求
  - 可靠性需求定量地指定系统的可靠性，可用性与可靠性密切相关，它量化了用户可以使用系统的程度。
- 出错处理需求
  - 这类需求说明系统对环境错误应该怎样响应。例如，如果它接收到从另一个系统发来的违反协议格式的消息，应该做什么?注意，上述这类错误并不是由该应用系统本身造成的。
- 接口需求
  - 接口需求描述应用系统与它的环境通信的格式。常见的接口需求有：用户接口需求；硬件接口需求；软件接口需求；通信接口需求。
- 约束
  - 设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件。常见的约束有：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台。
- 逆向需求
  - 逆向需求说明软件系统不应该做什么。理论上有无限多个逆向需求，人们应该仅选取能澄清真实需求且可消除可能发生的误解的那些逆向需求。
- 将来可能提出的要求
  - 应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。这样做的目的是，在设计过程中对系统将来可能的扩充和修改预做准备，以便一旦确实需要时能比较容易地进行这种扩充和修改。

### 3.1.2分析系统的数据要求

任何一个软件系统本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响，因此，必须分析系统的数据要求，这是软件需求分析的一个重要任务。

复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观。为了提高可理解性，常常利用图形工具辅助描绘数据结构。

### 3.1.3导出系统的逻辑模型

综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用数据流图、实体联系图、状态转换图、数据字典和主要的处理算法描述这个逻辑模型。

### 3.1.4  修正系统开发计划

根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。

## 3.2 与用户沟通获取需求的方法

### 3.2.1 访谈

访谈是最早开始使用的获取用户需求的技术，也是迄今为止仍然广泛使用的需求分析技术。访谈有两种基本形式，分别是正式的和非正式的访谈。

正式访谈时，系统分析员将提出一些事先准备好的具体问题，例如，询问客户公司销售的商品种类、雇用的销售人员数目以及信息反馈时间应该多快等。在非正式访谈中，分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法，例如，询问用户对目前正在使用的系统有哪些不满意的地方。

访谈有两种基本形式，分别是正式的和非正式的访谈。正式访谈时，系统分析员将提出一些事先准备好的具体问题，非正式访谈中，分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法

在访问用户的过程中使用情景分析技术往往非常有效。所谓情景分析就是对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。

情景分析技术的用处主要体现在下述两个方面。

- 它能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。
- 由于情景分析较易为用户所理解，使用这种技术能保证用户在需求分析过程中始终扮演一个积极主动的角色。

### 3.2.2 面向数据流自顶向下求精

结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法。通过可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。
为了达到这个目标，通常从数据流图的输出端着手分析，这是因为系统的基本功能是产生这些输出，输出数据决定了系统必须具有的最基本的组成元素。

数据流图是帮助复查的极好工具，从输入端开始，分析员借助数据流图、数据字典和IPO图向用户解释输入数据是怎样一步一步地转变成输出数据的。这些解释集中反映了通过前面的分析工作分析员所获得的对目标系统的认识。

随着分析过程的进展，经过提问和解答的反复循环，分析员越来越深入具体地定义了目标系统，最终得到对系统数据和功能要求的满意了解。

![image-20220316212849229](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316212849.png)



### 3.2.3 简易的应用规格说明技术

简易的应用规格说明技术是为了解决使用传统的访谈或面向数据流自顶向下求精方法定义需求时，用户处于被动地位而且往往有意无意地与开发者区分“彼此”。由于不能像同一个团队的人那样齐心协力地识别和精化需求，这两种方法的效果有时并不理想的问题，提出的。

简易的应用规格说明技术分析需求的典型过程如下

- 进行初步的访谈
- 开发者和用户分别写出“产品需求”。
- 开会讨论，各自展示需求列表
- 得出了意见一致，为需求列表制定小型规格说明
- 根据会议结果，起草完整的软件需求规格说明

### 3.2.4  快速建立软件原型

为了快速地构建和修改原型，通常使用下述3种方法和工具。

- 第四代技术
- 可重用的软件构件
- 形式化规格说明和原型环境

快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序，快速原型应该具备的特性：

- 快速原型应该具备的第一个特性是“快速”。
- 快速原型应该具备的第二个特性是“容易修改”。

## 3.3 分析建模与规格说明

### 3.3.1 分析建模

模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。

为了开发复杂的系统，应从不同角度（模型）抽象出目标系统的特性（数据模型、功能模型、行为模型）

- 实体联系图，描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。
- 数据流图是建立功能模型的基础。
- 状态转换图描绘了系统的各种行为模式和在不同状态间转换的方式。

### 3.3.2 软件需求规格说明

<u>软件需求规格说明是需求分析阶段得出的最主要的文档。</u>

通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。

## 3.4 实体联系图

数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系。

### 3.4.1 数据对象

<u>数据对象是对软件必须理解的复合信息的抽象。</u>

数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。总之，可以由一组属性来定义的实体都可以被认为是数据对象。

### 3.4.2 属性

**属性定义了数据对象的性质**。
必须把一个或多个属性定义为“标识符”，也就是说，当人们希望找到数据对象的一个实例时，用标识符属性作为“关键字”(通常简称为“键”)。

### 3.4.3 联系

**客观世界中的事物彼此间往往是有联系的**。
数据对象彼此之间相互连接的方式称为联系，也称为关系。联系可分为以下3种类型。

- 一对一联系(1∶1)
  - 例如，一个部门有一个经理，而每个经理只在一个部门任职，则部门与经理的联系是一对一的。
- 一对多联系(1∶N)
  - 例如，某校教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教(见图3.2)。
- 多对多联系(M∶N)
  - 例如，图3.2表示学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。

![image-20220316213431593](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213431.png)

### 3.4.4 实体联系图的符号

通常，使用实体联系图(entityrelationship diagram)来建立数据模型。可以把实体联系图简称为ER图，相应地可把用ER图描绘的数据模型称为ER模型。

ER图中包含了实体(即数据对象)、关系和属性3种基本成分，通常用矩形框代表实体，用连接相关实体的菱形框表示关系，用椭圆形或圆角矩形表示实体(或关系)的属性，并用直线把实体(或关系)与其属性连接起来。

ER模型可以作为用户与分析员之间有效的交流工具。

## 3.5 数据规范化

软件系统经常使用各种长期保存的信息，这些信息通常以一定方式组织并存储在数据库或文件中，为减少数据冗余，避免出现插入异常或删除异常，简化修改数据的过程，通常需要把数据结构规范化。

通常用“范式(normal forms)”定义消除数据冗余的程度。

![image-20220316213523747](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213523.png)



## 3.6状态转换图

<u>状态转换图(简称为状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作。</u>

### 3.6.1 状态

<u>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</u>

在状态图中定义的状态主要有：初态(即初始状态)、终态(即最终状态)和中间状态。在一张状态图中只能有一个初态，而终态则可以有0至多个。

状态图既可以表示系统循环运行过程，也可以表示系统单程生命期。

### 3.6.2 事件

事件是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。

事件就是引起系统做动作或(和)转换状态的控制信息。

### 3.6.3 符号

在状态图中，初态用实心圆表示，终态用一对同心圆(内圆为实心圆)表示。
中间状态用圆角矩形表示，可以用两条水平横线把它分成上、中、下3个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，这部分是可选的；下面部分是活动表，1这部分也是可选的。



**活动表的语法格式如下：**
**事件名(参数表)/动作表达式其中，“事件名”可以是任何事件的名称。**
在活动表中经常使用下述3种标准事件：entry, exit和do。

- <u>entry事件指定进入该状态的动作</u>
- <u>exit事件指定退出该状态的动作</u>
- <u>do事件则指定在该状态下的动作</u>

需要时可以为事件指定参数表。活动表中的动作表达式描述应做的具体动作。



**状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。**

状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。
**事件表达式的语法如下：**
**事件说明［守卫条件］／动作表达式其中，事件说明的语法为：事件名(参数表)。**



**状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向**。状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。
**事件表达式的语法如下：**
**事件说明［守卫条件］／动作表达式其中，事件说明的语法为：事件名(参数表)。**

![image-20220316213640635](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213640.png)

### 3.6.4 例子

为了具体说明怎样用状态图建立系统的行为模型，下面举一个例子
下图是人们非常熟悉的电话系统的状态图。

<img src="https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151102.png" alt="image-20220322110313697" style="zoom:50%;" />

## 3.7其他图形工具

描述复杂的事物时，图形远比文字叙述优越得多，它形象直观容易理解。前面已经介绍了用于建立功能模型的数据流图、用于建立数据模型的实体联系图和用于建立行为模型的状态图，本节再简要地介绍在需求分析阶段可能用到的另外3种图形工具。

### 3.7.1 层次方框图

<u>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</u>

例如，描绘一家计算机公司全部产品的数据结构可以用下图3.5层次方框图表示。
这家公司的产品由硬件、软件和服务3类产品组成，软件产品又分为系统软件和应用软件，系统软件又进一步分为操作系统、编译程序和软件工具等。

![image-20220316213738418](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213738.png)

### 3.7.2 Warnier图

和层次方框图类似，Warnier图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。

用Warnier图可以表明信息的逻辑组织，也就是说，它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的。

**异或含义:** **一个软件不能既是系统软件又是应用软件**

![image-20220316213756527](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213756.png)

### 3.7.3 IPO图

IPO图是输入、处理、输出图的简称，它是由美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。

下图3.7是主文件更新的例子，通过这个例子不难了解IPO图的用法

![image-20220316213814920](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220316213814.png)



![image-20220322112107252](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220322112107.png)

## 3.8 验证软件需求

### 3.8.1 从哪些方面验证软件需求的正确性

需求分析阶段的工作结果是开发软件系统的重要基础，大量统计数字表明，软件系统中15%的错误起源于错误的需求。

为了提高软件质量，确保软件开发成功，降低软件开发成本，一旦对目标系统提出一组要求之后，必须严格验证这些需求的正确性。一般说来，应该从下述4个方面进行验证。

- 一致性所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
- 完整性需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。
- 现实性指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。
- 有效性必须证明需求是正确有效的，确实能解决用户面对的问题。

### 3.8.2 验证软件需求的方法

上一小节已经指出，至少必须从一致性、完整性、现实性和有效性这4个不同角度验证软件需求的正确性。那么，怎样验证软件需求的正确性呢?验证的角度不同，验证的方法也不同。

- **验证需求的一致性**
  - 当需求分析的结果是用自然语言书写的时候，除了靠人工技术审查验证软件系统规格说明书的正确性之外，目前还没有其他更好的“测试”方法。但是，这种非形式化的规格说明书是难于验证的，特别在目标系统规模庞大、规格说明书篇幅很长的时候，人工审查的效果是没有保证的，冗余、遗漏和不一致等问题可能没被发现而继续保留下来，以致软件开发工作不能在正确的基础上顺利进行。
    为了克服上述困难，人们提出了形式化的描述软件需求的方法。
- **验证需求的现实性**
  - 为了验证需求的现实性，分析员应该参照以往开发类似系统的经验，分析用现有的软、硬件技术实现目标系统的可能性。必要的时候应该采用仿真或性能模拟技术，辅助分析软件需求规格说明书的现实性。
- **验证需求的完整性和有效性**
  - 只有目标系统的用户才真正知道软件需求规格说明书是否完整、准确地描述了他们的需求。因此，检验需求的完整性，特别是证明系统确实满足用户的实际需要，只有在用户的密切合作下才能完成。然而许多用户并不能清楚地认识到他们的需要(特别在要开发的系统是全新的，以前没有使用类似系统的经验时，情况更是如此)，不能有效地比较陈述需求的语句和实际需要的功能。只有当他们有某种工作着的软件系统可以实际使用和评价时，才能完整确切地提出他们的需要。

### 3.8.3 用于需求分析的软件工具

为了更有效地保证软件需求的正确性，特别是为了保证需求的一致性，需要有适当的软件工具支持需求分析工作。这类软件工具应该满足下列要求。

- **必须有形式化的语法(或表)，因此可以用计算机自动处理使用这种语法说明的内容。**
- **使用这个软件工具能够导出详细的文档。**
- **必须提供分析(测试)规格说明书的不一致性和冗余性的手段，并且应该能够产生一组报告指明对完整性分析的结果。**
- **使用这个软件工具之后，应该能够改进通信状况。**

PSL/PSA系统是CADSAT（计算机辅助设计和规格说明分析工具）的一部分。其中PSL是用来描述系统的形式语言，PSA是处理PSL描述的分析程序。

**PSL/PSA系统的功能主要有下述4种。**

- **描述任何应用领域的信息系统**。
- **创建一个数据库保存对该信息系统的描述符。**
- **对描述符施加增加、删除和更改等操作。**
- **产生格式化的文档和关于规格说明书的各种分析报告。**

# 5.总体设计

总体设计的基本目的就是回答“概括地说，系统应该如何实现”这个问题，因此，总体设计又称为概要设计或初步设计。
总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。

![image-20220324110006263](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324110006.png)

## 5.1 设计过程

![image-20220324105705505](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324105822.png)

### 典型的总体设计步骤

**1.** **设想供选择的方案**

在总体设计阶段分析员应该考虑各种可能的实现方案，并且力求从中选出最佳方案。

需求分析阶段得出的数据流图是总体设计的极好的出发点。

设想供选择的方案的一种常用的方法是，设想把数据流图中的处理分组的各种可能的方法，抛弃在技术上行不通的分组方法(例如，组内不同处理的执行时间不相容)，余下的分组方法代表可能的实现策略，并且可以启示供选择的物理系统。

**2.选取合理的方案**

应该从前一步得到的一系列供选择的方案中选取若干个合理的方案，通常至少选取低成本、中等成本和高成本的3种方案。在判断哪些方案合理时应该考虑在问题定义和可行性研究阶段确定的工程规模和目标，有时可能还需要进一步征求用户的意见。

对每个合理的方案，分析员都应该准备下列4份资料。

(1) 系统流程图。

(2) 组成系统的物理元素清单。

(3) 成本/效益分析。

(4) 实现这个系统的进度计划。

**3.推荐最佳方案**

用户和有关的技术专家应该认真审查分析员所推荐的最佳系统，如果该系统确实符合用户的需要，并且是在现有条件下完全能够实现的，则应该提请使用部门负责人进一步审批。在使用部门的负责人也接受了分析员所推荐的方案之后，将进入总体设计过程的下一个重要阶段——**结构设计**。

**4.功能分解**

为了最终实现目标系统，必须设计出组成这个系统的所有程序和文件(或数据库)。对程序(特别是复杂的大型程序)的设计，通常分为两个阶段完成：首先进行结构设计，然后进行过程设计。

为确定软件结构，首先需要从实现角度把复杂的功能进一步分解。分析员结合算法描述仔细分析数据流图中的每个处理，如果一个处理的功能过分复杂，必须把它的功能适当地分解成一系列比较简单的功能。

**5. 设计软件结构**

通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统，顶层模块调用它的下层模块以实现程序的完整功能，每个下层模块再调用更下层的模块，完成程序的一个子功能，最下层的模块完成最具体的功能。

**6.** **设计数据库**

对于需要使用数据库的那些应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步设计数据库。

**7.****制定****测试计划**

在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。第7章具体讨论

**8.** **书写文档**

应该用正式的文档记录总体设计的结果，在这个阶段应该完成的文档通常有下述几种。

(1)**系统说明**

(2)**用户手册**

(3)**测试计划**包括测试策略，测试方案，预期的测试结果，测试进度计划等

(4)**详细的实现计划**

(5)**数据库设计结果**

**9.审查和复审**

最后应该对总体设计的结果进行严格的技术审查，在技术审查通过之后再由客户从管理角度进行复审。

![image-20220324110757922](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324110758.png)

## 5.2  设计原理

### 5.2.1 模块化

**模块**是由边界元素限定的相邻程序元素（例如，数据说明，可执行的语句）的序列，而且有一个总体标识符代表它。**模块**是构成程序的基本构件。

**模块化**就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。

#### 优点:

模块化是软件解决复杂问题所具备的手段，可**降低软件复杂性**，**减少开发工作量**，从而**降低开发成本**，**提高软件生产率**，是模块化的依据。

> 模块化是为了使一个复杂的大型程序能被人的智力所管理，是软件应该具备的唯一属性。下面论证上面结论。
>
> 设函数C(x)定义问题x的复杂程度，函数E(x)确定解决问题x需要的工作量(时间)。对于两个问题P1和P2，如果
>
> C(P1)>C(P2)
>
> 显然               E(P1)>E(P2)
>
> 根据人类解决一般问题的经验，另一个有趣的规律是
>
> C(P1+P2)>C(P1)+C(P2)
>
> 也就是说，如果一个问题由P1和P2两个问题组合而成，那么它的复杂程度大于分别考虑每个问题时的复杂程度之和。
>
> 综上所述，得到下面的不等式
>
> E(P1+P2)>E(P1)+E(P2)
>
> 这个不等式导致“各个击破”的结论——把复杂的问题分解成许多容易解决的小问题，原来的问题也就容易解决了。这就是模块化的根据。

#### 模块化与成本关系

由上面的不等式似乎还能得出下述结论：如果无限地分割软件，最后为了开发软件而需要的工作量也就小得可以忽略了。事实上，还有另一个因素在起作用，从而使得上述结论不能成立。

如图，当模块数目增加时每个模块的规模将减小，开发单个模块需要的成本(工作量)确实减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。根据这两个因素，得出了图中的总成本曲线。每个程序都相应地有一个最适当的模块数目M，使得系统的开发成本最小。

![image-20220324111439840](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324111440.png)

#### 模块的基本属性

没来得及截图

### 5.2.2 抽象

![image-20220324111533747](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324111533.png)

![image-20220324111848534](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324111848.png)

### 5.2.3 逐步求精

**逐步求精定义为为了能集中精力解决主要问题而尽量推迟对问题细节的考虑**。

逐步求精最初是由Niklaus Wirth提出的一种自顶向下的设计策略。按照这种设计策略，程序的体系结构是通过**逐步精化处理**过程的层次而设计出来的。通过逐步分解对功能的宏观陈述而开发出**层次结构**，直至最终得出用程序设计语言表达的程序。

- 求精实际上是细化过程。
- 抽象与求精是一对互补的概念。

![image-20220324112023041](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112023.png)

![image-20220324112051312](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112051.png)

### 5.2.4 信息隐藏和局部化

**信息隐藏原理**：应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。

**局部化**:是指把一些关系密切的软件元素物理地放得彼此靠近。
如果在测试期间和以后的软件维护期间需要修改软件，使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。

### 5.2.5 模块独立

![image-20220324112225587](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112225.png)

#### **耦合**

**耦合** 是对一个软件结构内不同模块之间互连程度的度量。耦合强弱取决于模块间<u>接口</u>的复杂程度，<u>进入或访问</u>一个模块的点，以及通过接口的<u>数据</u>。
模块耦合分为数据耦合、控制耦合、特征耦合、公共环境耦合和内容耦合

**设计目标:低耦合**

![image-20220324112411902](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112412.png)

![image-20220324112655314](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112655.png)

![image-20220324112711530](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112711.png)

![image-20220324112723261](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112723.png)

![image-20220324112813967](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324112814.png)

![image-20220324113402158](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113402.png)

![image-20220324113410074](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113410.png)

![image-20220324113500596](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113500.png)

![image-20220324113605521](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113605.png)

![image-20220324113633018](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113633.png)

![image-20220324113712939](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113713.png)

![image-20220324113731834](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113732.png)

![image-20220324113823005](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113823.png)

![image-20220324113903502](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113903.png)

![image-20220324113933417](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324113933.png)

#### **内聚性**

![image-20220324114144446](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114144.png)

![image-20220324114223299](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114223.png)

![image-20220324114300568](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114300.png)

![image-20220324114424045](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114424.png)

![image-20220324114504935](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114505.png)

![image-20220324114529679](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114529.png)

![image-20220324114611801](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114611.png)

![image-20220324114709270](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114709.png)

#### 总结

![image-20220324114726788](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324114726.png)

## 5.3  启发规则

**1.改进软件结构提高模块独立性**

设计出软件的初步结构以后，应该审查分析这个结构，通过模块分解或合并，力求降低耦合提高内聚。

**2.模块规模应该适中**

一个模块的规模不应过大，最好能写在一页纸内(通常不超过60行语句)

**3.深度、宽度、扇出和扇入都应适当**

- 深度：软件结构中控制的层数
- 宽度：软件结构内同一个层次上的模块总数的最大值
- 扇出：一个模块直接控制(调用)的模块数目
- 扇入：一个模块被多少个上级模块直接调用的数目

![image-20220324115017110](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324115017.png)

**4.模块的作用域应该在控制域之内**

**作用域**：受该模块内一个判定影响的所有模块的集合。

**控制域**：模块本身以及所有直接或间接从属于它的模块的集合。

![image-20220324115121088](https://gitee.com/yonaspigeon/giteepicstore/raw/master/master/20220324115121.png)

在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块及它的直属下级模块

<u>怎样修改软件结构才能使作用域是控制域的子集呢?</u>

- 方法1是把做判定的点往上移（例如，把判定从模块C中移到模块X中）
- 方法2是把那些在作用域内但不在控制域内的模块移到控制域内（例如，把模块L移到模块C的下面，成为它的直属下级模块。）

**5.力争降低模块接口的复杂程度**

模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。
如：QUAD_ROOT(TBL,X)
求一元二次方程的根的模块，其中用数组TBL传送方程的系数，用数组X回送求得的根。
使用接口可能是比较简单，如：
**QUAD_ROOT(A,B,C,ROOT1,ROOT2)**
其中A、B、C是方程的系数，ROOT1和ROOT2是算出的两个根。

**6.设计单入口单出口的模块**

这条启发式规则警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。

**7.模块功能应该可以预测**

模块的功能应该能够预测，但也要防止模块功能过分局限。

## 5.4  描绘软件结构的图形工具

### 5.4.1 层次图和HIPO图(不带箭头)

层次图用来描绘软件的层次结构。数据结构的层次方框图相同，但是表现的内容却完全不同。层次图很适于在自顶向下设计软件的过程中使用。

![image-20220329104259465](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151103.png)

HIPO图是美国IBM公司发明的“层次图加输入/处理/输出图”的英文缩写。为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。

![image-20220329104323192](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151104.png)

### 5.4.2 (软件)结构图

Yourdon提出的结构图是进行软件结构设计的工具。

- 图中一个方框代表一个模块
- 框内注明模块的名字或主要功能
- 方框之间的箭头(或直线)表示模块的调用关系
- 尾部是<u>空心圆表示传递的是数据
- 实心圆表示传递的是控制信息。

![image-20220329105215312](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151105.png)

![image-20220329104346133](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151106.png)

一些附加的符号，可以表示模块的选择调用或循环调用。左图表示当模块M中某个判定为真时调用模块A，为假时调用模块B。右图表示模块M循环调用模块A、B和C。

![image-20220329104357199](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151107.png)

#### 数据传递

![image-20220329105249341](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151108.png)

## 5.5  面向数据流的设计方法

### 5.5.1 概念

面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法。信息流有下述两种类型。
1）变换流
信息沿输入通路进入系统，由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫作变换流。

![image-20220329110227658](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151109.png)

![image-20220329105422397](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151110.png)



2）事务流
数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类数据流应该划为一类特殊的数据流，称为事务流。图中的处理T称为事务中心，它完成下述任务。
(1)接收输入数据(输入数据又称为事务)。
(2) 分析每个事务以确定它的类型。
(3) 根据事务类型选取一条活动通路。

![image-20220329110420641](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151111.png)

![image-20220329105538040](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151112.png)

![image-20220329110432011](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151113.png)

3）设计过程

![image-20220329105625027](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151114.png)

### 5.5.2 变换分析

变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构。

#### 1.例子 ：汽车数字仪表板的设计

假设的仪表板将完成下述功能。
(1) 通过模数转换实现传感器和微处理机接口。
(2) 在发光二极管面板上显示数据。
(3) 指示每小时英里数(mph)，行驶的里程每加仑油行驶的英里数(mpg)等。
(4) 指示加速或减速。
(5) 超速警告：如果车速超过55英里/小时，则发出超速警告铃声。
在软件需求分析阶段应该对上述每条要求以及系统的其他特点进行全面的分析评价，建立必要的文档资料，特别是数据流图。

#### 2.设计步骤

第1步复查基本系统模型。
第2步复查并精化数据流图。
假设在需求分析阶段产生的数字仪表板系统的数据流图如图所示。

![image-20220329110206261](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151115.png)

第3步确定数据流图具有变换特性还是事务特性。
第4步确定输入流和输出流的边界，从而孤立出变换中心。

![image-20220329110328095](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151116.png)

第5步完成 “第一级分解”

软件结构代表对控制的自顶向下的分配，所谓分解就是分配控制的过程。对于变换流的情况，数据流图被映射成一个特殊的软件结构，这个结构控制输入、变换和输出等信息处理过程。

位于软件结构最顶层的控制模块**Cm**协调下述从属的控制功能。

- 输入信息处理控制模块**Ca**,协调对所有输入数据的接收。
- 变换中心控制模块**Ct**,管理对内部形式的数据的所有操作。
- 输出信息处理控制模块**Ce**，协调输出信息的产生过程。

![image-20220329111554517](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151117.png)

对于数字仪表板的例子，第一级分解得出的结构如图所示。每个控制模块的名字表明了为它所控制的那些模块的功能。

![image-20220329111606532](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329111606532.png)

第6步完成“第二级分解”



第二级分解就是把数据流图中的每个处理映射成软件结构中一个适当的模块。

完成第二级分解的方法是，从变换中心的边界开始逆着输入通路向外移动，把输入通路中每个处理映射成软件结构中**Ca**控制下的一个低层模块；然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块**Ce**控制的一个低层模块；最后把变换中心内的每个处理映射成受**Ct**控制的一个模块。

![image-20220329111717999](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329111717999.png)

![image-20220329111859489](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329111859489.png)

![image-20220329111938522](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329111938522.png)

第7步使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。

![image-20220329111951810](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151118.png)

#### 补充内容

![image-20220329112132867](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329112132867.png)

- 逻辑输入,输出:变换中心进去/出来的流

![image-20220329112412588](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329112412588.png)

![image-20220329112547960](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151119.png)

![image-20220329112632491](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220329151120.png)

![image-20220329112648069](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329112648069.png)

![image-20220329112759223](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329112759223.png)

![image-20220329113759484](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329113759484.png)

![image-20220329114028984](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329114028984.png)

> **答案:**
>
> ![image-20220329115051156](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329115051156.png)

![image-20220329115215009](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329115215009.png)

> **答案**
>
> ![image-20220329115835710](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/image-20220329115835710.png)

### 5.5.3事务分析

数据流具有明显的事务特点时采用事务分析方法。
事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。由事务流映射成的软件结构包括一个接收分支和一个发送分支。

![image-20220331104351471](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331104351.png)

![image-20220331105116386](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105116.png)

![image-20220331105133011](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105133.png)

![image-20220331105342930](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105343.png)

![image-20220331105432281](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105432.png)

![image-20220331105448797](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105449.png)

![image-20220331105648194](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105648.png)

![image-20220331105856221](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331105856.png)

![image-20220331110005822](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331110006.png)

![image-20220331110047808](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331110048.png)



![image-20220331110319901](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331110320.png)

### 5.5.4 设计优化

设计人员应该致力于开发能够满足所有功能和性能要求，而且按照设计原理和启发式设计规则衡量是值得接收的软件。
设计的早期阶段尽量对软件结构进行精化。
对时间起决定性作用的软件进行优化是合理的。
(1) 在不考虑时间因素的前提下开发并精化软件结构。
(2) 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程(算法)，以求提高效率。
(3) 使用高级程序设计语言编写程序。
(4) 在软件中孤立出那些大量占用处理机资源的模块。
(5) 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率。

## 本章小结

1.总体设计阶段主要由系统设计和结构设计两阶段组成。

2.进行软件结构设计时应该遵循的最主要的原理是模块独立原理。

3.在软件开发过程中既要充分重视和利用这些启发式规则，又要从实际情况出发避免生搬硬套。

4.层次图和**结构图**是描绘软件结构的常用工具。

5.用形式化的方法由数据流图映射出软件结构。

# 第6章  详细设计

根本目标：确定应该怎样具体地实现所要求的系统。

详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。

详细设计的结果基本上决定了最终的程序代码的质量。

![image-20220331111237528](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331111237.png)

![image-20220331111438500](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331111438.png)

## 6.1  结构程序设计

1965年结构程序设计的概念最早由E.W.Dijkstra提出：程序的质量与程序中所包含的GO TO 语句的数量成反比

1966年Bohm和Jacopini证明了只用“顺序”、“选择”和“循环”控制结构就能实现任何单入口单出口的程序。

![image-20220331111206807](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331111207.png)

实际上用顺序结构和循环结构(又称DO-WHILE结构)完全可以实现选择结构(又称IF-THEN-ELSE结构) ，因此，理论上最基本的控制结构只有两种。

1968年Dijkstra再次建议从一切高级语言中取消GO TO语句，只使用3种基本控制结构写程序。学界认识到不是简单地去掉GO TO 语句的问题，而是要创立一种新的程序设计思想、方法和风格。

1971年IBM公司在纽约时报信息库管理系统的设计中成功地使用了结构程序设计技术

1972年IBM公司的Mills进一步提出，程序应该只有一个入口和一个出口，补充了结构程序设计的规则。

### 什么是结构化程序

![image-20220331111946510](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331111946.png)

结构程序设计经典定义：如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。

结构程序设计更全面的定义：结构程序设计是尽可能少用GO TO语句的程序设计方法。最好仅在检测出错误时才使用GO TO语句，而且应该总是使用前向GO TO语句。

从理论上说只用上述3种基本控制结构就可以实现任何单入口单出口的程序，但是为了实际使用方便起见，常常还允许使用DO-UNTIL和DO-CASE两种控制结构

![image-20220331111839274](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331111839.png)

如果只允许使用**顺序、IF-THEN-ELSE型分支和DO-WHILE**型循环这3种基本控制结构，则称为**经典的结构程序设计**；

如果除了上述3种基本控制结构之外，还允许使用**DO-CASE**型多分支结构和DO-UNTIL型循环结构，则称为**扩展的结构程序设计**；

如果再允许使用**LEAVE(或BREAK)**结构，则称为**修正的结构程序设计**。

### 结构化程序设计原则

![image-20220331112243337](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331112243.png)

## 6.2 人机界面设计

![image-20220331112342539](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331112342.png)

### 用户界面应具备的特性

![image-20220331113319617](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331113320.png)

- **可使用性**
  - 使用简单,界面术语标准化,一致性;HELP功能;较快系统响应速度,较低系统开销;容错率
- **灵活性**
  - 满足不同用户的要求;制定修改界面;提供各类系统响应信息;软件系统应有的标准的界面
- **复杂性**
  - 在完成预定功能的前提下,用户界面越简单越好
- **可靠性**
  - 用户界面能保证用户正确可靠使用系统,保证有关程序和数据的安全性

### 6.2.1 设计问题

- 系统响应时间
- 用户帮助设施
- 出错信息处理
- 命令交互

#### 6.2.1.1系统响应时间

**系统响应时间指从用户完成某个控制动作(例如，按回车键或单击鼠标)，到软件给出预期的响应(输出信息或做动作)之间的这段时间。**

系统响应时间有两个重要属性，分别是长度和易变性。

- **长度**：时间过长，用户就会感到紧张，过短，加快用户操作节奏，可能会犯错误
- **易变性**：系统响应时间相对于平均响应时间的偏差即使系统响应时间较长，响应时间易变性低也有助于用户建立起稳定的工作节奏。

#### 6.2.1.2用户帮助设施

常见的帮助设施可分为集成的和附加的两类。

具体设计帮助设施时，必须解决下述的一系列问题。

1. 在用户与系统交互期间，是否在任何时候都能获得关于系统任何功能的帮助信息?
   - 有两种选择：提供部分功能的帮助信息和提供全部功能的帮助信息。
2. 用户怎样请求帮助?
   - 有3种选择：帮助菜单，特殊功能键和HELP命令。
3. 怎样显示帮助信息?
   - 有3种选择：在独立的窗口中，指出参考某个文档(不理想)和在屏幕固定位置显示简短提示。
4. 用户怎样返回到正常的交互方式中?
   - 有两种选择：屏幕上的返回按钮和功能键。
5. 怎样组织帮助信息?
   - 有3种选择：平面结构，信息的层次结构和超文本结构。

#### 6.2.1.3出错信息处理

出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”。一般说来，交互式系统给出的出错信息或警告信息，具有下述属性。

1. 用用户可以理解的术语描述问题。
2. 提供有助于从错误中恢复的建设性意见。指出错误可能导致哪些负面后果(例如，破坏数据文件)，以便用户检查是否出现了这些问题，并在确实出现
3. 问题时及时解决。
4. 伴随着听觉上或视觉上的提示
5. 不能带有指责色彩，不能责怪用户。

#### 6.2.1.4命令交互

许多高级用户仍然偏爱面向命令行的交互方式

在提供命令交互方式时，必须考虑下列设计问题。

1. 是否每个菜单选项都有对应的命令?
2. 采用何种命令形式?有3种选择：控制序列(例如，Ctrl+P)，功能键和输入命令。
3. 学习和记忆命令的难度有多大?忘记了命令怎么办?
4. 用户是否可以定制或缩写命令?

在越来越多的应用软件中，人机界面设计者都提供了“命令宏机制”。

在理想的情况下，所有应用软件都有一致的命令使用方法

### 6.2.2.设计过程 

![image-20220331114536410](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331114536.png)

#### 评价用户界面指标

1. 系统及其界面的**规格说明书的长度和复杂程度**，预示了用户学习使用该系统所需要的工作量。
2. 命令或动作的数量、命令的平均参数个数或动作中单个操作的个数，预示了系统的交互时间和总体效率。
3. 设计模型中包含的动作、命令和系统状态的数量，预示了用户学习使用该系统时需要记忆的内容的多少。
4. 界面风格、帮助设施和出错处理协议，预示了界面的复杂程度及用户接受该界面的程度。

### 6.2.3人机界面设计指南

#### 1.一般交互指南

**涉及信息显示、数据输入和系统整体控制**

1. 保持一致性。
2. 提供有意义的反馈。
3. 在执行有较大破坏性的动作之前要求用户确认。
4. 允许取消绝大多数操作。
5. 减少在两次操作之间必须记忆的信息量。
6. 提高对话、移动和思考的效率。
7. 允许犯错误。
8. 按功能对动作分类，并据此设计屏幕布局。
9. 提供对用户工作内容敏感的帮助设施
10. 用简单动词或动词短语作为命令名。

![image-20220331115050407](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331115050.png)

![image-20220331115127030](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331115127.png)

![image-20220331115142366](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331115142.png)

#### 2.信息显示指南

多种不同方式“显示”信息：用文字、图形和声音；按位置、移动和大小；使用颜色、分辨率和省略。

1. 只显示与当前工作内容有关的信息。
2. 不要用数据淹没用户，应该用便于用户迅速吸取信息的方式来表示数据。
3. 使用一致的标记、标准的缩写和可预知的颜色。
4. 允许用户保持可视化的语境。
5. 产生有意义的出错信息。
6. 使用大小写、缩进和文本分组以帮助理解。
7. 使用窗口分隔不同类型的信息。(8)使用“模拟”显示方式表示信息，以使信息更容易被用户提取。
8.  高效率地使用显示屏。

#### 3.数据输入界面

用户的大部分时间用在选择命令、输入数据和向系统提供输入。

1. 尽量减少用户的输入动作。
2. 保持信息显示和数据输入之间的一致性。
3. 允许用户自定义输入。
4. 交互应该是灵活的，并且可调整成用户最喜欢的输入方式。
5. 使在当前动作语境中不适用的命令不起作用。
6. 让用户控制交互流。
7. 对所有输入动作都提供帮助。
8. 消除冗余的输入。
9. 高效率地使用显示屏。

## 6.3 过程设计的工具

### 6.3.1 程序流程图

**程序流程图又称为程序框图**，它是使用最广泛的描述过程设计的方法。程序流程图中使用的

- **(a) 选择(分支)；** 
- (b) 注释； 
- (c) 预先定义的处理； 
- **(d) 多分支；** 
- **(e) 开始或停止；** 
- (f) 准备； 
- (g) 循环上界限； 
- (h) 循环下界限； 
- (i) 虚线； 
- (j) 省略符； 
- (k) 并行方式； 
- **(l) 处理；** 
- **(m) 输入输出；** 
- **(n) 连接；** 
- **(o) 换页连接；** 
- **(p) 控制流**

![image-20220331115821806](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331115821.png)

#### 五种基本控制结构

![image-20220331120150766](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331120150.png)

![image-20220331120243871](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331120244.png)

### 6.3.2 盒图

出于要有一种不允许违背结构程序设计精神的图形工具的考虑，Nassi和Shneiderman提出了盒图，又称为N-S图。它有下述特点。

- 功能域(即一个特定控制结构的作用域)明确，可以从盒图上一眼就看出来。
- 不可能任意转移控制。
- 很容易确定局部和全程数据的作用域。
- 很容易表现嵌套关系，也可以表示模块的层次结构。

图给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图表示方法。其中

基本符号(a) 顺序； (b) IF_THEN_ELSE型分支； (c) CASE型多分支； (d) 循环； (e) 调用子程序A

![image-20220331121141447](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331121141.png)

![image-20220331121407500](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331121407.png)

![image-20220331121538923](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331121539.png)

### 6.3.3 PAD图

PAD是问题分析图(problem analysis diagram)的英文缩写，用二维树形结构的图来表示程序的控制流。

基本符号

(a)顺序(先执行P1后执行P2)；

(b)选择(IF C THEN P1 ELSE P2); 

(c)CASE型多分支；

(d)WHILE型循环(WHILE C DO P);

(e)UNTIL型循环(REPEAT P UNTIL C)； 

(f)语句标号； 

(g)定义

![image-20220331121200474](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220331121200.png)

**PAD图的主要优点如下**：

- 使用表示结构化控制结构的PAD符号所设计出来的程序必然是结构化程序。
-  PAD图所描绘的程序结构十分清晰。
- 用PAD图表现程序逻辑，易读、易懂、易记。
- 容易将PAD图转换成高级语言源程序，这种转换可 用软件工具自动完成，从而可省去人工编码的工作，有利于提高软件可靠性和软件生产率。
- 即可用于表示程序逻辑，也可用于描绘数据结构。
- PAD图的符号支持自顶向下、逐步求精方法的使用。

#### 示例

![image-20220405105538474](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405105538.png)

![image-20220405105558868](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405105559.png)

### 6.3.4 判定表

判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。
判定表由4部分组成，

- 左上部列出所有**条件**
- 左下部是所有可能做的**动作**
- 右上部是表示各种条件组合的一个**矩阵**
- 右下部是和每种条件组合相对应的**动作**

判定表右半部的每一列实质上是一条规则，规定了与特定的条件组合相对应的动作。

![image-20220405105925694](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405105925.png)

### 6.3.5 判定树

判定树是判定表的变种，它也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。

![image-20220405110645065](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405110645.png)

### 6.3.6 过程设计语言

过程设计语言（PDL）也称为伪码。是用正文形式表示数据和处理过程的设计工具。
PDL有下述特点：

- 关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。如，if…fi(或endif)等
- 自然语言的自由语法，它描述处理特点。
- 数据说明的手段。应该既包括简单的数据结构(例如纯量和数组)，又包括复杂的数据结构(例如，链表或层次的数据结构)。
- 模块定义和调用的技术，应该提供各种接口描述模式。

**PDL有下述优点：**

1. 可以作为注释直接插在源程序中间。
2. 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。
3. 已经有自动处理PDL的程序存在，而且可以自动由PDL生成程序代码。

**PDL的缺点**

1. 不如图形工具形象直观，描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。

> ![image-20220405111101718](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405111101.png)
>
> ![image-20220405111404231](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405111404.png)
>
> ![image-20220405111429697](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405111429.png)

#### 练习

![image-20220405111856521](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405111856.png)

![image-20220405114605692](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405114605.png)

### 总结

![image-20220405111821863](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405111822.png)

# 第8章 维护

## 8.1. 软件维护的定义

​    所谓软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。可以通过描述软件交付使用后可能进行的4项活动，具体地定义软件维护。

### 8.1.1.改正性维护

   因为软件测试不可能暴露出一个大型软件系统中所有潜藏的错误，所以必然会有第一项维护活动：
   在任何大型程序的使用期间，用户必然会发现程序错误，并且把他们遇到的问题报告给维护人员。把诊断和改正错误的过程称为改正性维护。

### 8.1.2. 适应性维护——第二项维护活动

   因为软件测试不可能暴露出一个大型软件系统中所有潜藏的错误，所以必然会有第一项维护活动：
   在任何大型程序的使用期间，用户必然会发现程序错误，并且把他们遇到的问题报告给维护人员。把诊断和改正错误的过程称为改正性维护。

![image-20220405115947582](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405115947.png)

### 8.1.3.完善性维护

当一个软件系统顺利地运行时，常常出现第三项维护活动：

- 在使用软件的过程中用户往往提出增加**新功能**或修改已有功能的建议，还可能提出一般性的**改进意见。**
- 为了满足这类要求，需要进行完善性维护。
- 这项维护活动通常占软件维护工作的大部分。

### 8.1.4.预防性维护

​    当为了改进未来的**可维护性或可靠性**，或为了给未来的改进奠定更好的基础而修改软件时，出现了第四项维护活动。这项维护活动通常称为预防性维护，目前这项维护活动相对比较少。

### 总结

![image-20220405120349730](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220405120349.png)

从上述关于软件维护的定义不难看出，软件维护绝不仅限于纠正使用中发现的错误，事实上在全部维护活动中一半以上是完善性维护。

应该注意，上述4类维护活动都必须应用于整个软件配置，维护软件文档和维护软件的可执行代码是同样重要的。

## 8.2 软件维护的特点

### 8.2.1. 结构化维护与非结构化维护差别巨大

#### 1.非结构化维护

如果软件配置的唯一成分是程序代码，那么维护活动从艰苦地评价程序代码开始，而且常常由于程序内部文档不足而使评价更困难，对于软件结构、全程数据结构、系统接口、性能和(或)设计约束等经常会产生误解，而且对程序代码所做的改动的后果也是难于估量的。
非结构化维护需要付出很大代价(浪费精力并且遭受挫折的打击)，这种维护方式是没有使用良好定义的方法学开发出来的软件的必然结果。

#### 2.结构化维护

如果有一个完整的软件配置存在，那么维护工作从评价设计文档开始，确定软件重要的结构、性能以及接口等特点；估量要求的改动将带来的影响，并且计划实施途径。然后：

- l首先，修改设计并且对所做的修改进行仔细复查。
- l然后，编写相应的源程序代码；
- l接下来，使用在测试说明书中包含的信息进行回归测试；
- l最后，把修改后的软件再次交付使用。

刚才描述的事件构成结构化维护，它是在软件开发的早期应用软件工程方法学的结果。虽然有了软件的完整配置并不能保证维护中没有问题，但是确实能减少精力的浪费并且能提高维护的总体质量。

### 8.2.2. 维护的代价高昂

#### 无形的代价！！！

​    因为可用的资源必须供维护任务使用，以致耽误甚至丧失了开发的良机，这是软件维护的一个无形的代价。其他无形的代价还有以下几个。

- l当看来合理的有关改错或修改的要求不能及时满足时将引起用户不满。
- l由于维护时的改动，在软件中引入了潜伏的错误，从而降低了软件的质量。
- l当必须把软件工程师调去从事维护工作时，将在开发过程中造成混乱。

#### 最后一个代价

   软件维护的最后一个代价是生产率的大幅度下降，这种情况在维护旧程序时常常遇到。

据Gausler在1976年的报道，美国空军的飞行控制软件每条指令的开发成本是75美元，然而维护成本大约是每条指令4000美元，也就是说，生产率下降为约1/50。

#### 用于维护工作的劳动可以分：

A.生产性活动

- 分析评价
- 修改设计
- 编写程序代码

B.非生产性活动

- 理解程序代码的功能
- 解释数据结构
- 接口特点
- 性能限度

下述表达式给出维护工作量的一个模型：M=P+K×exp(c-d)，其中：

- M：维护用的总工作量
- P：生产性工作量
- K：经验常数
- c：复杂程度
- d：维护人员对软件的熟悉程度

**上面的模型表明，如果软件的开发途径不好，而且原来的开发人员不能参加维护工作，那么维护工作量和费用将指数地增加。**

### 8.2.3. 维护的问题很多

> 下面列出和软件维护有关的部分问题：
>
> 1. 理解别人写的程序通常非常困难，而且困难程度随着软件配置成分的减少而迅速增加。如果仅有程序代码没有说明文档，则会出现严重的问题。
> 2.  需要维护的软件往往没有合格的文档，或者文档资料显著不足。认识到软件必须有文档仅仅是第一步，容易理解的并且和程序代码完全一致的文档才真正有价值。
> 3. 当要求对软件进行维护时，不能指望由开发人员给人们仔细说明软件。由于维护阶段持续的时间很长，因此，当需要解释软件时，往往原来写程序的人已经不在附近了。
> 4. 绝大多数软件在设计时没有考虑将来的修改。除非使用强调模块独立原理的设计方法学，否则修改软件既困难又容易发生差错。
> 5. 软件维护不是一项吸引人的工作。形成这种观念很大程度上是因为维护工作经常遭受挫折。
>
> 
>
> ​    上述种种问题在现有的没采用软件工程思想开发出来的软件中，都或多或少地存在着。不应该把一种科学的方法学看做万应灵药，但是，软件工程至少部分地解决了与维护有关的每一个问题。

## 8.3 软件维护的过程

**维护过程的本质**

维护过程本质上是修改和压缩了的软件定义和开发过程，而且事实上远在提出一项维护要求之前，与软件维护有关的工作已经开始了。

- l首先必须建立一个**维护组织**
- l随后必须确定**报告和评价的过程**
- l而且必须为每个维护要求**规定一个标准化的事件序列**

此外，还应该建立一个适用于**维护活动的记录**保管过程，并且规定复审标准。

### 1. 维护组织

为了有效地进行软件维护，应事先就开始做组织工作。

-  首先建立维护的机构
-  申明提出维护申请报告的过程及评价的过程
-  为每一个维护申请规定标准的处理步骤
-  建立维护活动的登记制度以及规定评价和评审的标准。

**软件维护的机构**

![image-20220407104821398](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407104821.png)

- 维护申请提交给维护管理员，他把申请交给某个系统监督员去评价。
- 一旦做出评价，由修改负责人确定如何进行修改。
- 在修改程序的过程中，由配置管理员严格把关，控制修改的范围，对软件配置进行审计。
- 在维护之前，就把责任明确下来，可以减少维护过程中的混乱。

### 2.软件维护申请报告

- 维护申请报告或称**软件问题报告**，由申请维护的**用户填写**。
- 用户必须**完整地说明产生错误的情况**，包括**输入数据、错误清单以及其它有关材料。**
- 如果申请的是适应性维护或完善性维护，用户必须提出一份修改说明书，列出所有希望的修改。

- 维护申请报告将由**维护管理员和系统监督员**来研究处理。
- 他们应相应地做出**软件修改报告**，指明：
  - 为满足某个维护申请报告，所需的工作量；
  - 所需修改变动的性质；
  - 申请修改的优先级；
  - 预计修改后的状况.
- 软件修改报告应提交修改负责人，经批准后才能开始进一步安排维护工作。

### 3.软件维护工作流程

![image-20220407105031776](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407105031.png)

尽管维护申请的类型不同，但都要进行同样的**技术工作**。

-  **修改软件需求说明**
-  **修改软件设计**
-  **设计评审**
-  **对源程序做必要的修改**
-  **单元测试**
-  **集成测试( 回归测试)**
-  **确认测试**
-  **软件配置评审等。**

在每次软件维护任务完成后进行**情况评审**，对以下问题做一总结：

1. **在目前情况下，设计、编码、测试中的哪一方面可以改进?**
2. **哪些维护资源应该有但没有?**
3. **工作中主要的或次要的障碍是什么?**
4. **从维护申请的类型来看是否应当有预防性维护?**

情况评审对将来的维护工作如何进行会产生重要的影响。

### 4.维护档案记录

- **程序名称**
- **源程序语句条数**
- **机器代码指令条数**
- **所用的程序设计语言**
- **程序安装的日期**
- **程序安装后的运行次数**
- **与程序安装后运行次数有关的处理故障次数**

- **程序改变的层次及名称**
- **修改程序增加的源程序语句条数**
- **修改程序减少的源程序语句条数**
- **每次修改所付出的“人时”数**
- **修改程序的日期**
- **软件维护人员的姓名**
- **维护申请报告的名称、维护类型**
- **维护开始时间和维护结束时间、**
- **花费在维护上的累计“人时”数**
- **维护工作的净收益等**

### 5.维护评价

如果维护的档案记录做得比较好，可以得出一些维护“性能”方面的度量值。

1.  每次程序运行时的**平均出错**次数；
2.  花费在每类维护上的**总“人时”**数；
3. 每个程序、每种语言、每种维护类型的程序**平均修改次数**；
4. 因为维护，增加或删除每个源程序语句所花费的**平均“人时”数**；
5.  用于每种语言的**平均“人时”**数；
6.  维护申请报告的**平均处理时间**；
7.  各类维护申请的**百分比**。

#### 软件维护的策略

- **改正性维护**
- **通常要生成100％可靠的软件并不一定合算**，成本太高。但通过使用新技术，可大大减少进行改正性维护的需要。
- 这些技术包括：
  - **数据库管理系统、软件开发环境、程序自动生成系统、较高级(第四代)的语言。以及新的开发方法、软件复用、防错程序设计及周期性维护审查**等。

#### 适应性维护

这一类维护不可避免，可以控制。

- 在配置管理时，把硬件、操作系统和其它相关环境因素的可能变化考虑在内。
- 把与硬件、操作系统，以及其它外围设备有关的程序归到特定的程序模块中。 
- 使用内部程序列表、外部文件，以及处理的例行程序包，可为维护时修改程序提供方便。

#### 完善性维护

- 利用前两类维护中列举的方法，也可以减少这一类维护。特别是**数据库管理系统、程序生成器、应用软件包，可减少维护工作量。**
- 此外，建立软件系统的原型，把它在实际系统开发之前提供给用户。用户通过研究原型，进一步完善他们的功能要求，就可以减少以后完善性维护的需要。

#### 程序修改的步骤及修改的副作用

在软件维护时，必然会对**源程序进行修改。**

通常对源程序的修改不能无计划地仓促上阵，为了正确、有效地修改,需要经历以下**三个步骤**。

##### 分析和理解程序

经过分析，**全面、准确、迅速地理解程序是决定维护成败和质量好坏的关键**。在这方面，软件的可理解性和文档的质量非常重要。

- 理解程序的功能和目标；
- 掌握程序的结构信息，即从程序中细分出若干结构成分。如**程序系统结构、 控制结构、数据结构和输入／输出结构等；**
- 了解数据流信息，即涉及到的数据来源何处，在哪里被使用；
- 了解控制流信息，即执行每条路径的结果；
- 理解程序的操作(使用)要求；

为了容易地理解程序，要求自顶向下地理解现有源程序的程序结构和数据结构，为此可采用如下几种方法：

###### 1.分析程序结构图

![image-20220407110351056](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407110351.png)

![image-20220407110356210](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407110356.png)

###### 2.数据跟踪

(1) **建立各层次的程序级上的接口图**，展示各模块或过程的调用方式和接口参数；

(2) **利用数据流分析方法，对过程内部的一些变量进行跟踪**。可获得有关数据在过程间如何传递，在过程内如何处理等信息。对于判断问题原因特别有用。在跟踪的过程中可在源程序中间插入自己的注释。

###### 3.控制跟踪

控制流跟踪可采用符号执行或实际动态跟踪的方法，了**解数据如何从一个输入源到达输出点的。**

###### 4.充分阅读和使用源程序清单和文档，分析现有文档的合理性。

###### 5.充分使用由编译程序或汇编程序提供的交叉引用表、符号表、以及其它有用的信息。

###### 6.如有可能，积极参加开发工作。

##### 修改程序

对程序的修改，必须事先做出计划，有预谋地、周密有效地实施修改。

###### 1.设计程序的修改计划

程序的修改计划要**考虑人员和资源**的安排。小的修改可以不需要详细的计划，而对于需要耗时数月的修改，就需要计划立案。

在编写有关问题解决的方案时，必须充分描述修改作业的规格说明。

- **规格说明信息**：数据修改、处理修改、作业控制语言修改、系统之间接口的修改等；
- **维护资源**：新程序版本、测试数据、所需软件、计算机时间等；
- **人员**；
- **支持**：纸面、计算机媒体等。

![image-20220407111000098](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111000.png)

![image-20220407111132514](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111132.png)

###### 2.修改代码

![image-20220407111159938](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111200.png)

###### 3.修改程序的副作用

修改代码的副作用

![image-20220407111418086](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111418.png)

修改数据的副作用

![image-20220407111454409](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111454.png)

修改文档的副作用

![image-20220407111612084](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111612.png)

![image-20220407111649952](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111650.png)

控制副作用

![image-20220407111754225](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111754.png)

##### 重新验证程序

###### 静态确认

![image-20220407111905199](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111905.png)

###### 计算机确认

![image-20220407111929617](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111929.png)

###### 维护后的验收

![image-20220407111953120](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407111953.png)

##### 测试种类

![image-20220407112217177](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407112217.png)

## 8.4 软件的可维护性

衡量软件质量的几个主要质量特性：

- **可维护性**
- **可使用性**
- **可靠性**

软件可**维护性**的定义：指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度

### 8.4.1. 决定软件可维护性的因素

维护就是在软件交付使用后进行的修改，**修改之前必须理解待修改的对象，修改之后应该进行必要的测试**，以保证所做的修改是正确的。如果是改正性维护，还必须预先进行调试以确定错误的具体位置。决定软件可维护性的因素主要有    

- 可理解性；
- 可测试性；
- 可修改性；
- 可移植性；
- 可重用性；
- 可使用性；
- 可靠性；	
- 效率：

**在各类维护中的侧重点**     

![image-20220407112636655](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407112636.png)

#### 1.可理解性

- **可理解性表明人们通过阅读源代码和相关文档**，**了解程序功能及其如何运行的容易程度**。
- 模块化，风格一致性，不使用令人捉摸不定或含糊不清的代码，使用有意义的数据名和过程名，结构化，完整性等。

#### 2.可测试性

**可测试性表明论证程序正确性的容易程度**。

诊断和测试的容易程度取决于软件容易理解的程度。

- **良好的文档**
- **软件结构**
- **可用的测试工具**
- **调试工具，**
- **以前设计的测试过程**
- **开发阶段用过的测试方案，以便维护人员进行回归测试。**
- **在设计阶段应该尽力把软件设计成容易测试和容易诊断的。**

对于程序模块来说，可以用程序复杂度来度量它的可测试性。模块的环形复杂度越大，可执行的路径就越多，因此，全面测试它的难度就越高。

#### 3.可修改性

**可修改性表明程序容易修改的程度**。

一个可修改的程序应当是**可理解的、通用的、灵活的、简单的。**

- **通用性**是指程序适用于各种功能变化而无需修改。
- **灵活性**是指能够容易地对程序进行修改。

软件容易修改的程度和本书第5章讲过的设计原理和启发规则直接有关。**耦合、内聚、信息隐藏、局部化、控制域与作用域的关系**等，都影响软件的可修改性。

![image-20220407113518058](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407113518.png)

#### 4.可移植性

- **可移植性表明程序转移到一个新的计算环境**（硬件配置和操作系统等）的可能性的大小。或者它表明程序可以容易地、有效地在各种各样的计算环境中运行的容易程度。
- 一个可移植的程序应具有**结构良好、灵活、不依赖于某一具体计算机或操作系统的性能。**
- 把与**硬件、操作系统以及其他外部设备有关的程序代码集**中放到特定的程序模块中，可以把因环境变化而必须修改的程序局限在少数程序模块中，从而降低修改的难度。

#### 5.可重用性

所谓重用（reuse）是指同一事物不做修改或**稍加改动就在不同环境中多次重复使用**。大量使用可重用的软件构件来开发软件，可以从下述两个方面提高软件的可维护性。

- 通常，可重用的软件构件在开发时都经过**很严格的测试，可靠性比较高**，且在每次重用过程中都会发现并清除一些错误，随着时间推移，**这样的构件将变成实质上无错误的**。因此，软件中使用的可重用构件越多，软件的可靠性越高，改正性维护需求就越少。
- **很容易修改可重用的软件构件使之再次应用在新环境中**，因此，软件中使用的可重用构件越多，适应性和完善性维护也就越容易。

#### 6.可使用性

从用户观点出发，**可使用性定义为程序方便、实用、及易于使用的程度**。一个可使用的程序应是**易于使用的、能允许用户出错和改变，并尽可能不使用户陷入混乱状态的程序。**

#### 7.可靠性

可靠性表明一个程序按照用户的要求和设计目标，在**给定的一段时间内正确执行的概率。**

##### 度量可靠性的方法

![image-20220407114146655](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407114146.png)

#### 8.效率

- **效率表明一个程序能执行预定功能而又不浪费机器资源的程度。**
- 这些机器资源包括**内存容量、外存容量、通道容量和执行时间。**

##### 用于效率度量的检查项目

- 程序是否模块化? 结构是否良好?
- 是否消除了无用的标号与表达式，以充分发挥编译器优化作用?
- 程序的编译器是否有优化功能?

- 是否把特殊子程序和错误处理子程序都归入了单独的模块中?
- 是否以快速的数学运算代替了较慢的数学运算?
- 是否尽可能地使用了整数运算，而不是实数运算?
- 是否在表达式中避免了混合数据类型的使用，消除了不必要的类型转换? 
- 程序是否避免了非标准的函数或子程序的调用?
- 在几条分支结构中，是否最有可能为“真”的分支首先得到测试?
- 在复杂的逻辑条件中，是否最有可能为“真“的表达式首先得到测试?

### 8.4.2.文档

**文档是影响软件可维护性的决定因素**。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档比程序代码更重要。

软件文档应该满足下述要求：

1. 必须描述如何使用这个系统。
2. 必须描述怎样安装和管理这个系统。
3. 必须描述系统需求和设计。
4. 必须描述系统的实现和测试。

文档分为**用户文档**和**系统文档**两类。

- 用户文档主要描述系统功能和使用方法，不关心这些功能是怎样实现的。
- 系统文档指从问题定义、需求说明到验收测试这样系列的有关文档。

#### 1.用户文档

用户文档是用户了解系统的第一步，它应该能使用户获得对系统的准确的初步印象。

 (1)功能描述

 (2) 安装文档

 (3) 使用手册

 (4) 参考手册（要完整）

 (5) 操作员指南(如果需要有系统操作员的话)

#### 2.系统文档

​     所谓**系统文档**指从**问题定义、需求说明到验收测试计划**这样一系列和系统实现有关的文档。描述系统设计、实现和测试的文档对于理解程序和维护程序来说是极端重要的。

   和用户文档类似，系统文档的结构也应该能把读者从对系统概貌的了解，引导到对系统每个方面每个特点的更形式化更具体的认识。

##### 为什么要进行可维护性复审？

- **可维护性是所有软件都应该具备的基本特点**，必须在开发阶段**保证软件具有可维护因素**。
- **不能准确反映软件当前状态的设计文档可能比完全没有文档更坏。**
- 如果对软件的可执行部分的修改没有及时反映在用户文档中，则必然会使用户因为受挫折而产生不满。

- 在软件再次交付使用之前，对软件配置进行严格的复审，则可大大减少文档的问题。
- **在需求分析阶段的复审过程中**，应该对将来要改进的部分和可能会修改的部分加以注意并指明；应该讨论软件的可移植性问题，并且考虑可能影响软件维护的系统界面。
- **在正式的和非正式的设计复审期间**，应该从容易修改、模块化和功能独立的目标出发，评价软件的结构和过程；设计中应该对将来可能修改的部分预作准备。

- **代码复审**应该强调编码风格和内部说明文档这两个影响可维护性的因素。
- **在设计和编码过程中**应该尽量使用可重用的软件构件，如果需要开发新的构件，也应该注意提高构件的可重用性。
- **在测试结束时**进行最正式的可维护性复审，这个复审称为配置复审。配置复审的目的是保证软件配置的所有成分是完整的、一致的和可理解的，而且为了便于修改和管理已经编目归档了。

##### 提高可维护性的方法

- **建立明确的软件质量目标和优先级**
  - 一个可维护的程序应是可理解的、可靠的、可测试的、可修改的、可移植的、效率高的、可使用的。
  - 要实现这所有的目标，需要付出很大的代价，而且也不一定行得通。
  - 某些质量特性是相互促进的，例如可理解性和可测试性、可理解性和可修改性。
  - 另一些质量特性是相互抵触的，如效率和可移植性、效率和可修改性等。
  - 每一种质量特性的相对重要性应随程序的用途及计算环境的不同而不同。例如，对编译程序来说，可能强调效率；但对管理信息系统来说，则可能强调可使用性和可修改性。
  - 应当对程序的质量特性，在提出目标的同时还必须规定它们的优先级。

- **使用提高软件质量的技术和工具**
  - 模块化
    如果需要改变某个模块的功能，则只要改变这个模块，对其它模块影响很小；
    如果需要增加程序的某些功能，则仅需增加完成这些功能的新的模块或模块层；
    程序的测试与重复测试比较容易；
    程序错误易于定位和纠正； 
  - 结构化程序设计
     程序被划分成分层的模块结构；
     模块调用控制必须从模块的入口点进入，从其出口点退出。
     模块的控制结构仅限于顺序、选择、重复三种，且没有GOTO语句。
     每个程序变量只用于唯一的程序目的，而且变量的作用范围应是明确的、有限制的。
  - 使用结构化程序设计技术，提高现有系统的可维护性
    采用备用件的方法──用一个新的结构良好的模块替换掉整个要修改的模块。
    采用自动重建结构和重新格式化的工具(结构更新技术)──把非结构化代码转换成良好结构代码 。
    改进现有程序的不完善的文档─ ─建立或补充系统说明书、设计文档、模块说明书、以及在源程序中插入必要的注释。



- **进行明确的质量保证审查**
  - 质量保证审查对于获得和维持软件的质量，是一个很有用的技术。
  - 审查可以用来检测在开发和维护阶段内发生的质量变化。
  - 一旦检测出问题来，就可以采取措施来纠正，以控制不断增长的软件维护成本，延长软件系统的有效生命期。
    1. **在检查点进行复审**
       - 保证软件质量的最佳方法是在软件开发的最初阶段把质量要求考虑进去，并在开发过程每一阶段的终点，设置检查点进行检查。
         检查的目的是要证实，已开发的软件是否符合标准，是否满足规定的质量需求。在不同的检查点，检查的重点不完全相同。
       - ![image-20220407115751529](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407115751.png)
       - 在设计阶段，检查重点是可理解性、可修改性、可测试性。
         - 可理解性检查的重点是程序的复杂性。对每个模块可用McCabe环路来计算模块的复杂性，若大于10，则需重新设计。
         - 可以使用各种质量特性检查表，或用度量标准来检查可维护性。
         - 审查小组可以采用人工测试一类的方式，进行审查。
    2. **验收检查**
       - 验收检查是一个特殊的检查点的检查，是交付使用前的最后一次检查，
         验收检查实际上是验收测试的一部分，只不过它是从维护的角度提出验收的条件和标准。
         验收检查必须遵循的最小验收标准。
         - ![image-20220407115846014](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407115846.png)
         - ![image-20220407115854151](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407115854.png)
    3. **周期性维护审查**
       - 检查点复查和验收检查，可用来保证新软件系统的可维护性
       - 对已有的软件系统，则应当进行周期性的维护检查。
       - 软件在运行期间进行修改，会导致软件质量有变坏的危险，破坏程序概念的完整性。
       - 必须定期检查，对软件做周期性的维护审查，以跟踪软件质量的变化。
       - 周期性维护审查实际上是开发阶段检查点复查的继续，并且采用的检查方法、检查内容都是相同的。
       - 维护审查的结果可以同以前的维护审查的结果，以前的验收检查的结果、检查点检查的结果相比较，任何一种改变都表明在软件质量上或其它类型的问题上可能起了变化。
       - 对于改变的原因应当进行分析。
    4. **对软件包进行检查**
       - 软件包是一种标准化的，可为不同单位、不同用户使用的软件。
       - 一般源代码和程序文档不会提供给用户。
       - 对软件包的维护采取以下方法。
         - 使用单位的维护人员首先要仔细分析、研究卖主提供的用户手册、操作手册、培训教程等，以及卖方提供的验收测试报告等。
         - 在此基础上，深入了解本单位的希望和要求，编制软件包的检验程序。检查软件包程序所执行的功能是否与用户的要求和条件相一致。
         - 为了建立这个程序，维护人员可以利用卖方提供的验收测试实例，还可以自己重新设计新的测试实例。
         - 根据测试结果，检查和验证软件包的参数或控制结构，以完成软件包的维护。

- **选择可维护的程序设计语言**
  - ![image-20220407120149479](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407120149.png)

- **改进程序的文档**
  - 程序文档是对程序总目标、程序各组成部分之间的关系、程序设计策略、程序实现过程的历史数据等的说明和补充。
  - 即使是一个十分简单的程序，要想有效地、高效率地维护它，也需要编制文档来解释其目的及任务。
  - 对于程序维护人员来说，要想按程序编制人员的意图重新改造程序，并对今后变化的可能性进行估计，缺了文档是不行的。
  - 因此，为了维护程序，人们必须阅读和理解文档。
  - 另外，在软件维护阶段，利用**历史文档**，可以大大简化维护工作。通过了解原设计思想，可以判断出错之处，指导维护人员选择适当的方法修改代码而不危及系统的完整性。
  - **历史文档**有三种：
    -  **系统开发日志**
    -  **错误记载**
    -  **系统维护日志**

## 8.5 预防性维护

### 怎样满足用户对老程序的维护要求？

> 这些程序的体系结构和数据结构都很差，文档不全甚至完全没有文档，对曾经做过的修改也没有完整的记录。

（1）反复多次地做修改程序的尝试，与不可见的设计及源代码“顽强战斗”，以实现所要求的修改。
（2） 通过仔细分析程序尽可能多地掌握程序的内部工作细节，以便更有效地修改它。
（3） 在深入理解原有设计的基础上，用软件工程方法重新设计、重新编码和测试那些需要变更的软件部分。
（4） 以软件工程方法学为指导，对程序全部重新设计、重新编码和测试，为此可以使用CASE工具（逆向工程和再工程工具）来帮助理解原有的设计

**预防性维护方法定义为：“把今天的方法学应用到昨天的系统上，以支持明天的需求。”**

> **在一个正在工作的程序版本已经存在的情况下重新开发一个大型程序，似乎是一种浪费。值得吗？**
>
> 下述事实很能说明问题。
>
> (1) 维护一行源代码的代价可能是最初开发该行源代码代价的14~40倍。
>
> (2) 重新设计软件体系结构（程序及数据结构）时使用了现代设计概念，它对将来的维护可能有很大的帮助。
>
> (3)由于现有的程序版本可作为软件原型使用，开发生产率可大大高于平均水平。
>
> (4)用户具有较多使用该软件的经验，因此，能够很容易地搞清晰的变更需求和变更的范围。
>
> (5)利用逆向工程和再工程的工具，可以使一部分工作自动化。
>
> (6)在完成预防性维护的过程中可以建立起完整的软件配置。

##    8.6   软件再工程过程

​      典型的软件再工程过程模型如下图所示。

![image-20220407120926005](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220407120926.png)

**软件再工程**

- 软件再工程是一个工程过程，它将逆向工程、重构和正向工程组合起来，旨在对现存的大量软件系统进行挖掘、整理，重新获得设计信息，用这些信息改建或重构现有的系统，以改进它的综合质量；
- 或者得到有用的软件构件，对已有软件构件进行维护以延长其生存期。
- 再工程的基础是系统理解，包括对运行系统、源代码、设计、分析、文档等的全面理解。但在很多情况下，由于各类文档的丢失，只能对源代码进行理解，即程序理解。

### 1.库存目录分析

每个软件组织都应该保存其拥有的所有应用系统的库存目录。该目录包含关于每个应用系统的基本信息

> （例如应用系统的名字，最初构建它的日期，已做过的实质性修改次数，过去18个月报告的错误，用户数量，安装它的机器数量，它的复杂程度，文档质量，整体可维护性等级，预期寿命，在未来36个月内的预期修改次数，业务重要程度等）。

应该仔细分析库存目录，按照业务重要程度、寿命、当前可维护性、预期的修改次数等标准，把库中的应用系统排序，从中选出再工程的候选者，然后明智地分配再工程所需要的资源。

### 2.文档重构

老程序固有的特点是缺乏文档。具体情况不同，处理这个问题的方法也不同。

- 建立文档非常耗费时间，不可能为数百个程序都重新建立文档。如果一个程序是相对稳定的，正在走向其有用生命的终点，而且可能不会再经历什么变化，那么，让它**保持现状**是一个明智的选择。
- 为了便于今后的维护，必须更新文档，但是由于资源有限，应采用“**使用时建文档**”的方法。
- 如果某应用系统是完成业务工作的关键，而且必须重构全部文档，则仍然应该设法把文档工作**减少到必需的最小量**。

### 3.逆向工程

**逆向工程是分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程**，是一个恢复设计结果的过程，逆向工程工具从现存的程序代码中抽取有关数据、体系结构和处理过程的设计信息。

### 4.代码重构

代码重构是最常见的再工程活动。某些老程序具有比较完整、合理的体系结构，但是，个体模块的编码方式却是难于理解、测试和维护的。在这种情况下，可以**重构可疑模块的代码**。

- 首先，用重构工具分析源代码，标注出和结构化程序设计概念相违背的部分
- 然后，重构有问题的代码（此项工作可自动进行）
- 最后，复审和测试生成的重构代码（以保证没有引入异常）并更新代码文档。

### 5.数据重构

**与代码重构不同**，数据重构发生在相当低的抽象层次上，它是一种全范围的再工程活动——对数据的修改必然会导致体系结构或代码层的改变。在大多数情况下，数据重构始于逆向工程活动，分解当前使用的数据体系结构，必要时定义数据模型，标识数据对象和属性，并从软件质量的角度复审现存的数据结构。

当数据结构较差时（例如在关系型方法可大大简化处理的情况下却使用平坦文件实现），应该对数据进行再工程。

### 6.正向工程

应用现代软件工程的概念、原理、技术和方法，**重新开发现有的某个应用系统**。

## 第9章  面向对象方法学引论

​     面向对象技术强调在软件开发过程中面向客观世界或问题域中的事物，采用人类在认识客观世界的过程中普遍运用的思维方法，直观、自然地描述客观世界中的有关事物。

  面向对象的分析方法是利用面向对象的信息建模概念，如实体、关系、属性等，同时运用封装、继承、多态等机制来构造模拟现实系统的方法。

  传统的结构化设计方法的基本点是面向过程，系统被分解成若干个过程。而面向对象的方法是采用构造模型的观点，在系统的开发过程中，各个步骤的共同的目标是建造一个问题域的模型。在面向对象的设计中，初始元素是对象，然后将具有共同特征的对象归纳成类，组织类之间的等级关系，构造类库。在应用时，在类库中选择相应的类。

## 9.1  面向对象方法学概述

### 9.1.1.面向对象方法学的要点

**软件工程发展的两个重要阶段**

- **传统软件工程**
- **面向对象软件的工程**

#### 传统软件工程

以*面向过程的结构化程序设计*为基础；

遵循“*程序**=**数据结构**+**算法*”的思路；

由“追求技巧与效率”到“*清晰第一，效率第二*”

缺点：

- 不太适应规模大、特别复杂的项目；
- 难以解决软件重用的问题；
- 难以适应需求的变化；
- 难以彻底解决维护问题。

#### 面向对象软件的工程

- 按人类习惯的思维方法，以现实世界中客观存在的事物（即对象）为中心来思考和认识问题。
- 采用的思想方法与原则：抽象、分类、继承、聚合、封装等。
- 以易于理解的方式表达软件系统，建立问题域模型，使设计出的软件尽可能直接地描述现实世界，具有更好的可维护性

面向对象方法具有下述4个要点：

① 任何客观的事物或实体都是对象。对象组成客观世界，复杂的对象可以由简单的对象组成。

② 具有相同数据和操作的对象可以归并为一个类（class ) ，对象是对象类的一个实例。

③ 类可以派生出子类，子类继承父类的全部特性（数据和操作），又可以有自己的新特性。子类与父类形成类的层次结构。

④ 对象之间通过消息传递相互联系。



>    **面向对象＝对象＋类＋继承＋消息通信**
>
> 如果一个软件系统采用这些概念来建立模型并予以实现，那么它就是面向对象的。
>
> 一个面向对象的程序的每一成份应是对象，计算是通过新的对象的建立和对象之间的通信来执行的。

**面向对象范型的特点**

- 面向对象系统中的对象是数据抽象与过程抽象的综合体。
- 所谓过程抽象是指当使用某个过程时，无需关心过程内部的实现细节，只要知道如何调用该过程以及该过程完成什么功能即可。
- 所谓数据抽象是指使用结构或记录等方式把某个实体的数据集中起来，使得使用者能够以单元为单位使用数据。
- 面向对象范型在数据抽象中组织过程抽象。

- 面向对象系统的状态分别保存在各个对象的数据存储中，而不是保存在一些全局变量中。
- 系统解决问题的控制流包含在各个对象中的操作内。并通过消息传递，控制流从一个对象转移到另一个对象。
- 算法被分布到各种实体中。通过执行消息传递和对象中的操作实现算法的功能。

**面向对象的特点**

抽象性：对象包含数据抽象和行为抽象；

封装性：信息隐蔽（使用与实现分开）；

共享性：

- 同一个类中所有对象共享相同的数据结构和行为；
- 同一应用中的对象通过继承关系，共享共同的数据结构和行为；
- 不同应用中的对象通过复用，共享数据结构和行为。

### 9.1.2.面向对象方法学的优点

1.与人类习惯的思维方法一致

l面向对象的软件技术以对象为核心，用这种技术开发出的软件系统由对象组成。对象是由描述内部状态表示静态属性的数据，以及可以对这些数据施加的操作(对象的动态行为)，封装在一起所构成的统一体。

l面向对象的设计方法基本原理是，使用现实世界的概念抽象地思考问题从而自然地解决问题。

l面向对象方法学的基本原则是按照人类习惯的思维方法建立问题域的模型，开发出尽可能直观、自然地表现求解方法的软件系统。面向对象的软件系统中使用的对象，是对客观世界中实体的抽象。

2.稳定性好

  面向对象的软件系统的结构是根据问题领域的模型建立起来的，而不是基于对系统应完成的功能的分解，所以，当对系统的功能需求变化时并不会引起软件结构的整体变化，往往仅需要作一些局部性的修改。由于现实世界中的实体是相对稳定的，因此，以对象为中心构造的软件系统也是比较稳定的。

3.可重用性好

  对象固有的封装性和信息隐藏机制，使得对象的内部实现与外界隔离，具有较强的独立性。对象是比较理想的模块和可重用的软件成分。

  面向对象的软件技术在利用可重用的软件成分构造新的软件系统时，有很大的灵活性。有两种方法可以重复使用一个对象类：一种方法是创建该类的实例，从而直接使用它；另一种方法是从它派生出一个满足当前需要的新类。

4.较易开发大型软件产品

​    用面向对象方法学开发软件时，构成软件系统的每个对象就像一个微型程序，有自己的数据、操作、功能和用途，因此，可以把一个大型软件产品分解成一系列本质上相互独立的小产品来处理，这就不仅降低了开发的技术难度，而且也使得对开发工作的管理比较容易。

5.可维护性好

(1)面向对象的软件稳定性比较好。

(2)面向对象的软件比较容易修改。

(3)面向对象的软件比较容易理解。

(4)易于测试和调试。

## 9.2  面向对象的概念

### 9.2.1.对象

在现实世界中有意义的、与所要解决的问题有关系的任何事物都可以作为对象，包括具体的物理实体的抽象、人为的概念、任何有明确边界和意义的东西。

对象可以是外部实体、信息结构、事件、角色、组织结构、地点或位置、操作规程等。

> 如：一名职工、一本图书、贷款、生产计划、一场演出等。

对象既有静态的属性，又有动态的行为（操作）。

#### 从软件开发的角度定义对象

![image-20220414105037708](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111144.png)

#### 对象的形象表示

![image-20220414105053173](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111145.png)

![image-20220414105105098](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111146.png)

![image-20220414105111547](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111147.png)

### 9.2.2.其他概念

#### 1、类（ Class ) 

具有相同属性和服务的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述。

“类”好比是一个对象模板，用它可以产生多个对象。

![image-20220414105220032](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111148.png)

![image-20220414105230871](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111149.png)

#### 2.实例（instance）

实例是某个特定类所描述的一个具体对象。

如：“张三”“李四”是类“学生”的实例。

对象：可以是一个具体的对象，也可以泛指一般的对象。

实例：必然是指一个在客观世界中存在的具体对象。

#### 3.消息（massage）

对象之间通信的手段，是一个对象要求另一对象执行类中定义的某个操作的规格说明。

通常一个消息由三部分组成：

- l接收消息的对象
- l消息标识符（即消息名）
- l零个或多个变元

> 例如： MyCircle.Show (Green ) 
>
> MyCircle是接收消息的对象的名字， Show 是消息名，Green是消息的变元。

#### 4.方法（method）

  方法就是对象所能执行的操作，也就是类中所定义的服务。方法描述了对象执行操作的算法，响应消息的方法。在C++语言中把方法称为成员函数。

#### 5.属性（attribute）

  属性就是类中所定义的数据，它是对客观世界实体所具有的性质的抽象。类的每个实例都有自己特有的属性值。在C++语言中把属性称为数据成员。

>    如：学生类属性有姓名、年龄、性别等。
>
>    如：张三的年龄为19 ，李四 的年龄为20。

#### 6.封装（encapsulation）

  在面向对象的程序中，封装是指把数据和实现操作的代码集中起来放在对象内部。

  对象具有封装性的条件如下：

  (1) 有一个清晰的边界。所有私有数据和实现操作的代码都被封装在这个边界内，从外面看不见更不能直接访问。

  (2) 有确定的接口（即协议）。这些接口就是对象可以接受的消息，只能通过向对象发送消息来使用它。

  (3) 受保护的内部实现。实现对象功能的细节（私有数据和代码）不能在定义该对象的类的范围外访问。

  封装就是信息隐藏，通过封装对外界隐藏对象的实现细节。   

#### 7.继承（inheritance）  

在现存类定义的基础上，建立新定义类的技术。

新类的定义可以是现存类所声明的数据、定义与新类所增加的声明的组合。

新类复用现存类的定义，而不要求修改现存类。

现存类可当作父类（泛化类、基类或超类）来引用，则新类相应地可当作子类（特化类、子女类或派生类）来引用。

- l**继承的传递性**：即一个类实际上继承了它所在的类等级中在它上层的全部基类的所有描述。

- 如果类 C 继承类 B ,类 B 继承类 A ，则类 C 继承类 A 。
- 怎样建立一个好的继承层次
  - 类可以从父类继承，父类又可以从它的父类继承，形成多层次的继承结构。
  - 当增加一个新类时，不一定在最低层，可能需要插在中间层，这样可能需要调整原来的层次结构。

#### 实现继承机制的原理

![image-20220414105358577](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111150.png)

#### 单继承与多继承

![image-20220414105502801](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111151.png)

![image-20220414105508403](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111152.png)

![image-20220414105512615](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111153.png)

![image-20220414105516664](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111154.png)

![image-20220414105527637](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111155.png)

#### 8.多态性（polymorphism）

​    多态性指对象根据所接受的消息而做出动作，同样的消息为不同的对象接受时可导致完全不同的行动。

![image-20220414105539018](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111156.png)

#### 9.重载（overloading）

 有两种重载：

- 函数重载：在同一作用域，若干个参数特征不同的函数可以使用相同的函数名字；
- 运算符重载：同一个运算符可以施加于不同类型的操作数上面。  

重载进一步提高了面向对象系统的灵活性和可读性。









# 面向对象建模——统一建模语言UML



UML 是Unified Modeling Language的缩写。它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。UML聚集了来自下列建模的精髓：

- –数据建模（实体关系图ERD）
- –业务建模 （工作流）
- –对象建模 
- –构件建模

它可用于软件生命周期各个过程，并适用于各种不同的实现技术。

**统一标准**

- 融合了当前一些流行的面向对象开发方法的主要概念和技术，成为一种面向对象的标准化的统一建模语言。
- 提供了标准的面向对象的模型元素的定义和表示法，有标准的语言工具可用。
- 已成为工业标准化组织OMG的正式标准。

**面向对象**

- 支持面向对象的主要概念，提供了一批基本的模型元素的表示图形和方法。

**可视化，表示能力强大**

- 一种图形化语言，系统的逻辑模型和实现模型都能用UML的模型图形清晰地表示。
- 可以处理与软件的说明和文档有关的问题。
- 提供了语言的扩展机制，用户可以根据需要增加定义自己的衍型（StereoType）、标记值和约束等。

- 可用于各种复杂类型的软件系统的建模。

**独立于过程**

- 系统建模语言，独立于开发过程。

**容易掌握使用**

- –概念明确，建模表示法简洁明了，图形结构清晰，容易掌握使用。

- –着重学习三个方面的主要内容：

     (1) UML的基本模型元素

     (2) 组织模型元素的规则

     (3) UML语言的公共机制

**与程序设计语言的关系**

- –用Java，C++ 等编程语言可实现一个系统。
- –一些CASE工具可以根据 UML所建立的系统模型来产生Java、C++ 等代码框架。

#### UML 的目标

UML是一种建模语言，UML 的目标主要是：

- 1、用对象的概念来构造系统模型（不仅是针对软件系统）。
- 2、建立直观的从模型直至可执行体之间的对应关系。
- 3、为复杂的系统建立衡量标准。
- 4、创建一种对人和机器都适合的语言，即可以用人工来描述，又可以用机器实现计算机辅助建模。

#### UML的定义

UML定义有两个组成部分：语义和表示法。

语义用自然语言描述，表示法定义了UML的可视化标准表示符号，这决定了UML是一种可视化的建模语言。

在语义上，模型是元模型的实例。UML定义给出了语法结构的精确定义。

使用UML时，要从不同的角度观察系统，为此定义了概念“视图”。视图是对系统的模型在某方面的投影，注重于系统的某个方面。

#### UML的构成

**UML的三个主要组成元素**

​	1)基本构造块（basic building blocks ）

​	2)组织构造块的规则（rules）

​	3)运用于整个UML的公共机制

 （common mechanisms）

**UML包括三种基本构造块:**

​	1)事物（things）

​	2)关系（relationships）

​	3)图（diagrams）



#### UML 事物 — 结构事物

1. ##### Class（类）

![image-20220414110622022](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110622.png)

2. ##### Interface（接口）

描述了一个类或构件的服务（操作）集。



![image-20220414110646096](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110646.png)

3. ##### Collaboration（协作）

   合作是完成某个特定任务的一组类及其关联的集合，用于对用例的实现建模。

4. ##### Use Case（用例）

   表示系统想要实现的行为，不关心这些行为是怎样实现的。

![image-20220414110709163](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111157.png)

5. ##### Active Class（主动类）

与一般类相同，但它至少拥有一个进程或线程，故能够启动控制活动。



![image-20220414110735554](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110735.png)



6. ##### Component（构件）

系统中物理的、可替代的部件。

![image-20220414110801896](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110802.png)

7. ##### Node（节点）

系统在运行时存在的物理元素。

![image-20220414110817177](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110817.png)



8. ##### Interaction（交互）

- 交互由在特定的上下文环境中共同完成一定任务的一组对象之间传递的消息组成。
- 交互涉及的元素包括消息、动作序列和链。

![image-20220414110842540](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110842.png)

9. ##### State Machine（状态机）

- 状态机描述了一个对象或一个交互在生存周期内响应事件所经历的状态序列。
- 状态机涉及的元素包括状态、转换、事件活动等。

![image-20220414110905360](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110905.png)

10. ##### package（包）

- 包是把元素组织成组的机制，结构事物、行为事物甚至其他分组事物都可以放进包内。
- 包不象构件（仅在运行时存在），它纯粹是概念上的（即它仅在开发时存在）。

![image-20220414110928368](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110928.png)

11. ##### Note（注释）

依附于一个元素或一组元素之上，对其进行约束或解释的简单符号。

![image-20220414110945601](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110945.png)

#### UML Relationships（关系）

**UML中有 4 种关系：**

- 依赖
- 关联
- 泛化
- 实现 

**关系特征：**

- 这四种关系是UML模型中可以包含的基本关系。
- 它们也有变体。例如，依赖的变体有细化、跟踪、包含和延伸。

1. ##### 依赖

- 两个事物之间的语义关系，其中目标事物发生变化会影响源事物的语义。 
- 图中虚线箭头从源事物指向目标事物，表示源事物依赖于目标事物。

![image-20220414111045820](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111045.png)

**两个类之间的依赖关系可以是：**

- 源类访问定义在**目标类内部的数据值**；
- 源类的操作调用了定义在**目标类的操作**；
- 源类的返回类或参数是**目标类的实例**；

如果在顺序图中的两个对象存在消息的传送，而且它们之间没有结构方面的连接，可以在类图上用依赖关系建模。

依赖的变体包含特定的语义，表明类之间的关系、包之间的关系、用例之间的关系、对象之间的关系、建模元素与模型之间的关系等。

**类之间的依赖关系可以是**：

- a.*友元依赖* <<friend>>
  -  目标类（如二叉树）视源类（如迭代器）为友元，允许源类访问目标类的所有私有属性和操作。

![image-20220414111358418](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111358.png)

- b.*导出依赖* <<derive>>
  -  两个类或对象如果存在导出依赖，则表明源类（如年龄）可以从目标类（如出生年月）通过计算导出。

![image-20220414111409788](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111410.png)

- c.*细化依赖* <<refine>>
  -  在类图中表示同一模型的不同详细程度的规格说明，源类比目标类更为详细。

![image-20220414111535087](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111535.png)

- d.*实例化依赖* <<instantiate>>
  -  若要强调一个类的对象是由另一个类的对象创建的，可用实例化依赖。它表明源类创建了目标类的一个实例。

![image-20220414111538999](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111539.png)

- e.*使用依赖* <<use>>
-  不加任何修饰的依赖即为使用依赖。也可用修饰<<use>>强调源类的语义依赖于目标类的具有共有可见性的构成的语义。

![image-20220414111720081](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111720.png)

- f.*绑定（Binding）依赖*
-  这种依赖关系中的目标类是模板类，源类是从模板实例化的类。

![image-20220414111724757](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111724.png)

**包之间的依赖关系可以是：**

- a.*访问依赖* <<access>>
  -  它表明源包被赋予了可访问目标包的权限。

![image-20220414111828094](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111828.png)

- b.*导入依赖* <<import>>
  -  它表明了源包可以访问目标包里的元素，但各个包有自己独立的命名空间，这意味着属于不同包的两个元素可以重名。导入依赖可以使目标包内的公共可见元素进入源包的命名空间。
  - ![image-20220414111839155](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111839.png)

**用例之间的依赖关系可以是：**

- a.*包含依赖* <<include>>
  -  它表明源用例显式地包含目标用例作为其行为的一部分。此时将源用例称为基用例，目标用例称为内含用例。
  -  如果两个用例之间具有包含依赖关系，则表明基用例的动作序列中有特定的步骤把内含用例的动作序列包含进来。

![image-20220414111901322](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111901.png)

- b.*扩展依赖* <<extend>>
  -  它表明源用例扩展了目标用例的行为。此时，源用例称为基用例，目标用例称为扩展用例。扩展用例在特定条件下为基用例提供附加的动态行为。例如，在人机交互过程中出现差错时进行的异常处理即为扩展动作。
  - 扩展依赖与包含依赖的区别在于，如果仅将扩展从基用例地动作序列中去除，基用例仍然是语义完备的，即它的执行仍将产生有意义的结果。而包含依赖则不然。
  - ![image-20220414111933526](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414111933.png)

**对象之间的依赖关系可以是：**

- a.*转换依赖* <<become>>
  -  当需要在交互图上表示对象状态的转换时可以用转换依赖。主要强调由于消息而导致对象状态的改变。转换依赖连接的目标对象和源对象是同一个对象。

- b.*调用依赖* <<call>>
  -  当需要在交互图或对象图上显式强调对象之间或操作之间的调用关系时要用调用依赖。它表明源对象引用了目标对象的操作，或源操作引用了目标操作。

- c.*复制依赖* <<copy>>
  -  为了在交互图或活动图上描述对象复制的动作可以采用复制依赖。它连接两个对象，目标对象是源对象的完全相同而又独立的副本。
- d.*发送依赖* <<send>>
  -  它连接一个对象（在源端）和一个消息（在目标端），表明源对象在交互过程中发送了一个消息，可以用在状态机的描述中。
  -  它针对内嵌有状态机的对象，可用来描述如何通过发送信号以产生某种事件的动作。

**建模元素与模型之间的依赖关系是：**

- a.*回溯依赖* <<trace>>
  -  它连接两个模型元素，表明目标是源的历史上的前驱。如交互和协作就是从用例导出的。

2. ##### 关联

- 关联是一种结构关系，它描述一组链，这些链是类之间或类与接口之间的连接。通过这种连接，一个对象可以访问另一个对象的属性或调用另一个对象的操作。
- 关联是双向的，关联两头的类都以某种角色参与关联．

![image-20220414112619249](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414112619.png)

- **聚合**（aggregation）是一种特殊类型的关联，它描述了整体和部分间的结构关系。
  - 聚合关系在整体端有一个菱形作为标记。
  - **复合聚合**（composite aggregate） 是一种特殊的聚合关系，它表明整体对象与部分对象具有相同的生存周期。
    - ![image-20220414113720166](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414113720.png)
  - **角色的重复度（Multiplicity）**
    - 表明角色在关联关系中出现的次数。如1，0..1，1..*，*等。
  - **导航（navigation）**
    - 一般默认关联关系是双向的，而导航则限制关联关系到一个方向。在图中用箭头指明方向。
    - ![image-20220414113824656](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414113824.png)
  - **限定关联（qualification）**
    - 如教师与学生的关系由课程的标识决定。
    - ![image-20220414113847364](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414113847.png)
  - **关联类**
    - 关联关系是两个类之间的语义连接。在比较简单的情况下，关联关系的语义用关联关系的名字来概括。但在某些情况下，需要对关联关系的语义做详细的定义、存储和访问，为此可以建立关联类，描述关联的属性。
    - ![image-20220414113927127](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414113927.png)

3. ##### 泛化

- 一般化─特殊化的关系（继承）。表明特化类共享一个或多个泛化类的结构和行为。
- 如果两个类被定义为具有泛化关系，就意味着在任何泛化类（父类）的对象出现的地方，都可以用特化类（子类）来代替。

![image-20220414114028035](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414114028.png)

- 继承的多态性表明子类的操作的动态行为可代替父类的同名操作的动态行为。
- 泛化关系的变体：实现继承。它规定其中的子类可继承其父类的结构和行为，但其可见性成为私有，也不支持父类的接口。

4. ##### 实现（Realization）

- 类之间的语义关系，其中的一个类元指定了由另一个类保证执行的契约。

- 两种情况出现实现关系：

     1）在接口和实现它们的类或构件之间；

     2）在用例和它们的协作之间。

  ![image-20220414114252304](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414114252.png)

####  **模型中主要的图形元素**

![image-20220414114324322](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414114324.png)

### UML模型的图形

![image-20220414114354502](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414114354.png)

#### UML图的作用

UML 图可以用于:

- 使用用例（use cases）和参与者（actors）描述系统的边界和它的主要功能。
- 使用交互图（顺序图、协作图）具体描述用例的实现。
- 使用活动图描述多用例或多线程的复杂行为
- 使用类图表示系统的静态结构。 
- 使用状态转换图模型化对象的行为。
- 使用构件图和部署图展现系统的物理实现体系结构。

> #### UML工作的实例
>
> 某大学用计算机管理的注册（registration）系统
>
> 注册管理员设置一个学期的所有课程信息
>
> 一个课程可以有多个课程选课单。
>
> 学生选择4门主修课和2门选修课
>
> 当某学生在学期注册了，则记账（billing）系统会得到通知，在该学期给该学生开设账号。
>
> 学生在注册后一段时间可以使用系统增加/撤销所选课程。
>
> 教授使用这个系统接受他们课程的选课名册。
>
> 注册系统的用户将得到密码（password），用于登录的确认。

#### 用例图（use case diagram）

用例图展现了一组用例、参与者（Actor）以及它们之间的关系。

用例图通常包括用例、参与者和扩展关系、包含关系等。

用例图的功能是支持系统的行为，即该系统在它的上下文环境中所提供的外部可见服务。

用例图的两种使用方式：

- **上下文环境建模**：说明位于系统之外并与系统进行交互的参与者以及他们所扮演的角色的含义。
- **功能需求建模**：说明系统想要的行为。 

##### 参与者（Actors）

- 参与者定义了一组与系统有信息交互关系的人、事、物。它是用例的客户并与用例进行交互。一个参与者针对每一个与之通信的用例扮演一种角色。
- 角色可以是人或外部系统。它定义了系统的边界。
- ![image-20220414115026995](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115027.png)

##### 用例（Use Cases）

一个用例是一种系统应表现行为的模式:

- 每个用例是一个参与者与系统在一次对话中所执行的相关事务的序列。 

> 要调查参与者以确定他们的要求：
>
> Registrar（注册管理员）－ 维护所有课程信息
>
> Professor（教授）－ 要求选课名单
>
> Student（学生）－ 维护选课表
>
> Billing System（记账系统）－ 从注册中心接受记账信息

![image-20220414115257314](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115257.png)

##### 用例的规格说明

为每个用例建立一个规格说明，描述用例的事件流（flow of event）。

- 从参与者角度编写

它包含在用例执行时系统必须为参与者提供的各种细节。

典型的内容有

- 用例如何开始和结束
- 基本的事件流
- 候补的事件流
- 异常的事件流

> **维护所有课程信息的事件流**
>
> ![image-20220414115644347](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115644.png)
>
> ![image-20220414115753609](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115753.png)
>
> ![image-20220414115759966](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115800.png)
>
> ![image-20220414115809762](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115809.png)
>
> ![image-20220414115957625](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414115957.png)
>
> ![image-20220414120101205](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414120101.png)

#### 交互图 — 用例的实现 

- 用例图描述了系统的外部视图。
- 交互图则描述了如何通过对象之间的交互实现用例。
- 交互图展现了按一定的目的进行的一种交互，它由在一个上下文中的一组对象及它们之间交互的信息组成。

交互图有两种类型：

- **顺序图**（Sequence diagram）
- **协作图**（Collaboration diagram）

##### 顺序图（Sequence Diagram）

顺序图也称为序列图，它按时间顺序显示对象之间的交互。

![image-20220414120240000](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414120240.png)

> ![image-20220414120439249](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414120439.png)
>
> ![image-20220414120606180](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414120606.png)

- 顺序图展现了一组对象和由这组对象收发的消息，用于按时间顺序对控制流建模。
- 对象表述为虚垂线顶端的矩形框。这些对象都排列在图的顶部，其生命线从图的顶部画到图的底部。
- 垂线是对象的生命线，说明对象在一段时间内存在。
- 对象可以在交互过程中创建，在交互过程中撤销。
- 生命线之间的箭头表示消息。消息出现的次序自上而下。
- 消息箭头可以回到同一条生命线，指明自调用，即对象发给自己的消息。

- 顺序图的控制焦点是一个瘦高的矩形，表示一个对象执行一个动作所经历的时间段。矩形的顶部表示动作的开始，底部表示动作的结束（可以由一个返回消息来标记）。

**顺序图的构造步骤**：

​	==a)首先，把参加交互的对象放在图的上方，横向排列。通常把发起交互的对象放在左边，较下级对象依次放在右边。==

​	==b)然后，把这些对象发送和接收的消息纵向按时间顺序从上到下放置。==

​	==c)这样，就提供了控制流随时间推移的清晰的可视化轨迹。==

> ![image-20220414120844893](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414120845.png)

**边界类**  

- 是直接与系统外部实体交互的类，描述系统与外部（人或其他系统）的接口建模，其原型为<<boundary>>。

**控制类**  

- 是为特定用例的控制行为建模的类，协调特定于用例的行为所需的事件，其原型为<<control>>。

**实体类**  

- 是用来保存或更新某个对象的信息的类，独立于它的环境。原型为<<entity>>。

![image-20220414121026011](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414121026.png)



#### 协作图（Collaboration Diagram）

协作图也称为合作图，它显示了对象与周围对象之间的交互，以及它们之间的链接



![image-20220419104821076](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419104828.png)

- 协作图展现了<u>一组对象，这组对象之间的连接</u>以及<u>这组对象收发的消息</u>。
- 协作图中的协作<u>不是参与者与系统之间的交互</u>，而是<u>系统内部某一个用例中各个对象之间信息传递的方式。</u>
- 消息上所附**编号**指明执行顺序。
- **协作图的构造步骤：**
  - a)将参加交互的**对象**作为图的顶点。
  - b)将连接这些对象的**链**表示为图的弧。
  - c)用对象发送和接收的**消息**修饰这些链。
- 协作图提供了在协作对象的结构组织的上下文环境中观察控制流的一个清晰的可视化轨迹。

> ![image-20220419104903916](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419104904.png)
>



#### 类图（class diagram）

- **类图从系统的逻辑视图展现了一组类、接口、协作和它们之间的关系。**
- 类图给出系统的静态设计视图，主动类的类图给出了系统的静态进程视图。
- **在类图中UML建模元素包括：**
  - 类及其结构和行为；
  - 接口；
  - 协作；
  - 关联、依赖、泛化关系；
  - 多重性和导航指示符；
  - 角色名字。

##### 类（Class）

- 类是具有共同结构、共同行为、共同关系和共同语义的对象的集合。
- 通过检查在顺序图和协作图中的对象可以发现类。
- 一个类用间隔为三部分的矩形描绘。
- 类应当使用领域的术语来命名：
  - 应建立命名的标准
  - 例如，所有的类都是以大写字母开头的单一名词

> ##### 类的事例
>
> ![image-20220419105322475](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419105322.png)
>

##### 操作（Operations）

- 一个类的行为通过类的各种操作来表达。
- 这些操作可以通过检查交互图来寻找。

![image-20220419105404407](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419105404.png)

##### 属性（Attributes）

- 一个类的结构通过它的属性来表达。
- 通过检查类的定义、问题的需求，并参照领域知识来发现属性。

![image-20220419105551685](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419105551.png)

> ##### 类的事例
>
> ![image-20220419105650425](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419105650.png)



##### 寻找关系

通过检查交互图，以发现关系

- 如果两个对象必须打交道，一定存在沟通的路径。

![image-20220419105832324](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419105832.png)

> ##### 关系的事例
>
> ![image-20220419105859821](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419105900.png)
>
> ##### 多重性和导航的事例
>
> ![image-20220419110034284](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419110034.png)
>
> ##### 泛化（继承）的事例
>
> ![image-20220419110132228](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419110132.png)

##### 对象图（Object Diagram）

- 对象图展现了一组对象以及它们之间的关系。用以详述、构造和文档化系统中存在的实例以及它们之间的相互关系。
- 对象图给出系统的静态设计视图或静态进程视图，和类图一样。描述了在类图中所建立的事物的**实例的静态快照**。
- 对象图一般包括**对象和链**。
- 这种视图主要支持系统的功能需求，即系统应该提供给最终用户的服务。因而它也用于表示交互图表示的**动态场景的一个静态画面**。

> ##### 对象图的事例
>
> ![image-20220419110313973](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419110314.png)

##### 状态迁移图（ State Transition Diagram ）

- **状态是在对象生存周期中的一个位置**。在此位置满足某种条件，执行某种活动或等待某个事件。
- 状态迁移图展现了一个状态机，它由状态、转移、事件和活动组成。
- 状态迁移图显示了： 
  - **一个给定类的生存史；**
  - **导致状态转移的一系列事件；**
  - **产生状态变化的一系列活动；**
- 状态图关注系统的动态视图。

> ##### 状态迁移图的事例
>
> ![image-20220419110705467](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419110705.png)
>
> ##### AＴＭ机 状态图
>
> ![image-20220419110818984](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419110819.png)
>
> ##### 打电话状态图
>
> ![image-20220419110957868](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419110958.png)
>
> ##### 电话状态图
>
> ![image-20220419111010908](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419111011.png)

##### 活动图（Activity Diagram）

- **一个活动是一个在状态机内部正在进行的非原子（即可中断的）动作。** 
- 活动图是一种特殊的状态图。其中，
  - 大多数的或者全部的状态都是动作状态或者活动状态
  - 大多数的或者全部的迁移都是由于源状态中活动的完成而被触发的。
- 一个活动图着重于描述计算过程或工作流的顺序的和并发的执行步骤。

> ![image-20220419111146576](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419111146.png)

###### 活动图的两种使用方式

![image-20220419111408031](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419111408.png)

##### 泳道（swimlanes）

- 活动图描述发生了什么，但没有说明该活动由谁来完成。泳道描述了这种关系。
- 泳道用矩形框表示，属于某个泳道的活动放在该矩形框内，将对象名放在矩形框的顶部，表示泳道中的活动由该对象负责。
- 两个泳道中的活动由各自不同的对象负责，活动之间控制权的**转移表明对象之间的协作关系。**
- 所以**泳道可以将活动图的逻辑描述与顺序图、协作图的责任描述结合起来。**

> ![image-20220419111610037](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419111610.png)
>
> ![image-20220419111838643](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419111838.png)

##### 构件图（ Component diagram）

- 构件图展现了一组**构件之间的组织和依赖**。
- 构件图专注于系统的**静态实现视图**。它与类图相关，通常把构件映射为一个或多个**类、接口或协作。** 
- 一个构件可能是：
  - **部署构件**：如动态链接库(DLL)、二进制可执行构件、ActiveX控件、JavaBeans等，是形成可执行文件的基础。
  - **工作产品构件**：如数据文件或源代码。是部署构件的来源。
  - **执行构件**：可运行的构件

> ##### 构件图的事例
>
> ![image-20220419112119030](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419112119.png)

##### 接口（interface）

- **接口是一个类或构件提供给其他类或构件的一组操作。**类的变体，其变体关键字是`<<interface>>`。
- 每个接口要指定一个名字，以区分不同的接口。接口的名字就是类的名字，用字符串表示。
- 构件的接口有两种类型：
  - **导入接口**（import interface）：访问服务的构件使用导入接口；
  - **导出接口**（export interface）：由提供操作的构件提供。

##### 部署图（Deployment Diagram）

- **部署图展现了在软件过程中存在的运行处理节点以及其中的构件的配置**。
- 部署图给出了体系结构的**静态实施视图**。它描述系统硬件的物理拓扑结构（包括网络布局和构件在网络上的位置），以及在此结构上执行的软件（即运行时软构件在节点中的分布情况）。
- 它与构件图相关，通常一个节点包含一个或多个构件。

> ##### 部署图的事例
>
> ![image-20220419112656440](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419112656.png)

- **部署图(deployment diagram)定义系统中软硬件的物理体系结构。**

> ![image-20220419112856408](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419112856.png)

### UML的规则

- 命名 (names)
  - 为事物、关系和图起名。如：“student”、“PersonInfo::student”
- 作用域 (scope)
  - 把施于类而不是施于实例的操作和属性说明为类作用域。相当于C++静态变量。

![image-20220419113339943](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419113340.png)

- 可见性 (visibility)
  - 对类中任一属性或操作定义存取权限。
  - 加前缀：+ (公用)、- (私用)、# (保护)
- 完整性 (integrity)
  - 保持事物之间联系的正确性和一致性。
  - 单个模型是不充分的，应建立互补的连锁的模型，从整体描述软件的蓝图。
  - 保持模型与现实的一致性。
- 执行 (execution)
  - 通过运行或模拟动态模型，才能真正理解和领会程序代码的含义是什么。

### UML的公共机制

- 规格说明 (specifications)
  - UML的图形表示用来对系统进行可视化，UML的规格说明用来描述系统的细节。
  - 规格说明提供了对构造块的语法和语义的文字叙述。
  - 在增量式建模中，可有两种方式：
    1. 先画图，再增加语义到它的规格说明中；
    2. 先创建规格说明，或对已完成的系统执行逆向工程，创建这些规格说明的投影图。

- 修饰
  - ![image-20220419114216739](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114217.png)

- 通用划分
  - ![image-20220419114231263](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114231.png)

- 扩展机制
  - ![image-20220419114249333](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114249.png)
  - ![image-20220419114259464](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114259.png)
  - ![image-20220419114328620](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114328.png)
  - ![image-20220419114452639](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114452.png)

### UML主要内容

![image-20220419114803409](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114803.png)



## 9.4 对象模型

- 描述系统内部对象的**静态结构**，包括对象本身的定义、对象的属性和操作、以及对象与其它对象之间的关系。
- UML 中，对象模型通常由“类图”组成。

## 9.5 动态模型

- 状态图描述对象可能的**状态及其转换**，关心对象在某过程中的经历。
- 生命周期中的阶段也就是对象的状态。
- 一个触发行为称为一个事件.
- **状态**有持续性，它占用**一段时间间隔**。
- **事件**表示时刻，状态代表时间间隔。
- 通过状态图来描绘对象的**状态、触发状态转换**的事件以及**对象的行为**。

> ![image-20220419114937554](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419114937.png)

## 9.6 功能模型

- 功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，因此更直接地反映了用户对目标系统的需求。
- 功能模型由一组**数据流图或用例图组成**。
- 在UML中把用用例图建立起来的系统模型称为**用例模型**。
- 用例模型描述的是外部行为者(actor）所理解的系统功能。是其他视图的核心和基础。

> ![image-20220419115027548](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220419115027.png)
>



## 9.7 3种模型之间的关系

### 三种模型

- **对象模型** <u>定义了做事情的实体</u>,描述了动态模型、功能模型所操作的数据结构。对象模型中的操作对应于动态模型中事件和功能模型中的函数。
- **动态模型** 描述了对象的控制结构，它明确<u>规定了什么时候(即在何种状态下接受了什么事件触发)做;。</u>
- **功能模型** <u>指明了系统应该”做什么”</u>，由数据流图和用例图组成，描述了对象模型中操作的含义、动态模型中动作的意义以及对象模型中约束的意义。

### 关系

- 功能模型中的**处理（或用例**）对应于对象模型中的类所提供的服务。有时一个处理（或用例）对应多个**服务**，也有一个服务对应多个处理（或用例）的时候。
- 数据流图中的**数据存储**，以及**数据的源点/终点**，通常是对象模型中的**对象**。
- 数据流图中的**数据流**，往往是对象模型中对象的**属性值**，也可能是整个对象。
- 用例图中的**行为者**，可能是对象模型中的**对象**。
- 功能模型中的**处理（或用例）**可能产生动态模型中的**事件**。
- 对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点的结构。











































































# 第10章  面向对象分析

在面向对象分析中，主要由**对象模型、动态模型和功能模型**组成。

面向对象分析(OOA)的关键是识别出问题域内的**类**与**对象**，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型。在用面向对象观点建立起的3种模型中，**对象模型是最基本、最重要、最核心的**。

## 10.1 面向对象分析的基本过程

### 10.1.1.概述

​    面向对象分析，就是**抽取和整理用户需求**并**建立问题域精确模型的过程**。

- 面向对象分析过程从**分析陈述用户需求的文件**开始。
- 接下来，系统分析员应该深入理解用户需求，**抽象出目标系统的本质属性，并用模型准确地表示出来。**
- 在面向对象建模的过程中，系统分析员必须认真**向领域专家**学习。
- 在面向对象建模的过程中，还应该**仔细研究以前针对相同的或类似的问题域**进行面向对象分析所得到的结果（可重用）。

### 10.1.2.  3个模型与5个层次

在面向对象分析中，主要由对象模型、动态模型和功能模型组成。**对象模型是最基本、最重要、最核心的。**

正如9.3节所述，面向对象建模得到的模型包含系统的3个要素，即**静态结构**(对象模型)、**交互次序**(动态模型)**和数据变换**(功能模型)。解决的问题不同，这3个子模型的重要程度也不同。

![image-20220414105924858](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414105925.png)

​    在本书第9章中已经讲述了类与对象、结构、属性和服务的概念，现在再简要地介绍一下主题的概念。

主题是指导读者理解大型、复杂模型的一种机制。也就是说，通过划分主题把一个大型、复杂的对象模型分解成几个不同的概念范畴。

![image-20220414105934553](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414105934.png)

![image-20220414105954581](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414105954.png)

![image-20220414105958834](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414105958.png)

## 10.2 需求陈述

### 10.2.1. 书写要点

需求陈述应该阐明“**做什么**”而不是“怎样做”！

- 应该描**述用户的需求**而不是提出解决问题的方法。
- 应该指出哪些是系统必要的性质，哪些是任选的性质。
- 应该避免对设计策略施加过多的约束，也不要描述系统的内部结构，因为这样做将限制实现的灵活性。
- 对**系统性能**及系统与**外界环境交互协议进行描述**。
- 对采用的软件工程标准、模块构造准则、将来可能做的扩充以及可维护性要求等方面进行描述。

- 书写需求陈述时，要尽力做到语法正确，而且应该慎重选用名词、动词、形容词和同义词。
- 系统分析员**必须把需求与实现策略区分开**。
- 应该看到，需求陈述仅仅是理解用户需求的出发点，它并不是一成不变的文档。
- 系统分析员必须与用户及领域专家密切配合协同工作，共同提炼和整理用户需求。

### 10.2.2. 例子

![image-20220414110038359](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220414110038.png)

某银行拟开发一个自动取款机系统，它是一个由**自动取款机**、**中央计算机**、**分行计算机**及**柜员终端**组成的网络系统。ATM和中央计算机由总行投资购买。总行拥有多台ATM，分别设在全市各主要街道上。分行负责提供分行计算机和柜员终端。柜员终端设在分行营业厅及分行下属的各个储蓄所内。该系统的软件开发成本由各个分行分摊。

#### 1.储户和柜员交互

银行柜员使用柜员终端处理储户提交的储蓄事务。

- **储户**可以用现金或支票向自己**拥有**的某个**账户**内**存款**或**开新账户**，也可以从自己的账户中**取款**。
- **柜员**负责把储户提交的**存款或取款事务输进柜员终端**。
- **柜员终端**与相应的**分行计算机**通信，**分行计算机**具体**处理**针对某个**账户的事务并且维护账户**。

**接收**储户交来的现金或支票，或**付给**储户现金。

#### 2.储户和ATM交互

- 首先，ATM要求用户输入密码。
- 接下来ATM把从这张卡上读到的信息以及用户输入的密码传给中央计算机，请求中央计算机核对这些信息并处理这次事务。
- 中央计算机根据卡上的分行代码确定这次事务与分行的对应关系，并且委托相应的分行计算机验证用户密码。
- 用户输入的密码是正确的，ATM就要求用户选择事务类型(取款、查询等)。当用户选择取款时，ATM请求用户输入取款额。
- 最后，ATM从现金出口吐出现金，并且打印出账单交给用户。

## 10.3 建立对象模型

面向对象分析首要的工作，是**建立问题域的对象模型**。

这个模型描述了现实世界中的“**类与对象**”以及它们之间的关系，表示了目标系统的静态数据结构。静态数据结构对应用细节依赖较少，比较容易确定。因此，用面向对象方法开发绝大多数软件时，都首先建立对象模型，然后再建立另外两个子模型。

需求陈述、应用领域的专业知识以及关于客观世界的常识，**是建立对象模型时的主要信息来源**。

对象模型通常有5个层次。典型的工作步骤是：

- l首先确定**对象类和关联**(因为它们影响系统整体结构和解决问题的方法)，对于大型复杂问题还要进一步划分出若干个**主题**；
- l然后给类和关联增添**属性**，以进一步描述它们；
- l接下来利用适当的**继承**关系进一步合并和**组织类**。
- l而对类中**操作**的最后确定，则需等到建立了动态模型和功能模型之后，因为这两个子模型更准确地描述了对类中提供的服务的需求。

### 10.3.1. 确定类与对象

类与对象是在问题域中客观存在的，系统分析员的主要任务就是通过分析找出这些类与对象。

- l首先找出所有候选的类与对象；
- l然后从候选的类与对象中筛选掉不正确的或不必要的。

#### 1. 找出候选的类与对象

##### 正式分析方法

​    对象是对问题域中有意义的事物的抽象，它们既可能是物理实体，也可能是抽象概念。具体地说，大多数客观事物可分为下述5类。

​	(1) 可感知的**物理实体**，

> 例如，飞机、汽车、书、房屋等。

​	(2) 人或组织的**角色**，

> 例如，医生、教师、雇主、雇员、计算机系、财务处等。

​	(3) 应该记忆的**事件**，

> 例如，飞行、演出、访问、交通事故等。

​	(4) 两个或多个**对象的相互作用**，通常具有交易或接触的性质，

> 例如，购买、纳税、结婚等。

​	(5) 需要说明的**概念**，

> 例如，政策、保险政策、版权法等。

##### 非正式分析

另一种更简单的分析方法称为自然语言分析法

- 用自然语言书写的需求陈述为依据，
- 把陈述中的**名词**作为类与对象的候选者，
- 用**形容词**作为确定属性的线索，
- 把**动词**作为服务(操作)的候选者。

**自然语言分析法**：利用短语频率分析法识别模型成分的启发式准则，将语言成分映射为模型成分。

![image-20220426112447501](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426112447.png)

> 下面以ATM系统为例，说明非正式分析过程。
>
> 认真阅读10.2.2节给出的需求陈述，确定类与对象的初步的候选者：
>
> `银行，自动取款机(ATM)，系统，中央计算机，分行计算机，柜员终端，网络，总行，分行，软件，成本，市，街道，营业厅，储蓄所，柜员，储户，现金，支票，账户，事务，现金兑换卡，余额，磁卡，分行代码，卡号，用户，副本，信息，密码，类型，取款额，账单，访问。`
>
> 根据领域知识或常识进一步把隐含的类与对象提取出来。
>
> 例如，在ATM系统的需求陈述中虽然没写“**通信链路**”和“**事务日志**”，但是，根据领域知识和常识可以知道，在ATM系统中应该包含这两个实体。

#### 2.筛选出正确的类与对象

显然，仅通过一个简单、机械的过程不可能正确地完成分析工作。非正式分析仅仅帮助人们找到一些候选的类与对象，接下来应该严格考察每个候选对象，从中去掉不正确的或不必要的，仅保留确实应该记录其信息或需要其提供服务的那些对象。

筛选时主要依据下列标准，删除不正确或不必要的类与对象。

##### （1）冗余

如果两个类表达了同样的信息，则应该保留在此问题域中最富于描述力的名称。

>  例如ATM系统，其中储户与用户，现金兑换卡与磁卡及副本分别描述了相同的两类信息，因此，应该去掉“**用户**”、“**磁卡**”、“**副本**”等冗余的类，仅保留“**储户**”和“**现金兑换卡**”这两个类。

##### （2）无关

现实世界中存在许多对象，不能把它们都纳入到系统中去，仅需要把与本问题密切相关的类与对象放进目标系统中。有些类在其他问题中可能很重要，但与当前要解决的问题无关，同样也应该把它们删掉。

>  以ATM系统为例，这个系统并不处理分摊软件开发成本的问题，而且ATM和柜员终端放置的地点与本软件的关系也不大。因此，应该去掉候选类“**成本**”、“**市**”、“**街道**”、“**营业厅**”和“**储蓄所**”。

##### （3）笼统

在需求陈述中常常使用一些笼统的、泛指的名词，虽然在初步分析时把它们作为候选的类与对象列出来了，但是，要么系统无须记忆有关它们的信息，要么在需求陈述中有更明确更具体的名词对应它们所暗示的事务，因此，通常把这些笼统的或模糊的类去掉。

>  以ATM系统为例，“**银行**”实际指总行或分行，“**访问**”在这里实际指事务，“**信息**”的具体内容在需求陈述中随后就指明了。总之，在本例中应该去掉“**银行**”、“**网络**”、“**系统**”、“**软件**”、“**信息**”、“**访问**”等候选类。

##### （4）属性

在需求陈述中有些名词实际上描述的是其他对象的属性，应该把这些名词从候选类与对象中去掉。当然，如果某个性质具有很强的独立性，则应把它作为类而不是作为属性。

> 以ATM系统为例，“**现金**”、“**支票**”、“**取款额**”、“**账单**”、“**余额**”、“**分行代码**”、“**卡号**”、“**密码**”、“**类型**”等，实际上都应该作为属性对待。

##### （5）操作

在需求陈述中有时可能使用一些既可作为名词，又可作为动词的词，应该慎重考虑它们在本问题中的含义，以便正确地决定把它们作为类还是作为类中定义的操作。

> 例如，谈到电话时通常把“**拨号**”当作动词，当构造电话模型时确实应该把它作为一个操作，而不是一个类。但是，在开发电话的自动记账系统时，“**拨号**”需要有自己的属性(例如**日期、时间、受话地点等**)，因此应该把它作为一个类。

##### （6）实现

在分析阶段不应该过早地考虑怎样实现目标系统。因此，应该去掉仅和实现有关的候选的类与对象。在设计和实现阶段，这些类与对象可能是重要的，但在分析阶段过早地考虑它们反而会分散人们的注意力。

> 在ATM系统的例子中，“**事务日志**”无非是对一系列事务的记录，它的确切表示方式是面向对象设计的议题；“**通信链路**”在逻辑上是一种联系，在系统实现时它是关联类的物理实现。总之，应该暂时去掉 “**事务日志**”和“**通信链路**”这两个类，在设计或实现时再考虑它们。

### 10.3.2. 确定关联

两个或多个对象之间的相互依赖、相互作用的关系就是关联。

#### 1.初步确定关联

- 在初步确定关联时，大多数关联可以通过直接提取需求陈述中的动词词组而得出。
- 通过分析需求陈述，还能发现一些在陈述中隐含的关联。
- 最后，分析员还应该与用户及领域专家讨论问题域实体间的相互依赖、相互作用关系，根据领域知识再进一步补充一些关联。

> 以ATM系统为例。
>
> (1) 直接提取动词短语得出的关联
>
> 1. ATM、中央计算机、分行计算机及柜员终端组成网络。
> 2. 总行拥有多台ATM。
> 3. ATM设在主要街道上。
> 4. 分行提供分行计算机和柜员终端。
> 5. 柜员终端设在分行营业厅及储蓄所内。
> 6. 分行分摊软件开发成本。
> 7. 储户拥有账户。
> 8. 分行计算机处理针对账户的事务。
> 9. 分行计算机维护账户。
> 10.  柜员终端与分行计算机通信。
> 11.  柜员输入针对账户的事务。
> 12.  ATM与中央计算机交换关于事务的信息。
> 13.  中央计算机确定事务与分行的对应关系。
> 14.  ATM读现金兑换卡。
> 15.  ATM与用户交互。
> 16.  ATM吐出现金。
> 17.  ATM打印账单。
> 18.  系统处理并发的访问。
>
> (2) 需求陈述中隐含的关联
>
> 1. 总行由各个分行组成。
> 2. 分行保管账户。
> 3. 总行拥有中央计算机。
> 4. 系统维护事务日志。
> 5. 系统提供必要的安全性。
> 6. 储户拥有现金兑换卡。
>
> (3) 根据问题域知识得出的关联
>
> 1. 现金兑换卡访问账户。
> 2. 分行雇用柜员。

#### 2.筛选

经初步分析得出的关联只能作为候选的关联，还需经过进一步筛选，以去掉不正确的或不必要的关联。

筛选时主要根据下述标准删除候选的关联。

##### (1)已删去的类之间的关联

- 如果在分析确定类与对象的过程中已经删掉了某个候选类，则与这个类有关的关联也应该删去，或用其他类重新表达这个关联。

> 以ATM系统为例，由于已经删去了“系统”、“网络”、“市”、“街道”、“成本”、“软件”、“事务日志”、“现金”、“营业厅”、“储蓄所”、“账单”等候选类，因此与这些类有关的下列8个关联也应该删去。
>
> ①ATM、中央计算机、分行计算机及柜员终端组成网络。
>
> ②ATM设在主要街道上。
>
> ③分行分摊软件开发成本。
>
> ④系统提供必要的安全性。
>
> ⑤系统维护事务日志。
>
> ⑥ATM吐出现金。
>
> ⑦ATM打印账单。
>
> ⑧柜员终端设在分行营业厅及储蓄所内。

##### (2)与问题无关的或应在实现阶段考虑的关联

应该把处在本问题域之外的关联或与实现密切相关的关联删去。

> 例如，在ATM系统的例子中，“系统处理并发的访问”并没有标明对象之间的新关联，它只不过提醒人们在实现阶段需要使用实现并发访问的算法，以处理并发事务。

##### (3)瞬时事件

关联应该描述问题域的静态结构，而不应该是一个瞬时事件。

> 以ATM系统为例，“ATM读现金兑换卡”描述了ATM与用户交互周期中的一个动作，它并不是ATM与现金兑换卡之间的固有关系，因此应该删去。类似地，还应该删去“ATM与用户交互”这个候选的关联。

如果用动作表述的需求隐含了问题域的某种基本结构，则应该用适当的动词词组重新表示这个关联。

> 例如，在ATM系统的需求陈述中，“中央计算机确定事务与分行的对应关系”隐含了结构上“中央计算机与分行通信”的关系。

##### (4)三元关联

三个或三个以上对象之间的关联，大多可以分解为二元关联或用词组描述成限定的关联。

> 在ATM系统的例子中，
>
> - “柜员输入针对账户的事务”可以分解成“柜员输入事务”和“事务修改账户”这样两个二元关联。而且“分行计算机处理针对账户的事务”也可以做类似的分解。
> - “ATM与中央计算机交换关于事务的信息”这个候选的关联，实际上隐含了“ATM与中央计算机通信”和“在ATM上输入事务”这两个二元关联。

##### (5)派生关联

应该去掉那些可以用其他关联定义的冗余关联。

> 在ATM系统的例子中，
> “总行拥有多台ATM”实质上是“总行拥有中央计算机”和“ATM与中央计算机通信”这两个关联组合的结果。
> 而“分行计算机维护账户”的实际含义是“分行保管账户”和“事务修改账户”。

#### 3. 进一步完善

应该进一步完善经筛选后余下的关联。

通常从下述几个方面进行改进 

##### (1)正名

好的名字是帮助读者理解的关键因素之一。因此，应该仔细选择含义更明确的名字作为关联名。

> 例如，“分行提供分行计算机和柜员终端”不如改为“分行拥有分行计算机”和“分行拥有柜员终端”。

##### (2)分解

为了能够适用于不同的关联，必要时应该分解以前确定的类与对象。

> 例如，在ATM系统中，应该把“事务”分解成“远程事务”和“柜员事务”。

##### (3)补充

发现了遗漏的关联就应该及时补上。

> 例如，在ATM系统中把“事务”分解成上述两类之后，需要补充“柜员输入柜员事务”、“柜员事务输进柜员终端”、“在ATM上输入远程事务”和“远程事务由现金兑换卡授权”等关联。

##### (4)表明重数

应该初步判定各个关联的类型，并粗略地确定关联的重数。但是，无须为此花费过多精力，因为在分析过程中随着认识的逐渐深入，重数也会经常改动。

![image-20220426121118391](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220426121118.png)

### 10.3.3.划分主题 

在开发大型、复杂系统的过程中，为了降低复杂程度，人们习惯于把系统再进一步划分成几个不同的主题，也就是在概念上把系统包含的内容分解成若干个范畴。

- 在开发很小的系统时，可能根本无须引入主题层；
- 对于含有较多对象的系统，则往往先识别出类与对象和关联，然后划分主题，并用它作为指导开发者和用户观察整个模型的一种机制；
- 对于规模极大的系统，则首先由高级分析员粗略地识别对象和关联，然后初步划分主题，经进一步分析，对系统结构有更深入的了解之后，再进一步修改和精炼主题。

应该按问题领域而不是用功能分解方法来确定主题。此外，应该按照使不同主题内的对象相互间**依赖和交互最少的原则**来确定主题。

> 以ATM系统为例，可以把它划分成
>
> - **总行**（包含总行和中央计算机这两个类）
> - **分行**（包含分行、分行计算机、柜员终端、柜员事务、柜员和账户等类）
> - **ATM**（包含ATM、远程事务、现金兑换卡和储户等类）等3个主题。
>
> 事实上，这里描述的是一个简化的ATM系统，为了简单起见，在下面讨论这个例子时将忽略主题层。

### 10.3.4.确定属性 

**属性**是对象的性质，藉助于属性人们能对类与对象和结构有更深入更具体的认识。注意，在分析阶段不要用属性来表示对象间的关系，使用关联能够表示两个对象间的任何关系，而且把关系表示得更清晰、更醒目。
一般说来，确定属性的过程包括**分析**和**选择**两个步骤。

#### 1.分析

- 通常，在需求陈述中用名词词组表示属性

  > 例如，“汽车的颜色”或“光标的位置”。

- 往往用形容词表示可枚举的具体属性

  > 例如，“红色的”、“打开的”。

但是，不可能在需求陈述中找到所有属性，分析员还必须藉助于**领域知识和常识**才能分析得出需要的属性。幸运的是，属性对问题域的基本结构影响很小。随着时间的推移，问题域中的类始终保持稳定，属性却可能改变了，相应地，类中方法的复杂程度也将改变。

**属性的确定**既与问题域有关，也和目标系统的任务有关。

- 应该仅考虑与具体应用**直接相关的属性**，不要考虑那些超出所要解决的问题范围的属性。
- 在分析过程中应该首先找出最重要的属性，以后再逐渐把其余属性增添进去。
- 在分析阶段不要考虑那些纯粹用于实现的属性。

#### 2.选择

认真考察经初步分析而确定下来的那些属性，从中删掉不正确的或不必要的属性。通常有以下几种常见情况:

##### (1) 误把对象当作属性

如果某个实体的独立存在比它的值更重要，则应把它作为一个对象而不是对象的属性。在具体应用领域中具有自身性质的实体，必然是对象。同一个实体在不同应用领域中，到底应该作为对象还是属性，需要具体分析才能确定。

> 例如，在邮政目录中，“城市”是一个属性，而在人口普查中却应该把“城市”当作对象。

##### (2)误把关联类的属性当作一般对象的属性

如果某个性质依赖于某个关联链的存在，则该性质是关联类的属性，在分析阶段不应该把它作为一般对象的属性。特别是在多对多关联中，关联类属性很明显，即使在以后的开发阶段中，也不能把它归并成相互关联的两个对象中任一个的属性。

##### (3)把限定误当成属性

正如9.4.2节所述，正确使用限定词往往可以减少关联的重数。如果把某个属性值固定下来以后能减少关联的重数，则应该考虑把这个属性重新表述成一个限定词。

> 在ATM系统的例子中，“分行代码”、“账号”、“雇员号”、“站号”等都是限定词。

##### (4)误把内部状态当成了属性

如果某个性质是对象的非公开的内部状态，则应该从对象模型中删掉这个属性。

##### (5)过于细化

在分析阶段应该忽略那些对大多数操作都没有影响的属性。

##### (6)存在不一致的属性

类应该是简单而且一致的。如果得出一些看起来与其他属性毫不相关的属性，则应该考虑把该类分解成两个不同的类。

> 经过筛选之后，得到ATM系统中各个类的属性，如图所示。图中还标出了一些限定词：
>
> - “**卡号**”实际上是一个限定词。在研究卡号含义的过程中，发现以前在分析确定关联的过程中遗漏了“分行发放现金兑换卡”这个关联，现在把这个关联补上，卡号是这个关联上的限定词。
> - “**分行代码**”是关联“分行组成总行”上的限定词。
> - “**账号**”是关联“分行保管账户”上的限定词。
> - “**雇员号**”是“分行雇用柜员”上的限定词。
> - “**站号**”是“分行拥有柜员终端”、“柜员终端与分行计算机通信”及“中央计算机与ATM通信”3个关联上的限定词。
>
> ![image-20220503110407942](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503110408.png)

### 10.3.5.识别继承关系 

​       确定了类中应该定义的属性之后，就可以利用继承机制共享公共性质，并对系统中众多的类加以组织。正如以前曾经强调指出过的，**继承关系的建立实质上是知识抽取过程**，它应该反映出一定深度的领域知识，因此必须有领域专家密切配合才能完成。通常，许多归纳关系都是**根据客观世界现有的分类模式建立起来的**，只要可能，就应该使用现有的概念。

一般说来，可以使用两种方式建立继承(即泛化)关系。

1. **自底向上：**

   ​    抽象出现有类的共同性质泛化出父类，这个过程实质上模拟了人类归纳思维过程。

   > 例如，在ATM系统中，“**远程事务**”和“**柜员事务**”是类似的，可以泛化出父类“**事务**”；类似地，可以从“ATM”和“柜员终端”泛化出父类“输入站”。

2. **自顶向下:**

   ​    把现有类细化成更具体的子类，这模拟了人类的演绎思维过程。从应用域中常常能明显看出应该做的自顶向下的具体化工作。

   > 例如，带有形容词修饰的名词词组往往暗示了一些具体类。但是，在分析阶段应该避免过度细化。

   ​       利用多重继承可以提高共享程度，但是同时也增加了概念上以及实现时的复杂程度。使用多重继承机制时，通常应该指定一个主要父类，从它继承大部分属性和行为；次要父类只补充一些属性和行为。

> ![image-20220503111106791](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503111107.png)

### 10.3.6.反复修改 

​       仅仅经过一次建模过程很难得到完全正确的对象模型。事实上，软件开发过程就是一个多次反复修改、逐步完善的过程。在建模的任何一个步骤中，如果发现了模型的缺陷，都必须返回到前期阶段进行修改。

​       由于面向对象的概念和符号在整个开发过程中都是一致的，因此远比使用结构分析、设计技术更容易实现反复修改、逐步完善的过程。

​       实际上，有些细化工作(例如定义服务)是在建立了动态模型和功能模型之后才进行的。

> 下面以ATM系统为例，讨论可能做的修改
>
> 1. 分解“现金兑换卡”类
>
>    ​    实际上，“现金兑换卡”有两个相对独立的功能，它既是鉴别储户使用ATM的权限的卡，又是ATM获得分行代码和卡号等数据的数据载体。因此，把“现金兑换卡”类分解为“**卡权限**”和“**现金兑换卡**”两个类，将使每个类的功能更单一：前一个类标志储户访问账户的权限，后一个类是含有分行代码和卡号的数据载体。**多张现金兑换卡可能对应着相同的访问权限**。
>
> 2. “事务”由“更新”组成
>
>    ​    通常，一个事务包含对账户的若干次**更新**，这里所说的更新，指的是对账户所做的一个动作(**取款、存款或查询**)。“**更新**”虽然代表一个动作，但是它有自己的**属性**(类型、金额等)，应该独立存在，因此应该把它作为类。
>
> 3. 把“分行”与“分行计算机”合并
>
>    ​    区分**“分行”与“分行计算机”**，对于分析这个系统来说，并没有多大意义，为简单起见，应该把它们**合并**。类似地，应该合并“**总行**”和“**中央计算机**”。

![image-20220503111829973](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503111830.png)

## 10.4 建立动态模型

建立动态模型

- 第一步，是编写典型交互行为的脚本。虽然脚本中不可能包括每个偶然事件，但是，至少必须保证不遗漏常见的交互行为。
- 第二步，从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的目标对象。
- 第三步，排列事件发生的次序，确定每个对象可能有的状态及状态间的转换关系，并用状态图描绘它们。
- 最后，比较各个对象的状态图，检查它们之间的一致性，确保事件之间的匹配。

### 10.4.1.编写脚本

​    在建立动态模型的过程中，**脚本是指系统在某一执行期间内出现的一系列事件**。脚本描述用户(或其他外部设备)与目标系统之间的一个或多个典型的交互过程（事件序列），以便对目标系统的行为有更具体的认识。

​    **目的**保证不遗漏重要的交互步骤，有助于确保整个交互过程的正确性和清晰性。

​    脚本描写的范围并不是固定的，既可以包括系统中发生的全部事件，也可以只包括由某些特定对象触发的事件。脚本描写的范围主要**由**编写脚本的**具体目的决定**。

​    即使在需求陈述中已经描写了完整的交互过程，也还需要花很大精力构思交互的形式。

> 例如，ATM系统的需求陈述，虽然表明了应从储户那里获取有关事务的信息，但并没有准确说明获取信息的具体过程，对动作次序的要求也是模糊的。

​    因此，编写脚本的过程，**实质上**就是分析用户对系统交互行为的要求的过程。在编写脚本的过程中，需要与用户充分交换意见，编写后还应该经过他们审查与修改。

编写脚本时，

- **首先**编写正常情况的脚本。
- **然后**，考虑特殊情况，例如输入或输出的数据为最大值(或最小值)。
- **最后**，考虑出错情况，例如，输入的值为非法值或响应失败。对大多数交互式系统来说，出错处理都是最难实现的部分。如果可能，应该允许用户“异常中止”一个操作或“取消”一个操作。
- **此外**，还应该提供诸如“帮助”和状态查询之类的在基本交互行为之上的“通用”交互行为。

> **ATM与用户交互的正常情况脚本：**
>
> (1)ATM请求用户插入卡片；用户插入现金卡。 
>
> (2)ATM接受卡片并读出它的分行代码和卡号。
>
> (3) ATM要求密码，用户键入密码“ 4011 ”。
>
> (4)ATM与总行验证卡号和密码；总行要求39分行核对密码，通知ATM有效。
>
> (5)ATM要求选择事务类型（取款、存款、转户及查询），用户选择取款。 
>
> (6)ATM要求现金数量；用户输入￥ 100 。 
>
> (7)ATM确认可取款，要求总行处理事务；总行转给分行，分行处理完后返回账户余额。
>
> (8)ATM吐出现金并且要求用户取现金；用户取现金。
>
> (9)ATM提示用户是否想继续；用户指出不继续。
>
> (10) ATM打印收据，退出卡，并请求用户取出它们；用户拿走收据和卡。
>
> (11)ATM请求用户插入卡。
>
> **ATM与用户交互的异常情况脚本：**
>
> (1)ATM请求用户插入卡；用户插入现金卡。 
>
> (2)ATM接受卡并读它的卡号。
>
> (3)ATM要求密码；用户键入： 9999 ：。
>
> (4)ATM请求总行验证，总行请求分行确认卡号和密码后，拒绝它。 
>
> (5)ATM指示密码错并要求重新键入；用户键入： 4011 ，分行确认成功。
>
> (6)ATM请求用户选择事务类型；用户选择取款。 
>
> (7)ATM请求键入现金数量；用户改变选择并键入 “ CANCEL（取消）。 
>
> (8)ATM退出卡并且请求用户拿走卡；用户取出卡。 
>
> (9)ATM请求用户插入卡。

### 10.4.2. 设想用户界面

​    大多数交互行为都可以分为应用逻辑和用户界面两部分。通常，系统分析员首先集中精力考虑系统的信息流和控制流，**而不是首先考虑用户界面**。

​    事实上，采用不同界面(例如命令行或图形用户界面)，可以实现同样的程序逻辑。应用逻辑是内在的、本质的内容，用户界面是外在的表现形式。**动态模型着重表示应用系统的控制逻辑**。

​    但是，用户界面的美观程度、方便程度、易学程度以及效率等，是用户使用系统时最先感受到的，用户对系统的“第一印象”往往从界面得来，**用户界面的好坏往往对用户是否喜欢**、**是否接受一个系统起很重要的作用**。

​    在分析阶段不能完全忽略用户界面。在这个阶段用户界面的细节并不太重要，重要的是在这种界面下的信息交换方式。软件开发人员的目的是确保能够完成全部必要的信息交换，而不会丢失重要的信息。

​    不经过实际使用很难评价一个用户界面的优劣，因此，软件开发人员往往快速地建立起用户界面的原型，供用户试用与评价。

![image-20220503114034604](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503114034.png)

### 10.4.3. 画事件跟踪图（时序图）

完整、正确的脚本为建立动态模型奠定了必要的基础。但是，用自然语言书写的脚本往往不够简明，而且有时在阅读时会有二义性。为了有助于建立动态模型，通常在画状态图之前先画出事件跟踪图。为此首先需要进一步明确事件及事件与对象的关系。

1. 确定事件

2. 画出事件跟踪图

#### 1. 确定事件

​    应该把对控制流产生相同效果的那些事件组合在一起作为一类事件，并给它们取一个唯一的名字。

> 例如，“**吐出现金**”是一个事件类，尽管这类事件中的每个个别事件的参数值不同(吐出的现金数额不同)，然而这并不影响控制流

​    但是，应该把对控制流有不同影响的那些事件区分开来，不要误把它们组合在一起。

> 例如“账户有效”、“账户无效”、“密码错”等都是不同的事件。

​    一般说来，不同应用系统对相同事件的响应并不相同，因此，在最终分类所有事件之前，必须先画出状态图。如果从状态图中看出某些事件之间的差异对系统行为并没有影响，则可以忽略这些事件间的差异。

​    经过分析，应该区分出每类事件的发送对象和接受对象。一类事件相对它的发送对象来说是输出事件，但是相对它的接受对象来说则是输入事件。有时一个对象把事件发送给自己，在这种情况下，该事件既是输出事件又是输入事件

#### 2. 画出事件跟踪图

​    事件跟踪图实质上是扩充的脚本，可以认为事件跟踪图是简化的UML**顺序图**。

​    在事件跟踪图中，一条竖线代表一个对象，每个事件用一条水平的箭头线表示，箭头方向从事件的发送对象指向接受对象。时间从上向下递增。

​    画在最上面的水平箭头线代表最先发生的事件，画在最下面的水平箭头线所代表的事件最晚发生。箭头线之间的间距并没有具体含义，图中仅用箭头线在垂直方向上的相对位置表示事件发生的先后，并不表示两个事件之间的精确时间差。

![image-20220503114744597](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503114744.png)

### 10.4.4. 画状态图

​    **状态图描绘事件与对象状态的关系**。当对象接受了一个事件以后，它的下个状态取决于当前状态及所接受的事件。由事件引起的状态改变称为“转换”。如果一个事件并不引起当前状态发生转换，则可忽略这个事件。

​    **通常，用一张状态图描绘一类对象的行为，它确定了由事件序列引出的状态序列。**

​    但是，也不是任何一个类都需要有一张状态图描绘它的行为。很多对象仅响应与过去历史无关的那些输入事件，或者把历史作为不影响控制流的参数。对于这类对象来说，状态图是不必要的。系统分析员应该集中精力仅考虑具有**重要交互行为**的那些类。

​    从一张事件跟踪图出发画状态图时，应该集中精力仅考虑影响一类对象的事件，也就是说，**仅考虑事件跟踪图中指向某条竖线的那些箭头线**。把这些事件作为状态图中的有向边(即箭头线)，边上标以事件名。

​    两个事件之间的间隔就是一个状态。一般说来，如果同一个对象对相同事件的响应不同，则这个对象处在不同状态。**应该尽量给每个状态取个有意义的名字**。通常，从事件跟踪图中当前考虑的竖线射出的箭头线，是这条竖线代表的对象达到某个状态时所做的行为(往往是引起另一类对象状态转换的事件)。

​    根据一张事件跟踪图画出状态图之后，再把其他脚本的事件跟踪图合并到已画出的状态图中。为此需在事件跟踪图中找出以前考虑过的脚本的分支点(例如“验证账户”就是一个分支点，因为验证的结果可能是“账户有效”，也可能是“无效账户”)，然后把其他脚本中的事件序列并入已有的状态图中，作为一条可选的路径。

**考虑完正常事件之后再考虑边界情况和特殊情况**

​    其中包括在不适当时候发生的事件(例如系统正在处理某个事务时，用户要求取消该事务)。有时用户(或外部设备)不能做出快速响应，然而某些资源又必须及时收回，于是在一定间隔后就产生了“超时”事件。对用户出错情况往往需要花费很多精力处理，并且会使原来清晰、紧凑的程序结构变得复杂、繁琐，但是，**出错处理是不能省略的**。

​    当状态图覆盖了所有脚本，包含了影响某类对象状态的全部事件时，该类的状态图就构造出来了。利用这张状态图可能会发现一些遗漏的情况。测试完整性和出错处理能力的最好方法，是设想各种可能出现的情况，多问几个“如果……，则……”的问题。

> 以ATM系统为例 
>
>   “ATM”、“柜员终端”、“总行”和“分行”都是主动对象，它们相互发送事件；而“现金兑换卡”、“事务”和“账户”是被动对象，并不发送事件。“储户”和“柜员”虽然也是动作对象，但是，它们都是系统外部的因素，无须在系统内实现它们。因此，只需要考虑“ATM”、“总行”、“柜员终端”和“分行”的状态图。（看下面的图片）
>
> ![image-20220503115715315](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503115715.png)
>
> ![image-20220503120352214](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503120352.png)
>
> ![image-20220503120400193](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503120400.png)

### 10.4.5. 审查动态模型

​    各个类的状态图通过共享事件合并起来，构成了系统的动态模型。在完成了每个具有重要交互行为的类的状态图之后，应该检查系统级的完整性和一致性。

​    一般说来，每个事件都应该既有发送对象又有接受对象，当然，有时发送者和接受者是同一个对象。**对于没有前驱或没有后继的状态应该着重审查**，如果这个状态既不是交互序列的起点也不是终点，则发现了一个错误。

​    应该审查每个事件，跟踪它对系统中各个对象所产生的效果，以保证它们与每个脚本都匹配。

> ​    以ATM系统为例， 在总行类的状态图中，事件“分行代码错”是由总行发出的，但是在ATM类的状态图中并没有一个状态接受这个事件。
>
>    因此，在ATM类的状态图中应该再补充一个状态“**do/****显示分行代码错信息**”，它接受由前驱状态“do/验证账户”发出的事件“**分行代码错**”，它的后续状态是“退卡”。
>
> ![image-20220503120729675](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503120729.png)

## 10.5 建立功能模型

​    功能模型表明了系统中数据之间的依赖关系，以及有关的数据处理功能，它由一组数据流图组成。其中的处理功能可以用IPO图(或表)、伪码等多种方式进一步描述。

   面向对象分析中可由用例和场景表示的功能模型。

### 10.5.1. 画出基本系统模型图

​    基本系统模型由若干个数据源点/终点，及一个处理框组成，这个处理框代表了系统加工、变换数据的整体功能。

​    基本系统模型指明了目标系统的边界。由数据源点输入的数据和输出到数据终点的数据，是系统与外部世界之间的交互事件的参数。

![image-20220503121034876](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503121035.png)

### 10.5.2. 画出功能级数据流图

把基本系统模型中单一的处理框分解成若干个处理框，以描述系统加工、变换数据的基本功能，就得到功能级数据流图。右图是ATM系统的功能级数据流图。

![image-20220503120852057](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220503120852.png)

### 10.5.3. 描述处理框功能

把数据流图分解细化到一定程度之后，就应该描述图中各个处理框的功能。应该注意的是，要着重描述每个处理框所代表的功能，而不是实现功能的具体算法。

描述既可以是说明性的，也可以是过程性的。

- 说明性描述规定了输入值和输出值之间的关系，以及输出值应遵循的规律。
- 过程性描述则通过算法说明“做什么”。

一般说来，说明性描述优于过程性描述，因为这类描述中通常不会隐含具体实现方面的考虑。

## 10.6  定义服务

   “对象”是由描述其属性的数据，及可以对这些数据施加的操作(即服务)，封装在一起构成的独立单元。因此，为建立完整的对象模型，既要确定类中应该定义的属性，又要确定类中应该定义的服务。

​    需要等到建立了动态模型和功能模型之后，才能最终确定类中应有的服务，因为这两个子模型更明确地描述了每个类中应该提供哪些服务。事实上，在确定类中应有的服务时，既要考虑该类实体的常规行为，又要考虑在本系统中特殊需要的服务。

### 1. 常规行为

在分析阶段可以认为，类中定义的每个属性都是可以访问的，也就是说，假设在每个类中都定义了读、写该类每个属性的操作。但是，通常无须在类图中显式表示这些常规操作。

### 2.从事件导出的操作

​    状态图中发往对象的事件也就是该对象接收到的消息，因此该对象必须有由消息选择符指定的操作，这个操作修改对象状态(即属性值)并启动相应的服务。

> 例如，在ATM系统中，发往ATM对象的事件“中止”，启动该对象的服务“打印账单”；发往分行的事件“请分行验卡”启动该对象的服务“验证卡号”；而事件“处理分行事务”启动分行对象的服务“更新账户”。
>

可以看出，所启动的这些服务通常就是接受事件的对象在相应状态的行为。

### 3. 与数据流图中处理框对应的操作

​       数据流图中的每个处理框都与一个对象(也可能是若干个对象)上的操作相对应。应该仔细对照状态图和数据流图，以便更正确地确定对象应该提供的服务。

> ​    例如，在ATM系统中，从状态图上看出分行对象应该提供“验证卡号”服务，而在数据流图上与之对应的处理框是“验卡”，根据实际应该完成的功能看，该对象提供的这个服务应该是“验卡”。
>

### 4. 利用继承减少冗余操作

​    应该尽量利用继承机制以减少所需定义的服务数目。只要不违背领域知识和常识，就尽量抽取出相似类的公共属性和操作，以建立这些类的新父类，并在类等级的不同层次中正确地定义各个服务。

# 第11章  面向对象设计

​    分析是提取和整理用户需求，并建立问题域精确模型的过程。设计则是把分析阶段得到的需求转变成符合成本和质量要求的、抽象的系统实现方案的过程。

​    从面向对象分析到面向对象设计(OOD)，是一个逐渐扩充模型的过程。或者说，面向对象设计就是用面向对象观点建立求解域模型的过程。

   本章首先讲述为获得优秀设计结果应该遵循的准则，然后具体讲述面向对象设计的任务和方法。

##  11.1 面向对象设计的准则

### 1. 模块化

- 对象就是模块
- 把数据结构和操作这些数据的方法紧密地结合在一起

### 2. 抽象

- 过程抽象
- 数据抽象：类
- 参数化抽象：C++的“模板”

### 3. 信息隐藏

- 通过对象的封装性实现
- 类分离了接口与实现，支持信息隐藏

### 4. 弱耦合

- 耦合：一个软件结构内不同模块之间互连的紧密程度
- 弱耦合：系统中某一部分的变化对其他部分的影响降到最低程度
- 对象之间的耦合：交互耦合&继承耦合

### 5. 强内聚

- 内聚衡量一个模块内各个元素彼此结合的紧密程度
- 在设计时应该力求做到高内聚
- 面向对象设计的3种内聚：
  - 服务内聚、类内聚、一般\特殊内聚

### 6. 可重用

- 尽量使用已有的类
- 如果确实需要创建新类，则在设计这些新类的协议时，应该考虑将来的可重复使用性

##  11.2 启发规则

### 1. 设计结果应该清晰易懂

- 提高软件可维护性和可重用性的重要措施
- 保证设计结果清晰易懂的主要因素：
  1. 用词一致 
  2. 使用已有的协议
  3. 减少消息模式的数目
  4. 避免模糊的定义

### 2. 一般-特殊结构的深度应适当

- 类等级中包含的层次数适当
- 一个中等规模(大约包含100个类)的系统中，类等级层次数应保持为7±2。

### 3. 设计简单的类

- 尽量设计小而简单的类
- 注意以下几点：
  1. 避免包含过多的属性
  2. 有明确的定义
  3. 尽量简化对象之间的合作关系
  4. 不要提供太多服务

### 4. 使用简单的协议

- 消息中的参数不要超协议过3个

### 5. 使用简单的服务

- 类中的服务通常都很小

- 尽量避免使用复杂的服务

### 6. 把设计变动减至最小

- 理想的设计变动曲线如右图所示
- 在设计的早期阶段，变动较大，随着时间推移，设计方案日趋成熟，改动也越来越小了
- <img src="https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220510111915.png" alt="image-20220510111908266" style="zoom:33%;" />

##  11.3 软件重用

### 11.3.1 软件重用概述

#### 1. 重用

- 重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使用。
- 广义地说，软件重用可分为以下3个层次：
  1. 知识重用
  2. 方法和标准的重用
  3. 软件成分的重用
- 上述前两个重用层次属于知识工程研究的范畴，本节仅讨论软件成分重用问题。

#### 2. 软件成分的重用级别

- 代码重用
  1. 源代码剪贴
  2. 源代码包含
  3. 继承
- 设计结果重用
  - 重用某个软件系统的设计模型(即求解域模型)
- 分许结果重用
  - 更高级别的重用，即重用某个系统的分析模型

#### 3.典型的可重用软件成分

  主要有以下10种：

(1)项目计划

(2)成本估计

(3)体系结构

(4)需求模型和规格说明

(5)设计

(6)源代码

(7)用户文档和技术文档

(8)用户界面

(9)数据

(10)测试用例

### 11.3.2 类构件

面向对象技术中的“类”，是比较理想的可重用软构件，不妨称之为类构件。

#### 1. 可重用软构件应具备的特点

为使软构件也像硬件集成电路那样，能在构造各种各样的软件系统时方便地重复使用，就必须使它们满足下列要求：

1. 模块独立性强
2. 成具有高度可塑性
3. 接口清晰、简明、可靠
4. 需求模型和规格说明

#### 2. 生产率

​     当把可重用的软件成分应用于软件开发的全过程时，创建计划、模型、文档、代码和数据所需花费的时间将减少，从而将用较少的投入给客户提供相同级别的产品，因此，生产率得到了提高。

​     由于应用领域、问题复杂程度、项目组的结构和大小、项目期限、可应用的技术等许多因素都对项目组的生产率有影响，因此，不同开发组织对软件重用带来生产率提高的数字的报告并不相同，但基本上30%50%的5重用大约可以导致生产率提高25%40%。

#### 3. 成本

软件重用带来的净成本节省可以用下式估算：C=Cs-Cr-Cd           

Cr是与重用相关联的成本

1. 领域分析与建模的成本
2. 设计领域体系结构的成本
3. 为便于重用而增加的文档的成本
4. 维护和完善可重用的软件成分的成本
5. 为从外部获取构件所付出的版税和许可证费用
6. 创建（或购买）及运行重用库的费用
7. 对设计和实现可重用构件的人员的培训费用

Cd是交付给客户的软件的实际成本

Cs使用本书第13章讲述的技术来估算

## 11.4 系统分解

<u>分而治之，各个击破</u>

​    软件工程师在设计比较复杂的应用系统时普遍采用的策略，也是首先把系统分解成若干个比较小的部分，然后再分别设计每个部分。

<u>系统的主要组成部分称为子系统</u>

​    面向对象设计模型的4大组成部分可以想象成整个模型的4个垂直切片。

![image-20220510114842610](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220510114843.png)

### 1.  子系统之间的两种交互方式

（1）客户-供应商关系

- 作为“客户”的子系统调用作为“供应商”的子系统，后者完成某些服务工作并返回结果。
- 前者必须了解后者的接口，然而后者却无须了解前者的接口，因为任何交互行为都是由前者驱动的。

（2）平等伙伴关系

- 每个子系统都可能调用其他子系统，每个子系统都必须了解其他子系统的接口。
- 子系统之间的交互更复杂，这种交互方式还可能存在通信环路。

### 2.  组织系统的两种方案

（1）层次组织

- 把软件系统组织成一个层次系统，每层是一个子系统。
- 上层在下层的基础上建立，下层为实现上层功能而提供必要的服务。
- 每一层内所包含的对象，彼此间相互独立，而处于不同层次上的对象，彼此间往往有关联。
- 在上、下层之间存在客户-供应商关系。低层相当于供应商，上层相当于客户。
- 层次结构又可进一步划分成两种模式：封闭式和开放式。

（2）块状组织

- 把软件系统垂直地分解成若干个相对独立的、弱耦合的子系统。
- 一个子系统相当于一块，每块提供一种类型的服务。

（3）设计系统的拓扑结构

​    由子系统组成完整的系统时，典型的拓扑结构有管道形、树形、星形等。

​    设计者应该采用与问题结构相适应的、尽可能简单的拓扑结构，以减少子系统之间的交互数量。

## 11.5 设计问题域子系统

​    在面向对象设计过程中，可能对面向对象分析所得出的问题域模型做补充或修改

### 1. 调整需求 

​    两种情况会导致修改通过面向对象分析所确定的系统需求

- 用户需求或外部环境发生了变化。
- 分析员对问题域理解不透彻或缺乏领域专家帮助，以致面向对象分析模型不能完整、准确地反映用户的真实需求。

### 2. 重用已有的类

如果有可能重用已有的类，则重用已有类的典型过程如下

①选择有可能被重用的已有类，标出这些候选类中对本问题无用的属性和服务，尽量重用那些能使无用的属性和服务降到最低程度的类。

②在被重用的已有类和问题域类之间添加泛化关系(即从被重用的已有类派生出问题域类)。

③标出问题域类中从已有类继承来的属性和服务，现在已经无须在问题域类内定义它们了。

④修改与问题域类相关的关联，必要时改为与被重用的已有类相关的关联。

### 3. 把问题域类组合在一起

​    在面向对象设计过程中，设计者往往通过引入一个根类而把问题域类组合在一起。

### 4. 添加一般化类以建立协议

​     一些具体类需要有一个公共的协议，也就是说，它们都需要定义一组类似的服务(很可能还需要相应的属性)。在这种情况下可以引入一个附加类(例如根类)，以便建立这个协议

### 5. 调整继承类层次

(1) 使用多重继承机制

<img src="https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220510115750.png" alt="image-20220510115750324" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220510115808.png" alt="image-20220510115808180" style="zoom:50%;" />

​    如果面向对象分析模型中包含了多重继承关系，然而所使用的程序设计语言却并不提供多重继承机制，则必须修改面向对象分析的结果。即使使用支持多重继承的语言，有时也会出于实现考虑而对面向对象分析结果作一些调整。

下面分情况讨论。

- 窄菱形模式，出现属性及服务命名冲突的可能性比较大；
- 阔菱形模式，属性及服务的名字发生冲突的可能性比较小，但是，它需要用更多的类才能表示同一个设计。

(2) 使用单重继承机制

​    如果打算使用仅提供单继承机制的语言实现系统，则必须把面向对象分析模型中的多重继承结构转换成单继承结构。

<img src="https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220510115901.png" alt="image-20220510115901053" style="zoom:50%;" />

​    显然，在多重继承结构中的某些继承关系，经简化后将不再存在，这表明需要在各个具体类中重复定义某些属性和服务。

### 6. ATM系统实例

​    ATM三个子系统为星形拓扑结构；物理联结用专用电话线实现；根据ATM站号和分行代码，区分由每个ATM站和每台分行计算机联向中央计算机的电话线。

​    在面向对象分析过程中已经对ATM系统做了相当仔细的分析，而且假设所使用的实现环境能完全支持模型的实现。

​    因此，在设计阶段无须对已有的问题域模型作实质性的修改或扩充。

![image-20220510115937295](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220510115937.png)

## 11.5设计问题域子系统

为提高性能，在对分析模型进行大规模的改动之前，应考虑下面一些问题：

- **不要认为象C++之类的OOPL就一定效率不高**。事实表明，非OOPL的紧凑代码的效率比OOPL的效率高近10倍，但用非OOPL编程会令程序员非常疲劳，容易出错。
- **提高一个现存系统的工作效率比重新设计一个高效的系统要容易**。一开始应当建立一个原始的简单的设计，实现和调试不会太困难。如果对设计有性能要求，只需加入少量的工作就可以了。

- Ø**通常系统80%的开销都集中在20%的代码段上。**与其为了尽量处处节省系统开销而破坏完善的系统结构，还不如找出系统开销最集中的地方，只对那部分做优化。
- Ø**预测软件开销集中在什么地** 方是困难的。 进行优化最有效的方法是在系统运行时使用性能监测工具对系统进行观测。一些像继承、动态绑定、消息传递等处理虽然看起来简单，但需要大量的系统开销。在代码复杂性与运行的低效之间没有相关性。
- Ø**提高性能最好的方法是采用好的解决方案**，而不是拼命地去节省几个微秒、几个字节。

## 11.6 设计人机交互子系统

### 1. 分类用户 

为了更好地了解用户的需要与爱好，以便设计出符合用户需要的界面，设计者首先应该把将来可能与系统交互的用户分类。

> - 按技能层次分类：外行／初学者／熟练者／专家
> - 按组织层次分类：行政人员／管理人员／专业技术人员／其它办事员
> - 按职能分类：客户／职员

### 2. 描述用户

了解将来使用系统的每类用户的情况

 对以上定义的每一类用户，列出对以下问题做出的考虑：谁、目的、特点、成功的关键因素、熟练程度以及任务脚本。

>   在OOATOOLTM 中有一个例子：
>
> - Ø谁：分析员
> - Ø目的：要求一个工具来辅助分析工作 (摆脱繁重的画图和检查图的工作)。
> - Ø特点：年龄: 42岁；教育水平: 大学；限制:不要微型打印，小于9个点的打印太小。
> - Ø成功的关键因素：工具应能使分析工作顺利进行；工具不应与分析工作冲突；工具应能捕获假设和思想，能适时做出折衷；应能及时给出模型各个部分的文档。
> - Ø熟练程度：专家。
> - Ø任务脚本：
>   - F主脚本：
>     - －识别“核心的”类和对象；
>     - －识别“核心”结构；
>     - －在发现了新的属性或操作时随时都可以加进模型中去。
>   - F 检验模型：
>     - －打印模型及其全部文档。

### 3. 设计命令层次

#### (1) 研究现有的人机交互含义和准则

Windows已经成了微机上图形用户界面事实上的工业标准

> 基本外观及给用户的感受都是相同的
>
> (1)每个程序至少有一个窗口，它由标题栏标识;
>
> (2)程序中大多数功能可通过菜单选用;
>
> (3)选中某些菜单项会弹出对话框，用户可通过它输入附加信息;
>
> (4)……
>
> 广大用户习以为常的许多约定
>
> (1)File菜单的最后一个菜单项是Exit；
>
> (2)在文件列表框中用鼠标单击某个表项，则相应的文件名变亮，若用鼠标双击则会打开该文件；
>
> (3)……

#### (2) 确定初始的命令层次

- 所谓命令层次，实质上是用过程抽象机制组织起来的、可供选用的服务的表示形式。
- 设计命令层次时，通常先从对服务的过程抽象着手，然后再进一步修改它们，以适合具体应用环境的需要。

> 如一系列 Menu Screens、或一个 Menu Bar、或一系列Icons.

#### (3) 精化命令层次

- •排列命令层次。把使用最频繁的操作放在前面；按照用户工作步骤排列。
- •通过逐步分解，找到整体－局部模式，以帮助在命令层中对操作分块。
- •根据人们短期记忆的 “7±2” 或 “每次记忆 3块／每块 3 项” 的特点，把菜单深度尽量限制在三层之内。
- •减少操作步骤：把点取、拖动和键盘操作减到最少。

#### (4)设计详细的交互

- •一致性：采用一致的术语、一致的步骤和一致的活动。
- •不要“哑播放”：每当用户等待系统完成一个活动时，要给出一些反馈信息。
- •Undo：在操作出现错误时，要恢复或部分恢复原来的状态。
- •减少人脑的记忆负担：不应在一个窗口使用在另一个窗口中记忆或写下的信息；需要人按特定次序记忆的东西应组织得容易记忆。
- •学习的时间和效果：提供联机的帮助信息。
- •趣味性：尽量采取图形界面，符合人类习惯。

### 4. 设计人机交互类

   设计人机交互类，首先从组织窗口和部件的用户界面的设计开始。每个类包括窗口的菜单条、下拉菜单、弹出菜单的定义。还要定义用于创建菜单、加亮选择项、调用相应响应的操作

   窗口通常包括：类窗口、条件窗口、检查窗口、文档窗口、画图窗口、过滤器窗口、模型控制窗口、运行策略窗口、模板窗口等。

人机交互类与所使用的操作系统及编程语言密切相关

> 例如，在Windows环境下运行的Visual C++语言提供了MFC类库，设计人机交互类时，往往仅需从MFC类库中选出一些适用的类，然后从这些类派生出符合自己需要的类就可以了。

#### 5.继续做原型

- •开发用户界面原型，可对提交的人机交互活动进行体验、实地操作，并精炼成一致的模式。
- •使用快速原型工具或应用构造器，对各种命令方式，如菜单、弹出、填充以及快捷命令，做出原型让用户使用，通过用户反馈、修改、演示的迭代，使界面越来越有效。

- •设计人机交互子系统的启发式准则

  - ①、每一个组织和用户都有其文化背景。可能不仅仅意味着语言、传统和习惯。由于所建立的系统面对的是用户，因此，其界面必须必须与用户的文化背景相一致。

  -  一种适应用户文化背景的有效方法是“可视化表示”。目的是让计算机界面适应用户。

  - > 例如：有一个客户开发了一个财务管理软件，它以政府规定的各种计算方法和表格作为其可视化表示。对于这样的用户界面，学习和掌握它非常简单和容易。

  - ②、使用用户开发的场景或使用事例来驱动界面。为避免用户界面太复杂，先观察用户是如何完成其工作的。在执行一个特定的工作时，用户界面应能告诉用户下面将做什么。

  - ③、应当首先定义一个高层的用户界面和一些详细的对话框，然后定义人机交互对象，从而完成设计。需要建立原型对所有人机交互界面设计进行严格的检验。

  - ④、人机交互子系统的设计应从建立分析模型时就开始着手。在开发系统的人机交互子系统时，应允许用户对其试用。

  - ⑤、多数用户都不会从头开始设计人机交互类。事实上，使用各种所谓的可视化开发环境，如Delphi, PowerBuilder、Vasual Basic、Vasual C++、Borland C++ builder等，开发人员可能连人机交互子系统都不要。直接使用这些工具提供的控件，就可以作出用户界面。

  -  用户可以不需要HIC，但不能免去用户界面的设计。使用菜单树或状态，连同某些原型，来说明用户界面的设计思想。

## 11.7 设计任务管理子系统

​       设计工作的一项重要内容就是，确定哪些是必须同时动作的对象，哪些是相互排斥的对象。然后进一步设计任务管理子系统。

### 1. 分析并发性

- •如果两个对象彼此间不存在交互，或者它们同时接受事件，则这两个对象在本质上是并发的。
- •通过检查各个对象的状态图及它们之间交换的事件，能够把若干个非并发的对象归并到一条控制线中。
- •在计算机系统中用任务(task)实现控制线，一般认为任务是进程(process)的别名。通常把多个任务的并发执行称为多任务。

划分任务，可以简化系统的设计及编码工作。这种并发行为既可以在不同的处理器上实现，也可以在单个处理器上利用多任务操作系统仿真实现。

### 2. 设计任务管理子系统

![image-20220517114251777](https://cdn.jsdelivr.net/gh/stingo1218/pic/img/20220517125714.png)

#### 1）确定任务类型

##### （1） 确定事件驱动型任务

某些任务是由事件驱动而执行的。这种任务可能主要负责完成通讯

> 工作过程如下：
>
> 任务处于睡眠状态(不消耗处理器时间)，等待来自数据线或其他数据源的中断；
>
> 接收到中断唤醒该任务，接收数据并放入内存缓冲区或其他目的地，通知需要知道这件事的对象；
>
> 该任务又回到睡眠状态。

##### （2） 确定时钟驱动型任务

任务每隔一定时间间隔就被触发以执行某些处理

> 工作过程如下：
>
> •任务设置了唤醒时间后进入睡眠状态；
>
> •任务睡眠(不消耗处理器时间)，等待来自系统的中断；
>
> •一旦接收到这种中断，任务就被唤醒并做它的工作，通知有关的对象，然后该任务又回到睡眠状态。

##### （3） 确定优先任务

优先任务可以满足高优先级或低优先级的处理需求

- 高优先级：某些服务具有很高的优先级，为了在严格限定的时间内完成这种服务，可能需要把这类服务分离成独立的任务。
- 低优先级：与高优先级相反，有些服务是低优先级的，属于低优先级处理(通常指那些背景处理)。设计时可能用额外的任务把这样的处理分离出来。

##### （4） 确定关键任务

- 关键任务是有关系统成功或失败的关键处理，这类处理通常都有严格的可靠性要求。
- 在设计过程中可能用额外的任务把这样的关键处理分离出来，以满足高可靠性处理的要求。
- 对高可靠性处理应该精心设计和编码，并且应该严格测试。

##### （5） 确定协调任务

- 当系统中存在3个以上任务时，就应该增加一个任务，用它作为协调任务。
- 引入协调任务会增加系统的总开销(增加从一个任务到另一个任务的转换时间)，但是引入协调任务有助于把不同任务之间的协调控制封装起来。
- 使用状态转换矩阵可以比较方便地描述该任务的行为。
- 这类任务应该仅做协调工作，不要让它再承担其他服务工作。

#### 2）分析任务

##### （1） 尽量减少任务数

​     必须仔细分析和选择每个确实需要的任务，使系统中包含的任务数尽量少。

##### （2） 确定资源需求

​    设计者必须通过计算系统载荷(即每秒处理的业务数及处理一个业务所花费的时间)，来估算所需要的CPU(或其他固件)的处理能力。

​     应该综合考虑各种因素，以决定哪些子系统用硬件实现，哪些子系统用软件实现。

#### 3）完成设计 

设计任务包括定义任务的内容以及它怎样协调和通讯。

(1)任务的内容

(2)怎样协调 

(3)怎样通讯 

## 11.8 设计数据管理子系统

​         数据管理子系统是系统存储或检索对象的基本设施，它建立在某种数据存储管理系统之上，并且隔离了数据存储管理模式(文件、关系数据库或面向对象数据库)的影响。
