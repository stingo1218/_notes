[TOC]



# 大题

1. 函数 
2. 触发器
3. 存储过程

# 1基本概念

## 1.1  数据库基本概念

### 1.1.1  数据库与数据库管理系统

1．数据库
数据库(Database,简称DB):是长期储存在计算机内、有组织的、可共享的大量数据集合。
从广义上讲，数据不仅包含数字，还包括了文本、图像、音频、视频等。
例如，把一个学校的学生、课程、学生成绩等数据有序地组织并存放在计算机内，就可以构成一个数据库。

2．数据库管理系统（DBMS）
数据库管理系统（Database  Management System，简称DBMS）是管理数据库的系统，它按一定的数据模型组织数据。DBMS应提供数据定义、数据操纵、数据的完整性检查、数据库的安全保护、数据库的并发控制、故障恢复功能等功能

3.数据库系统（Database System，简称DBS）
数据、数据库、数据库管理系统与操作数据库的应用程序，加上支撑它们的硬件平台、软件平台和与数据库有关的人员一起构成了一个完整的数据库系统。如图1.1所示描述了数据库系统的构成。

n在数据库中用数据模型来**抽象、表示和处理**现实世界中的数据和信息。通俗地讲数据模型就是现实世界的模拟。

n模型种类：概念模型、逻辑模型、物理模型。

**(1)** **概念模型**  也称信息模型，它是按用户的观点来对数据和信息建模。 

**(2)** **逻辑模型**  主要包括层次模型、网状模型、关系模型等，它是按计算机系统的观点对数据建模。

**(3)** **物理模型**  在计算机系统内部的表示方式和存取方法。数据库设计人员需要了解和掌握。

说明：数据库设计中有时不区别概念模型和逻辑模型，所以在数据库设计工具ERWIN中只提供了逻辑模型和物理模型，而在PowerDesigner早期版本中也只提供了概念模型和物理模型两种模型，只是在PowerDesigner15版本中提供了三种模型：概念模型、逻辑模型、物理模型。

### 1.1.2  关系模型

（1）层次模型：以树形层次结构组织数据。如图1.2所示为某学校按层次模型组织的数据示例。

![image-20211220172557019](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202112201725113.png)

（2）网状模型：每一个数据用一个节点表示，每个节点与其他节点都有联系，这样数据库中的所有数据节点就构成了一个复杂的网络。如图1.3所示为按网状模型组织的数据示例。

![image-20211220172613497](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202112201726586.png)

（3）关系模型：以二维表格（关系表）的形式组织数据库中的数据。

¡超码：用于唯一决定表中行的一个或多个列。

¡候选码：如果任意超码的真子集都不是超码，则称其为候选码。可以看出，超码包括候选码。

¡主码：被数据库设计者选中的某一个候选码；

  主码应该选择哪些从不或极少变化的属性；

 基于关系模型的数据库管理系统（DBMS）称为关系数据库系统（RDBMS）
 80年代后，关系数据库系统成为最重要、最流行的数据库系统。典型的RDBMS有：ORACLE、SYBASE、INFORMIX、DB2、MS SQLServer等

**关系的完整性**
    关系模型的完整性规则是对关系的某种约束条件。
    实体完整性：实体完整性指表中行的完整性。实体完整性要求每一个表中的主键字段都不能为空或者重复的值。
    参照完整性：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须为：或者为空（F中每个属性均为空），或者等于S中某个元组的主码值。
    域完整性：指列的值域的完整性。如数据类型、格式、值域范围、是否允许空值等。
    用户定义的完整性：在某一具体应用中数据所要满足的语义要求。
    注：有些资料对域完整性和用户定义的完整性不加区分，因此将完整性定义为3种。

## 1.2  数据库设计

数据库的设计分为概念结构设计和逻辑结构设计两个阶段。

### 1.2.1 概念结构设计

l实体（或称实体集）：客观存在，可以相互区别的事物称为实体。如：学生

l实体型：用实体名及属性名集合来抽象和刻划的同类实体。如，学生(学号，姓名)

l联系：是指实体之间的相互关系。

lE-R图（Entity Relationship Diagram） ：通常称为 实体-关系(联系)图，其实严格的讲应该叫做**实体型**-关系(联系)图。E-R图提供了表示实体型、属性和联系的方法。 

## 1.3  数据库应用系统

## 1.4  SQL Server 2005环境



## 2.1  SQL Server数据库基本概念

## 第2章  数据库创建

## 2.1  SQL Server数据库基本概念

### 2.1.1  逻辑数据库

用户观点将数据库称为逻辑数据库，组成数据库的逻辑成分称为数据库对象。主要包括表、视图(选择语句/虚表 不存数据)、索引、存储过程(程序)、触发器(保证数据完整性)和约束等。
两种对象名：完全限定名和部分限定名。(类似绝对路径和相对路径)
（1）完全限定名。在SQL Server 2005中，完全限定名是对象的全名，包括四个部分：服务器名、数据库名、数据库架构名和对象名，其格式为：

```
server.database.scheme.object
```

在SQL Server2000中，完全限定名的格式为：服务器名.数据库名.所有者名.对象名。所有者名是指用户名，用户名与架构名之间的关系类似于用户名与用户身份之间的关系， 2005 中的DBO既是默认架构，也是默认用户 ，这是为了与SQL Server2000兼容。

（2）部分限定名。在使用T-SQL编程时，对象全名的前三个部分均可以被省略，当省略中间的部分时，圆点 “.”不可省略。把只包含对象完全限定名中的一部分的对象名称为部分限定名。

```
(server.)Datebase.scheme.xxx
Server..scheme .xxx
```

在部分限定名中，未指出的部分使用以下默认值：
服务器：默认为本地服务器。
数据库：默认为当前数据库。
数据库架构名：默认为dbo。

> 例如，以下是一些正确的对象部分限定名：
> server.database .. object      	/*省略架构名*/
> server . . scheme . object        	/*省略数据库名*/
> database . scheme . object      	/*省略服务器名*/
> server . . .object            	/*省略架构名和数据库名*/
> scheme.object             	/*省略服务器名和数据库名*/
> object                   	/*省略服务器名、数据库名和架构名*/

常用的数据库对象(具体内容将在后面的章节中介绍):
表：是SQL Server中最主要的数据库对象，它用来存储和操作数据。
视图：视图是从一个或多个基本表（或视图）中引出的表，数据库中只存放视图的定义，数据仍存放在导出视图的基本表中。(相当于基本表的部分列/行)
索引：索引是对表中的一列或者多列的数据进行排序，以提高访问速度。(类似字典)
表中的记录通常按其输入的时间顺序存放，这种顺序称为记录的物理顺序。
为了实现对表记录的快速查询，可以对表的记录按某个和某些属性进行排序，这种顺序称为逻辑顺序。
约束：约束机制保障了数据的一致性与完整性，如主键、外键、NOT NULL 、CHECK 、UNIQUE 。

存储过程：存储过程是一组完成特定功能的SQL语句集合，经过编译后存储在数据库中。存储过程具有接受参数、输出参数，返回单个或多个结果以及返回值的功能。
存储过程与函数有相同的地方，也有区别：
1、返回值的区别,函数有1个返回值,而存储过程返回值是通过参数返回的,可以有多个或者没有。
 2、调用的区别,函数可以在查询语句中直接调用,而存储过程必须单独调用；函数一般情况下是用来计算并返回一个计算结果而存储过程还可用来完成特定的数据操作（比如修改、插入数据库表或执行某些DDL语句等等） 

触发器：(增删改时,自动触发)可用于级联操作，能更加有效地保障数据库系统中数据的完整性和一致性。
默认值：默认值是在用户没有给出具体数据时，系统所自动生成的数值。
用户和角色：用户是对数据库有存取权限的使用者；角色是指一组数据库用户的集合。这两个概念类似于Windows XP的本地用户和组的概念。
规则：规则用来限制表字段的数据范围。
规则与CHECK约束有相似之处。但 CHECK约束作为CREATE TABLE 语句的一部分进行指定，而规则以单独的对象创建，然后绑定到列上。一个列只能应用一个规则，却可以应用多个CHECK约束。
 类似于 规则:函数   Check:代码
自定义类型：用户根据需要在给定的系统类型之上定义的自己的数据类型。
函数：用户可以根据需要自己定义的函数。

### 2.1.2  物理数据库

**1．数据库文件**
SQL Server 2005所使用的操作系统文件包括三类：
（1）主数据文件mdf(primary data file) 。简称主文件，是数据库的关键文件，包含了数据库的启动信息，并且存储数据。每个数据库必须有且仅能有一个主文件，其默认扩展名为.mdf。
（2）辅助数据文件ndf(Secondary data files) 。简称辅（助）文件，用于存储未包括在主文件内的其他数据。辅助文件的默认扩展名为.ndf。辅助文件是可选的，一般当数据库很大时，有可能需要创建多个辅助文件。(可选)(类似多通道)(作用:1.提高读写速度2.扩大数据库容量)
（3）日志文件ldf(log data file)。日志文件用于保存恢复数据库所需的事务日志信息(增删改等操作)。每个数据库至少有一个日志文件，也可以有多个，日志文件的扩展名为.ldf。(数据库崩溃后恢复(重做)数据库)

**2．文件组**
文件组由多个文件组成，使用文件组可以提高表中数据的查询性能。
在SQL Server 2005中有两类文件组：
（1）主文件组。主文件组包含主要数据文件和任何没有明确指派给其他文件组的其他文件。
（2）用户定义文件组。用户定义文件组是指创建或修改数据库语句中使用“FILEGROUP”关键字指定的文件组。
每个数据库中都有一个默认文件组。用户可以指定默认文件组，如果没有指定默认文件组，则主文件组是默认文件组。

**3．系统数据库与用户数据库**
在SQL Server 2005中有两类数据库：系统数据库和用户数据库。
系统数据库存储有关SQL Server的系统信息，如果系统数据库损坏，SQL Server将不能正常启动。4个系统数据库为：master、model、msdb和tempdb。
（1）master数据库包含了SQL Server诸如登录账号、系统配置、数据库位置及数据库错误信息等，用于控制用户数据库和SQL Server的运行。(管理其他数据库的数据库)(不要进行不熟悉操作)
（2）model数据库为新创建的数据库提供模板。
（3）msdb数据库为“SQL Server Agent”(组件)(自动执行)调度信息和作业记录提供存储空间。
（4）tempdb数据库为临时表和临时存储过程提供存储空间(临时表私有,用户独有,使用完自动消失)，所有与系统连接的用户的临时表和临时存储过程都存储于该数据库中。

### 2.2.1  数据库的创建(略)

### 2.2.2  数据库的修改和删除(略)

## 2.3  命令方式创建数据库

### 2.3.1  创建数据库

使用“CREATE DATABASE”创建数据库，要确保用户具有创建数据库的权限。
语法格式
说明：
在对语法格式进行解释之前，先介绍本书的语法格式中的约定。如表2.1所示。这些约定在本书中介绍T-SQL语法格式时也适用。

| 约  定            | 用  于                                                 |
| ----------------- | ------------------------------------------------------ |
| UPPERCASE（大写） | Transact-SQL 关键字                                    |
| 下画线            | 指示当语句中省略了包含带下画线的值的子句时应用的默认值 |
| \|                | 只能选择由\|分割的其中一项                             |
| [  ]              | 其中的内容可选。不要带有方括号                         |
| {  }              | 必选项。不要输入大括号                                 |
| [,...n]           | 指示前面的项可以重复*n*次。每一项由逗号分隔            |
| [  ...n]          | 指示前面的项可以重复*n*次。每一项由空格分隔            |
| [;]               | 可选的Transact-SQL语句终止符。不要输入方括号           |
| <label>  ::=      | 语法块的名称。                                         |

由语法格式可知，最简单的创建数据库的语句为：
CREATE DATABASE database_name //创建
Drop DATABASE database_name //删除

```sql
【例2.5】 创建一个名为TEST1的数据库，其初始大小为5MB，最大大小不限制，允许数据库自动增长，增长方式是按10%比例增长。日志文件初始为2MB，最大可增长到5MB，按1MB增长。假设SQL Server服务已启动，并以系统管理员身份登录计算机。
按钮新建一个查询窗口，如图2.12所示。
         CREATE DATABASE TEST1
	ON
	(
	     NAME='TEST1_DATA',--逻辑文件名，数据库OS文件在数据库中显示的名字
                       FILENAME='C:\Program Files\Microsoft SQL Server\MSSQL.1\MSSQL\Data\TEST1.mdf',
                                           --数据库OS文件
	     SIZE=5MB,
	     FILEGROWTH=10%		
	)
	LOG ON
	(
	     NAME='TEST1_log',
	     FILENAME='C:\Program Files\Microsoft SQL Server\MSSQL.1\MSSQL\Data\TEST1.ldf',
	     SIZE=2MB,
	     MAXSIZE=5MB,
	     FILEGROWTH=1MB
	)

```

### 2.3.2  修改数据库

使用“**ALTER DATABASE**”命令对数据库可进行以下修改：

l增加或删除数据文件；

l改变数据文件的大小和增长方式；

l改变日志文件的大小和增长方式；

l增加或删除日志文件；

l增加或删除文件组。

```sql
语法格式：
ALTER DATABASE database_name
{	ADD FILE <filespec>[,…n][ TO FILEGROUP filegroup_name ]
						/*在文件组中增加数据文件*/
	| ADD LOG FILE <filespec>[,…n]           		/*增加日志文件*/
	| REMOVE FILE logical_file_name           		/*删除数据文件*/
	| ADD FILEGROUP filegroup_name          		/*增加文件组*/
	| REMOVE FILEGROUP filegroup_name      		/*删除文件组*/
	| MODIFY FILE <filespec>                 		/*更改文件属性*/
	| MODIFY NAME = new_dbname           		/*数据库更名*/
	| MODIFY FILEGROUP filegroup_name {filegroup_property | NAME = new_filegroup_name }
	| SET <optionspec> [ ,...n ] [ WITH <termination> ]   	/*设置数据库属性*/
	| COLLATE < collation_name > 			/*指定数据库排序规则*/
}
[;]

```

```sql
【例2.8】 假设已经创建了例2.5中的数据库TEST1，它只有一个主数据文件，其逻辑文件名为TEST1_DATA，大小为5MB，最大为50MB，增长方式为按10%增长。
要求：修改数据库TEST1现有数据文件的属性，将主数据文件的最大大小改为100MB，增长方式改为按每次5MB增长。
语句：
ALTER DATABASE TEST1
	MODIFY FILE 
	(	
		NAME = TEST1_DATA,  --这里是逻辑名
		MAXSIZE =100MB,		/*将主数据文件的最大大小改为100MB*/
		FILEGROWTH = 5MB		/*将主数据文件的增长方式改为按5MB增长			)
GO	
```

```sql
【例2.9】 先为数据库TEST1增加数据文件TEST1BAK，然后删除该数据文件。
在“查询分析器”窗口中输入如下Transact-SQL语句并执行：
ALTER DATABASE TEST1
	ADD FILE
	(
		NAME = 'TEST1BAK',
		FILENAME = 'E:\TEST1BAK.ndf',
		SIZE = 10MB,
		MAXSIZE = 50MB,
		FILEGROWTH = 5%
	)
通过查看数据库属性对话框中的文件属性来观察数据库“TEST1”是否增加数据文件TEST1BAK。
删除数据文件TEST1BAK的命令如下：
ALTER DATABASE TEST1
	REMOVE FILE TEST1BAK
GO
```

```sql
【例2.10】 为数据库TEST1添加文件组FGROUP，并为此文件组添加两个大小均为10MB的数据文件。
在“查询分析器”窗口中输入如下Transact-SQL语句并执行：
ALTER DATABASE TEST1
	ADD FILEGROUP FGROUP  --新增文件组的名字

GO
ALTER DATABASE TEST1
	ADD FILE
	(
		NAME = 'TEST1_DATA2',
		FILENAME = 'C:\TEST1_Data2.ndf',
		SIZE = 10MB,
		MAXSIZE = 30MB,
		FILEGROWTH = 5MB
	),
	(	
		NAME = 'TEST1_DATA3',
		FILENAME = 'C:\TEST1_Data3.ndf',
		SIZE = 10MB,
		MAXSIZE = 30MB,
		FILEGROWTH = 5MB
	)
	TO FILEGROUP FGROUP  --添加到指定文件组
GO
```

```sql
【例2.11】从数据库中删除文件组，将例2.10中添加到TEST1数据库中的文件组FGROUP删除。
在“查询分析器”窗口中输入如下Transact-SQL语句并执行：
--先删除文件组中的文件
ALTER DATABASE TEST1
	REMOVE FILE TEST1_DATA2
GO
ALTER DATABASE TEST1
	REMOVE FILE TEST1_DATA3
GO
--再删除文件组
ALTER DATABASE TEST1
	REMOVE FILEGROUP FGROUP
GO
```

```sql
【例2.12】 为数据库TEST1添加一个日志文件。
在“查询分析器”窗口中输入如下Transact-SQL语句并执行：
ALTER DATABASE TEST1
	ADD LOG FILE
	(	
		NAME = 'TEST1_LOG2',
		FILENAME = 'C:\TEST1_Log2.ldf',
		SIZE = 5MB,
		MAXSIZE =10 MB,
		FILEGROWTH = 1MB
   )
```

```sql
【例2.13】 从数据库TEST1中删除一个日志文件，将日志文件TEST1_LOG2删除。
将数据库TEST1的名改为JUST_TEST。进行此操作时必须保证该数据库不被其他任何用户使用。
在“查询分析器”窗口中输入如下Transact-SQL语句并执行：
ALTER DATABASE TEST1
	REMOVE FILE TEST1_LOG2
GO
ALTER DATABASE TEST1
	MODIFY NAME = JUST_TEST
GO
```



### 2.3.3  删除数据库

删除数据库使用“**DROP DATABASE**”命令。

语法格式：

DROP DATABASE database_name[,…n][;]

其中，database_name是要删除的数据库名。

例如，要删除数据库TEST2，使用命令：

DROP DATABASE TEST2

GO

注意：使用“DROP DATABASE”语句不会出现确认信息，所以要小心使用。另外，不能删除系统数据库，否则将导致服务器无法使用。

### 2.3.4  数据库快照

创建数据库快照也使用“**CREATE DATABASE**”命令，语法格式如下：

CREATE DATABASE database_snapshot_name --数据库快照的名称

 ON

 (

 NAME = logical_file_name, /*要创建数据库快照的数据库

​                    文件的逻辑名*/

 FILENAME = 'os_file_name' --数据库快照文件的OS名



 ) [ ,...n ] 

 AS SNAPSHOT OF source_database_name--表示需要创建数据库快照的源数据库的数据库名称

FAT32不能创建数据库快照。

```sql
【例2.14】 创建PXSCJ数据库的快照PXSCJ_01。
CREATE DATABASE PXSCJ_01
	ON
	(
		NAME=PXSCJ,
		FILENAME='C:\Program Files\Microsoft SQL Server\MSSQL.1\MSSQL\Data\PXSCJ_01.mdf'
	)
	AS SNAPSHOT OF PXSCJ
GO
命令执行成功之后，在“对象资源管理器”窗口中刷新“数据库”菜单栏，在“数据库”中展开“数据库快照”，就可以看见刚刚创建的数据库快照PXSCJ_01了。
删除数据库快照的方法和删除数据库的方法完全相同，可以使用界面方式删除，也可以使用命令方式删除，例如：
DROP DATABASE PXSCJ_01;

```

# 第3章  表与表数据操作

## 3.1  表结构和数据类型

略

## 3.2  界面方式操作表

略

## 3.3  命令方式操作表

### 3.3.1创建表

```sql
【例3.5】 设已经创建了数据库PXSCJ，现在该数据库中需创建学生情况表XSB，该表的结构见表3.3。
创建表XSB的T-SQL语句如下：
USE PXSCJ
GO
CREATE TABLE XSB
( 	
	学号 char(6) NOT NULL PRIMARY KEY,--主键
	姓名 char(8) NOT NULL,
	性别 bit NULL DEFAULT 1,--缺省值1
	出生时间 datetime NULL,
	专业 char(12) NULL,
	总学分 int NULL,
	备注 varchar(500) NULL
)
GO
```

```sql
【例3.6】 创建一个带计算列的表，表中包含课程的课程号、总成绩和学习该课程的人数以及课程的平均成绩。
创建表的T-SQL语句如下：
CREATE TABLE PJCJ
(
	课程号 char(3) NOT NULL PRIMARY KEY,
	总成绩 real NOT NULL,
	人数   int NOT NULL,
	平均成绩 AS 总成绩/人数 PERSISTED --PERSISTED 表示在表中物理存储计算值 
)
GO
```



### 3.3.3  修改表结构

```sql
【例3.10】 设已经在数据库PXSCJ中创建了表XSB。先在表XSB中增加1个新列——奖学金等级。然后在表XSB中删除名为“奖学金等级”的列：
ALTER TABLE XSB
	ADD 奖学金等级 tinyint  NULL
go
       ALTER TABLE XSB
	DROP COLUMN 奖学金等级
```

```sqlite
【例3.11】 修改表XSB中已有列的属性：将名为“姓名”的列长度由原来的8改为10；将名为“出生时间”的列的数据类型由原来的datetime改为smalldatetime。
新建一个查询，在“查询分析器”中输入并执行如下脚本：
USE PXSCJ 使之成为当前数据库
GO
ALTER TABLE XSB
	ALTER COLUMN 姓名 char(10)
GO
ALTER TABLE XSB
	ALTER COLUMN 出生时间  smalldatetime
```

## 3.5  命令方式操作表数据

### 3.5.1插入记录

```sql
【例3.12】 向PXSCJ数据库的表XSB中插入如下的一行数据：
081101, 王林, 1, 1990-02-10, 计算机, 50, NULL（假设XSB表没有该行数据）：
语句如下：
INSERT INTO XSB VALUES('081101', '王林' , 1, '1990-02-10', '计算机',50, NULL)
```

```sql
【例3.13】 假设上表XSB中专业的默认值为“计算机”，备注默认值为NULL，插入上例那行数据可以使用以下命令：
INSERT INTO XSB (学号, 姓名, 性别, 出生时间, 总学分)
	VALUES('081101', '王林', 1, '1990-02-10', 50)
下列命令效果相同：
INSERT INTO XSB 
	VALUES('081101', '王林', 1, '1990-02-10', DEFAULT,50, NULL);
注意：若主键值重复，则INSERT语句插入失败。
```

```sql
【3.14】 向学生管理系统涉及的其他表中插入数据。
向KCB表加入数据的T-SQL语句示如下：
INSERT INTO KCB VALUES('101','计算机基础',1,80,5)
向CJB表加入数据T-SQL语句示如下：
INSERT INTO CJB VALUES('081101',101,80)
```

```sql
【例3.15】 从表XSB中生成计算机专业的学生表，包含学号、姓名、专业。。
用CREATE语句建立表XSB1：
CREATE TABLE XSB1
( 	num  char(6) NOT NULL PRIMARY KEY,
	name  char(8) NOT NULL,
	speiality char(10) NULL
)
用INSERT语句向XSB1表中插入数据：
INSERT INTO XSB1  --INTO可省略
	SELECT 学号, 姓名, 专业  FROM XSB  WHERE 专业= '计算机'
```

### 3.5.2  删除记录

```sql
【例3.16】 将XSB表中总学分大于52的行删除：
DELETE  FROM XSB
	WHERE 总学分>52
GO

【例3.17】 将XSB表中“备注”为空的行删除（实际不做操作）：
DELETE FROM XSB
	WHERE 备注 IS NULL
删除PXSCJ数据库的XSB表中的所有行：
DELETE XSB
```

### 3.5.3修改记录

```sql
【3.18】 将XSB表中“学号”为“081101”的学生的“备注”值改为“三好生”。
UPDATE XSB SET 备注= '三好生‘   WHERE 学号='081101'
```

```sql
【例3.19】 将XSB表中所有学生的“总学分”加10。将“罗林琳”同学的“专业”改为“软件工程”，“备注”改为“提前修完学分”。
UPDATE XSB	SET 总学分 = 总学分+10
GO
UPDATE XSB	SET 专业 = '软件工程',备注 = ‘提前修完学分
	WHERE 姓名 = '罗林琳'
GO
SELECT * FROM XSB
GO
注意：若UPDATE语句中未使用WHERE子句限定范围，UPDATE语句将更新表中的所有行。使用UPDATE可以一次更新多列的值，这样可以提高效率。
```

# 第4章  数据库的查询和视图

## 4.1  关系运算

## 4.2  数据库的查询

### 4.2.1选择列

#### 1．选择所有列

使用“*”表示选择表或视图中的所有列。

```sql
【4.1】 查询PXSCJ数据库的XSB表中的所有数据。

SELECT * FROM XSB
SELECT * FROM 练习.(dbo).XSB
```

#### 2．选择一个表中指定的列

各列名之间以逗号分隔。

```sql
【4.2】 查询PXSCJ数据库的XSB表中各个同学的姓名、专业和总学分。
SELECT 姓名,专业,总学分	FROM XSB
```

```sql
【4.3】 查询XSB表中计算机专业同学的学号、姓名和总学分，查询XSB表中的所有列。
SELECT 学号, 姓名, 总学分   FROM  XSB   WHERE 专业 = '计算机'
SELECT  *  FROM  XSB
```

![image-20211011134407036](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110111344324.png)

#### 3．定义列别名

```sql
【4.4】 查询XSB表中计算机系同学的学号、姓名和总学分，结果中各列的标题分别指定为number、name和mark。
SELECT 学号 (AS) 'number', 姓名 (AS) "name", 总学分 (AS) mark	#格式很自由
FROM  XSB WHERE 专业= '计算机'
```

![image-20211011134746873](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110111347023.png)

#### 4．替换查询结果中的数据

```sql
要替换查询结果中的数据，则要使用查询中的CASE表达式，格式为：
CASE 
	WHEN 条件1 THEN 表达式1   #满足条件  输出表达式
	WHEN 条件2 THEN 表达式2
		…
	ELSE 表达式
END
```

```sql
【4.5】 查询XSB表中计算专业学生的学号、姓名和总学分，对其总学分按以下规则进行替换：若总学分为空值，替换为“尚未选课”；若总学分小于50，替换为“不合格”；若总学分在50与52之间，替换为“合格”；若总学分大于52，替换为“优秀”。列标题更改为“等级”。
SELECT 学号, 姓名, 等级= 						#等级={case的内容}也就是列别名  
	CASE 
		WHEN 总学分 IS NULL THEN '尚未选课'   #不能写=NULL
		WHEN 总学分 < 50 THEN ‘不合格'
		WHEN 总学分 >=50 and 总学分<=52 THEN '合格'
		ELSE '优秀'
	END
	FROM  XSB	WHERE 专业= '计算机'
	
	
或者:
END as 等级也可以形成新列
```

![image-20211011140623111](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110111406418.png)

#### 5．计算列值

SELECT子句可使用表达式作为结果：

```sql
【4.6】 按120分计算成绩显示学号为081101的学生的成绩情况。
SELECT  学号, 课程号, 成绩120=成绩*1.20
	FROM CJB
	WHERE 学号= '081101'
```

该语句的执行结果如下所示：

![image-20211011140926151](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110111409347.png)

#### 6．消除结果集中的重复行

SELECT语句选择部分列时，可能会出现重复行。如，对XSB表只选择专业名，则出现多行重复的情况。可以使用DISTINCT关键字消除结果集中的重复行，其格式是：

```sql
SELECT  DISTINCT | ALL  column_name [ , column_name…]
```

```sql
【4.7】 对PXSCJ数据库的XSB表只选择专业和总学分，消除结果集中的重复行。
SELECT DISTINCT 专业,总学分
	FROM XSB
```

![image-20211011142253353](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110111423743.png)

![image-20211011142137108](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110181335033.png)

#### 7．限制结果集返回行数

```sql
#TOP选项的基本格式为：
[ TOP expression [ PERCENT ] [ WITH TIES ] ]
```

```sql
【4.8】  对PXSCJ数据库的XSB表选择姓名、专业和总学分，只返回前6行。
SELECT TOP 6 姓名,专业,总学分
	FROM XSB
```

![image-20211011142514956](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110111425201.png)

#### 9.聚合函数--经常和分组一起使用

聚合函数用于对一组值进行计算，然后返回单个值。如果一个SELECT语句中有一个GROUP BY子句，则这个聚合函数对所有组起作用。

| 函   数   名    | 说  明                                                       |
| --------------- | ------------------------------------------------------------ |
| **AVG**         | **求平均值**                                                 |
| BINARY_CHECKSUM | 返回对表中的行或表达式列表计算的二进制校验值，可用于检测表中行的更改 |
| CHECKSUM        | 返回在表的行上或在表达式列表上计算的校验值，用于生成哈希索引 |
| CHECKSUM_AGG    | 返回组中值的校验值                                           |
| **COUNT**       | **求行数，返回int类型整数**                                  |
| COUNT_BIG       | 求行数，返回bigint类型整数                                   |
| GROUPING        | 产生一个附加的列，当用CUBE或ROLLUP运算符添加行时,附加的列输出值为1,当所添加的行不是由CUBE或ROLLUP产生时,附加列值为0 |
| **MAX**         | **求最大值**                                                 |
| **MIN**         | **求最小值**                                                 |
| **SUM**         | **求和**                                                     |
| STDEV           | 返回给定表达式中所有值的统计标准偏差                         |
| STDEVP          | 返回给定表达式中所有值的填充统计标准偏差                     |
| VAR             | 返回给定表达式中所有值的统计方差                             |
| VARP            | 返回给定表达式中所有值的填充的统计方差                       |

### 4.2.2 WHERE子句(限制行)

#### 1.表达式比较

SELECT语句中WHERE子句用于选择满足条件的行。WHERE子句必须紧跟FROM子句之后，其基本格式为：

```sql
【4.16】 查询PXSCJ数据库XSB表中学号为081101同学的情况。
   SELECT 姓名,学号,总学分   FROM XSB
            WHERE 学号='081101';
```

```sql
【4.17】 查询XSB表中总学分大于50的同学的情况。
SELECT 姓名,学号,出生时间,总学分   FROM XSB
   WHERE 总学分>50;
```

```sql
【4.18】 查询XSB表中通信工程专业总学分大于等于42的同学的情况。
SELECT *  FROM  XSB
	WHERE 专业= '通信工程'  AND 总学分 >= 42
```

#### 2.模式匹配 LIKE

LIKE 谓词可使用通配符对字符串、日期或时间值进行“模糊”匹配。

| 通   配   符 | 说  明                                                       |
| ------------ | :----------------------------------------------------------- |
| %            | 代表0个或多个字符                                            |
| _            | （下画线）代表单个字符                                       |
| [字符列表]   | 指定范围（如[a-f]、[0-9]）或集合（如[abcdef]）中的任何单个字符 |
| [^字符列表] | 指定**不属于**范围（如 [^a-f]、[^0-9]）或集合（如[^abcdef]）的任何单个字符 |

```sql
【4.19】 查询XSB表中姓“王”且单名的学生情况。
        SELECT  * FROM XSB  
             WHERE 姓名 LIKE '王_ '
```

```sql
【4.20】 查询XSB表中学号中倒数第3个数字为1且倒数第1个数在1到5之间的学生学号，姓名及专业。
SELECT 学号,姓名,专业   FROM XSB
              WHERE 学号 LIKE '%1_[12345]' 
```

**如果字符串包括"_" "%":**

因为_ 代表任意单个字符。这时需要使用[ ] 或escape ‘转义字符'，转义字符可以使用任何有效的字符。

如下两种写法是正确的：

```sql
select * from   xsb   where  学号  like '%[_] '          
select * from   xsb   where  学号  like '%/_'   escape '/'
```

```sql
【4.21】 查询XSB表中名字包含下画线的学生学号和姓名。
            SELECT 学号,姓名   FROM XSB
              WHERE  学号  LIKE '%[_]%' 
      或：SELECT 学号,姓名   FROM XSB
              WHERE  学号  LIKE '%#_%'   ESCAPE '#'
```

#### 3．范围比较BETWEEN和IN。

BETWEEN关键字指出查询范围，格式为：

```sql
expression [ NOT ] BETWEEN expression1 AND expression2
```

若表达式expression的值在表达式expression1与expression2之间（包括这两个值），则返回TRUE，否则返回FALSE；使用NOT时，返回值刚好相反。

```sql
【4.22】 查询XSB表中不在1989年出生的学生情况。
    SELECT  学号, 姓名, 专业, 出生时间   FROM XSB
         WHERE 出生时间 NOT BETWEEN '1989-1-1' and '1989-12-31’
--------------------------------------------------------
        或  SELECT  学号, 姓名, 专业, 出生时间   FROM XSB
              WHERE 出生时间 < '1989-1-1' or  出生时间> '1989-12-31’
--------------------------------------------------------
     或  SELECT  学号, 姓名, 专业, 出生时间   FROM XSB
              WHERE year(出生时间) <>1989--year()内置函数
```

IN关键字可以指定一个值的列表（或子查询，后面讲），列表中列出所有可能的值。

> 相比较or,使用in可读性高

```sql
【4.23】 查询XSB表中专业为“计算机”或“通信工程”或“无线电”的学生的情况。
SELECT  *	FROM XSB
	WHERE 专业 IN ('计算机', '通信工程', '无线电')
该语句与下列语句等价：
SELECT  *	FROM  XSB
	WHERE 专业= '计算机' or 专业= '通信工程' or 专业='无线电‘

```

#### 4．空值比较

​       当需要判定一个表达式的值是否为空值时，缺省使用IS NULL关键字：

```sql
【4.24】 查询总学分尚未确定的学生情况。
SELECT  *
	FROM  XSB
	WHERE 总学分 IS NULL		
```

#### 5．CONTAINS谓词（略）

CONTAINS谓词需要创建并使用全文索引

#### 6．FREETEXT谓词（略）

#### 7．子查询

即SELECT多层嵌套。查询第一次查询结果.

##### 1.IN子查询

```sql
【4.27】 查找选修了课程号为206的课程的学生的情况。
SELECT * FROM  XSB
WHERE 学号 IN  ( SELECT 学号  FROM CJB   WHERE 课程号 = '206')
--比较
SELECT 学号  FROM CJB   WHERE 课程号 = '206'
```

![image-20211018135731655](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110181357762.png)

```SQL
未选课的学生
SELECT * FROM XSB WHERE 学号 NOT IN (SELECT 学号 FROM CJB)
```

![image-20211018140404094](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202110181404181.png)

```sql
【例4.28】 查找未选修离散数学的学生的情况。
SELECT  *  FROM  XSB  WHERE 学号 NOT IN
( SELECT 学号  FROM CJB  WHERE 课程号 IN   --这个“in”也可使用“=”
( SELECT 课程号  FROM KCB  WHERE  课程名 = '离散数学' )	)
执行结果如下所示：
```

##### 2.比较子查询。

这种子查询可以认为是IN子查询的扩展，它使表达式的值与子查询的结果进行比较运算

- ALL、SOME和ANY说明对比较运算的限制。
- ALL指定表达式要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较的关系时，才返回TRUE，否则返回FALSE。
- SOME或ANY表示表达式只要与子查询结果集中的某个值满足比较的关系时，就返回TRUE，否则返回FALSE。

```sql
【4.29】 查找选修了离散数学的学生学号。
   SELECT 学号  FROM CJB
   WHERE  课程号 (=/IN)( SELECT 课程号 FROM KCB  WHERE 课程名 ='离散数学');

【4.30】 查找比所有计算机系的学生年龄都大的学生。
   SELECT  * FROM  XSB  
   WHERE 出生时间 <ALL( SELECT 出生时间  FROM XSB  WHERE 专业= '计算机')
等价于：
   SELECT  * FROM  XSB  
   WHERE 出生时间<( SELECT min(出生时间) FROM XSB  WHERE 专业= '计算机')
```

```sql
【例4.31】 查找课程号206的成绩不低于课程号101的最低成绩的学生的学号。
SELECT 学号 FROM  CJB
	WHERE 课程号 = '206'  AND 成绩 !< ANY 
	( SELECT 成绩  FROM  CJB  WHERE 课程号 = '101')
 本例亦可用min函数实现：
      SELECT 学号FROM  CJB
	WHERE 课程号= '206'  AND 成绩!< 
	( SELECT min(成绩)  FROM  CJB  WHERE 课程号= '101')
```

##### 3.EXISTS子查询。

 EXISTS谓词用于测试子查询的结果是否为空表，若子查询的结果集不为空，则EXISTS返回TRUE，否则返回FALSE。

```SQL
【4.32】 查找选修206号课程的学生姓名。
SELECT 姓名  FROM  XSB  WHERE EXISTS
( SELECT  *  FROM  CJB  WHERE 学号 = XSB.学号 AND 课程号 = '206')
本亦可用in实现：
SELECT 姓名  FROM  XSB  WHERE 学号in
	( SELECT  学号 FROM  CJB  WHERE 课程号= '206')
```

### 4.2.3 FROM子句

```sql
【4.36】 查找“081101”号学生课程名为“计算机基础”的课程成绩。
SELECT 成绩	FROM CJB,KCB
	WHERE CJB.课程号=KCB.课程号
		AND 学号='081101' 
		AND 课程名='计算机基础'
```

### 4.2.4  连接表

#### 1．基于连接谓词的连接

```sql
【4.42】 查找PXSCJ数据库每个学生的情况以及选修的课程情况。
SELECT  *   FROM  XSB , CJB  WHERE XSB.学号 = CJB.学号

【4.43】 自然连接查询。（去掉重复的列）
SELECT   XSB.* , CJB.课程号, CJB.成绩	
FROM XSB , CJB  WHERE XSB.学号= CJB.学号
```

```sql
【4.44】 查找选修了206课程且成绩在80分以上的学生姓名及成绩。
  SELECT 姓名, 成绩
	FROM XSB , CJB
	WHERE XSB.学号 = CJB.学号 AND 课程号 = '206' AND 成绩 >= 80

【4.45】 查找选修了“计算机基础”课程且成绩在80分以上的学生学号、姓名、课程名及成绩。
  SELECT XSB.学号, 姓名, 课程名, 成绩
	FROM  XSB , KCB , CJB   --多表连接
	WHERE  XSB.学号 = CJB.学号 
		AND  KCB.课程号 = CJB.课程号
		AND  课程名 = '计算机基础'  
		AND  成绩 >= 80
```

#### 2．以JOIN关键字指定的连接

##### （1）内连接：INNER JOIN 

内连接按照ON所指定的连接条件合并两个表，**只返回满足条件的行**。其中的INNER关键字可省略。

```sql
【4.46】 查找每个学生的情况以及选修的课程情况。
SELECT  *  FROM  XSB  JOIN  CJB  ON  XSB.学号 =CJB.学号
```

```sql
【4.47】 查找选修了206课程且成绩在80分以上的学生姓名及成绩。（使用JOIN关键字）
SELECT 姓名, 成绩  FROM XSB JOIN CJB  ON XSB.学号 = CJB.学号 
	   WHERE 课程号 = '206'  AND 成绩>=80
```

```sql
【4.48】 用FROM子句的JOIN关键字表达下列查询：查找选修了“计算机基础”课程且成绩在80分以上的学生学号、姓名、课程名及成绩。
SELECT  XSB.学号, 姓名, 课程名, 成绩
      FROM XSB JOIN CJB JOIN KCB  
	          ON  CJB.课程号 = KCB.课程号  
	          ON  XSB.学号 = CJB.学号 
	WHERE 课程名= '计算机基础'  AND 成绩>=80
或
SELECT  XSB.学号, 姓名, 课程名, 成绩
      FROM XSB JOIN CJB ON XSB.学号 = CJB.学号
               JOIN KCB ON CJB.课程号 = KCB.课程号  
      WHERE 课程名= '计算机基础'  AND 成绩>=80
错误：
SELECT  XSB.学号, 姓名, 课程名, 成绩
      FROM XSB JOIN CJB JOIN KCB
ON  XSB.学号 = CJB.学号
ON  CJB.课程号 = KCB.课程号  
	WHERE 课程名= ‘计算机基础’  AND 成绩>=80
```

##### （2）外连接(无法连接自动填充NULL)

**强行连接**,可以找出连不上的

外连接包括三种：

- 左外连接（LEFT OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括左表的所有行；
- 右外连接（RIGHT OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括右表的所有行；
- 完全外连接（FULL OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括两个表的所有行。

其中的OUTER关键字均可省略。

```sql
【4.50】 查找所有学生情况及他们选修的课程号，若学生未选修任何课，也要包括其情况。
 SELECT XSB.* , 课程号
	FROM  XSB  LEFT JOIN CJB 
		ON  XSB.学号 = CJB.学号

【4.51】 查找被选修了的课程的选修情况和所有开设的课程名。
 SELECT CJB.* , 课程名
	FROM CJB RIGHT JOIN  KCB 
		ON  CJB.课程号= KCB.课程号
```

##### （3）交叉连接：CROSS JOIN(无条件,等价笛卡尔积)

```sql
【4.52】 列出学生所有可能的选课情况。
SELECT * FROM XSB CROSS JOIN KCB 
交叉连接实际上就是无条件链接，本等价于：
SELECT * FROM XSB , KCB
```

### 4.2.5  GROUP BY子句--经常和聚合函数一起用

GROUP BY子句主要用于根据字段对行分组。

```sql
【4.53】 将PXSCJ数据库中各专业输出。
SELECT 专业
	FROM   XSB
	GROUP  BY 专业
```

```sql
【4.54】 求各专业的学生数。
SELECT 专业 , COUNT(*) AS '学生数'	FROM   XSB  GROUP  BY 专业
```

```sql
【4.55】 求被选修的各门课程的平均成绩和选修该课程的人数。
SELECT 课程号 , AVG(成绩) AS '平均成绩' , COUNT(学号) AS '选修人数'
FROM CJB  GROUP BY课程号
```

```sql
【4.56】 查询每个专业的男生、女生人数，按专业的小计人数及学生总人数。
SELECT  CASE WHEN GROUPING(专业)=1 THEN '总计:' ELSE 专业 END as 专业名称, 性别,COUNT(*) AS '人数'
 FROM   XSB
GROUP  BY 专业,性别      /*先按专业分组，再按性别分组*/
WITH  ROLLUP                 /*增加分组合计及总合计行。 */
```

![image-20211101135614797](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111011356043.png)

```sql
【4.58】 查询每个专业的男生、女生人数，按专业的小计人数、按性别的小计人数及学生总人数。
SELECT 专业, 性别, COUNT(*) AS '人数'
	FROM XSB
	GROUP BY 专业,性别 
	WITH CUBE
```

### 4.2.6  HAVING子句--和group by一起使用

把Group By查询结果再次限定

```sql
【4.61】 查找平均成绩在85分以上的学生的学号和平均成绩。
SELECT 学号, AVG(成绩) AS '平均成绩'  FROM CJB
	GROUP BY 学号
	HAVING  AVG(成绩) > =85
```

```sql
【4.62】 查找有2门及以上的成绩在80分以上的学生的学号。
SELECT 学号 FROM CJB WHERE 成绩 >= 80 GROUP BY 学号 HAVING   COUNT(*) > 2
或：
SELECT * from (SELECT 学号,COUNT(*) as 门数FROM CJBWHERE 成绩>= 80 GROUP BY 学号) as t1 where t1.门数>=2
```

```sql
【4.63】 查找通信工程专业平均成绩在85分以上的学生的学号和平均成绩。
SELECT 学号, AVG(成绩) AS '平均成绩'FROM CJB
WHERE 学号 IN (SELECT 学号  FROM  XSB  WHERE 专业 = ‘通信工程’)
GROUP BY 学号
HAVING AVG(成绩) > =85
```

```sql
select 专业,count(*)as 人数
From xsb group by 专业
having count(*)>10

select * from (select 专业,count(*)as 人数
from xsb group by 专业)t1
where 人数>10
```

### 4.2.7  ORDER BY子句

ORDER BY子句对查询结果进行排序。

```sql
【4.64】 将通信工程专业的学生按出生时间先后排序。
SELECT  *  FROM  XSB
	WHERE 专业= '通信工程'
	ORDER BY 出生时间 ASC
```

```sql
【4.65】 将计算机专业学生的“计算机基础”课程成绩按降序排列。
SELECT 姓名, 课程名, 成绩  FROM XSB, KCB, CJB
     WHERE XSB.学号 = CJB.学号 
	AND  CJB.课程号 = KCB.课程号 
	AND  课程名= '计算机基础'
	AND 专业= '计算机'
    ORDER BY 成绩 DESC  --降序
```

### 4.2.8  SELECT语句的其他语法

#### 1．INTO --结果插入已有表

使用INTO子句可以将SELECT查询所得的结果保存到一个已新建的表中

```sql
【4.68】 由XSB表创建“计算机系学生”表，包括学号和姓名。
SELECT 学号, 姓名
	INTO计算机系学生
	FROM XSB
	WHERE 专业= ‘计算机’
```

#### 2．UNION--2个结果合并

使用UNION子句可以将两个或多个SELECT查询的结果合并成一个结果集

使用UNION组合两个查询的结果集的基本规则是： 
*（1）所有查询中的列数和列的顺序必须相同。*

*（2）数据类型必须兼容。* 
关键字ALL表示合并的结果中不去除重复行；不使用ALL则在合并的结果去除重复行。
含有UNION的SELECT查询也称为联合查询。

```sql
【4.69】 查找学号为081101和学号为081210两位同学的信息。
SELECT * FROM XSB WHERE 学号= '081101'
UNION ALL
SELECT * FROM XSB WHERE 学号= '081210';
```

#### 3．EXCEPT和INTERSECT

EXCEPT和INTERSECT用于比较两个查询的结果，返回非重复值。

```sql
【4.70】 查找专业为计算机但性别不为男的学生信息。
SELECT * FROM XSB WHERE 专业= '计算机'
EXCEPT
SELECT * FROM XSB WHERE 性别=1   /*1男 0女*/
```

```sql
【4.71】 查找总学分大于42且性别为男的学生信息。
SELECT * FROM XSB WHERE 总学分>42
INTERSECT
SELECT * FROM XSB WHERE 性别=1
```

## 4.3  视图

### **4.3.1** **视图概念**

视图是一个`虚拟表`，其内容由查询定义。但视图并`不存储数据`，视图数据来自由定义视图的查询所引用的表（第二章中已给出定义）

使用视图有下列优点：

   *（1）简单性：如可屏蔽表连接等复杂操作。*

   *（2）安全性：简化用户权限的管理，将用户限制在数据的不同子集上。*

   *（3）逻辑数据独立性：基本表的改变只需改变视图，而无需修改应用程序。*

### 4.3.2  创建视图

```sql
【 4.74】 创建UV_JSJ视图，要求如下：
1）包括计算机专业所有学生的学号、选修的课程号、成绩、专业名称。
2）要保证对该视图的修改都要符合专业为计算机这个条件。
3）使用视图UV_JSJ查找计算机专业的学生学号和选修的课程号。
DROP VIEW UV_JSJ
go
CREATE VIEW  UV_JSJ   AS 
    SELECT  XSB.学号, 课程号, 成绩,专业  FROM   XSB,  CJB
    WHERE  XSB.学号=CJB.学号  AND   专业= '计算机'
	WITH   CHECK OPTION#强制针对视图执行的所有数据修改语句都必须符合在定义视图时的SELECT语句中设置的条件。通过视图修改行时，WITH CHECK OPTION 可确保提交修改后，仍可通过视图看到数据。如果在定义视图的语句中的任何位置使用 TOP，则不能指定 CHECK OPTION。

```

```sql
【 4.77】 查找平均成绩在80分以上的学生的学号和平均成绩。
--首先创建学生平均成绩视图。
 CREATE VIEW  V_CJ_AVG(学号,平均成绩)  
	AS
	SELECT 学号, AVG(成绩)  FROM  CJB   GROUP BY 学号
--再对XS_KC_AVG视图进行查询：
 GO
 SELECT  *  FROM  V_CJ_AVG  WHERE  平均成绩>= 80

```

### 4.3.4  更新视图

**1．可更新视图**

可更新视图是指可通过视图更新基本表数据。

一个可更新视图可以是以下情形之一：

*（1）可更新的普通视图：*

创建视图的SELECT语句中没有聚合函数，且没有TOP、GROUP BY、UNION子句及DISTINCT关键字。

创建视图的SELECT语句中不包含从基本表列通过计算所得的列。

创建视图的SELECT语句的FROM子句中至少要包含一个基本表。

*（2）可更新的分区视图。*

在实现分区视图之前，必须先实现水平分区表。原始表被分成若干个较小的成员表，每个成员表包含与原始表相同数量的列，并且每一列具有与原始表中的相应列同样的特性（如数据类型、大小、排序规则）。

*（3）通过INSTEAD OF触发器创建的可更新视图。*

**2．插入数据**

```sql

使用INSERT语句通过视图向基本表插入数据，与对基本表的插入方式相同。
【 4.78】 向CS_XS视图中插入以下一条记录：
INSERT INTO CS_XS
	VALUES('081115', '刘明仪', 1,'1998-3-2', '计算机',50,NULL)
当视图所依赖的基本表有多个时，不能向该视图插入数据。
```

**3．修改数据**

```sql
【例 4.79】 将CS_XS视图中所有学生的总学分增加8。
UPDATE CS_XS	SET 总学分=总学分+ 8
```

该语句实际上是基本表XSB中所有专业为“计算机”的记录的总学分字段值在原来基础上增加8。
若一个视图依赖于多个基本表，则一次修改该视图只能变动一个基本表的数据。

```sql
【例 4.80】 将CS_KC视图中学号为081101的学生的101课程成绩改为90。
UPDATE CS_KC	SET 成绩=90
	WHERE 学号='081101'  AND 课程号='101‘
以下的修改是错误的：
UPDATE CS_KCSET 学号=‘081120’,课程号=‘208’/*因学号源于XSB表，课程号源于CJB表 */
	WHERE 成绩=90
```

**4．删除数据**

```sql
【例 4.81】 删除CS_XS中女同学的记录。
DELETE  FROM  CS_XS 	WHERE 性别 = 0
对视图的更新操作也可通过“SQL Server Management Studio”的界面进行，操作方法与对表数据的插入、修改和删除的界面操作方法基本相同，在此从略。
```

### 4.3.5  修改视图的定义

**ALTER VIEW语句修改视图**

```sql
【例 4.83】 将CS_XS视图修改为只包含计算机专业学生的学号、姓名和总学分。
ALTER VIEW CS_XS
	AS
	SELECT 学号, 姓名, 总学分
		FROM XSB
		WHERE 专业= '计算机'
```

```sql
【例 4.84】 视图CS_KC是加密存储视图，修改其定义：包括学号、姓名、选修的课程号、课程名和成绩。
ALTER VIEW CS_KC WITH ENCRYPTION
	AS 
	SELECT XSB.学号,XSB.姓名,CJB.课程号,KCB.课程名,成绩
		FROM  XSB, CJB, KCB
		WHERE  XSB.学号 = CJB.学号 
			AND  CJB.课程号 = KCB.课程号
			AND  专业= '计算机'
	WITH CHECK OPTION
```

### 4.3.6  删除视图

**1．通过“对象资源管理器”删除视图**
同删除其他对象。
**2．T-SQL命令方式删除视图**
语法格式：

```sql
DROP VIEW [ schema_name . ] view_name [ ...,n ] [ ; ]
```

其中view_name是视图名，使用DROP VIEW可删除一个或多个视图。例 如：

```sql
DROP VIEW CS_XS, CS_KC
```

将删除视图CS_XS和CS_KC。

## 4.4游标(不讲)

# 第5章  T-SQL语言

## 5.1  SQL语言与T-SQL语言

T-SQL是SQL语言的一种版本，只能用于微软MS SQL-Server以及Sybase Adaptive Server系列数据库。T-SQL除了提供标准的SQL命令之外，还提供了变量说明、流控制语言、功能函数等。

## 5.2  常量、变量与数据类型

### 5.2.1  常量

按类型分为：字符串常量、整型常量、实型常量、日期时间常量、货币常量、唯一标识常量等。

### 5.2.3  变量

**1．变量**
SQL Server中变量可分为两类：*全局变量，局部变量*
全局变量：全局变量由`系统提供且预先声明`，以“`@@`”开头。T-SQL全局变量作为函数引用。例 如，@@ERROR返回执行的上一个T-SQL语句的错误号；@@CONNECTIONS返回自上次启动SQL Server以来连接或试图连接的次数。全局变量的意义及使用请参考附录A。

局部变量：局部变量以`@`开头。例 如，保存运算的中间结果，作为循环变量等。

**2．局部变量及局部游标变量**
（1）局部变量
①局部变量的定义：用DECLARE声明，初始值为NULL。
语法格式：

```sql
DECLARE { @变量名   数据类型}  [ ,...n]
```

②局部变量的赋值：用SET或SELECT。

```sql
SET  @变量名＝表达式
```

```sql
SELECT {@变量名＝表达式} [,…n]
```

```sql
【例 5.1】 创建局部变量@var1、@var2并赋值，然后输出变量的值。
新建一个查询，在“查询分析器”窗口输入并执行如下脚本：
DECLARE @var1 char(10) ,@var2 char(30)
SET  @var1='中国'	     /*一个SET语句只能给一个变量赋值*/
SET  @var2=@var1+'是一个伟大的国家'
SELECT @var1, @var2
```

```sql
【例 5.2】 局部变量用于查询条件中。
DECLARE @sex bit
SET @sex=0
SELECT 学号, 姓名  FROM  XSB  WHERE 性别=@sex
```

```sql
【例5.3】 使用查询给变量赋值。
DECLARE @student char(8)
SET @student=(SELECT 姓名 FROM XSB WHERE 学号= '081101')
--或SELECT @student=姓名 FROM XSB WHERE 学号= '081101'
SELECT @student
```

```sql
【例5.4】 使用SELECT给局部变量赋值。
DECLARE @var1 nvarchar(30)
SELECT @var1 =‘刘丰’     --赋值
SELECT  @var1 AS ‘NAME’  --输出
```

## 5.3  运算符与表达式

```sql
【例5.13】 多个字符串的联接。
SELECT  (学号+  ',' + 姓名) AS 学号及姓名
	FROM XSB  WHERE 学号= '081101'
```



## 5.4  流程控制语句

流程控制语句可以改变计算机的执行顺序。流程控制语句如表5.11所示。

| 控 制 语 句 |     说  明     | 控 制 语 句 |         说  明         |
| :---------: | :------------: | :---------: | :--------------------: |
|  BEGIN…END  |     语句块     |  CONTINUE   | 用于重新开始下一次循环 |
|   IF…ELSE   |    条件语句    |    BREAK    |  用于退出最内层的循环  |
|    CASE     |    分支语句    |   RETURN    |       无条件返回       |
|    GOTO     | 无条件转移语句 |   WAITFOR   |  为语句的执行设置延迟  |
|    WHILE    |    循环语句    |             |                        |

### 5.4.1  BEGIN…END语句块

BEGIN…END用于定义语句块：
当多条T-SQL语句作为一组语句来执行时，就需要定义语句块。语法格式如下：

```sql
BEGIN 
	…
END 
例 如：
   BEGIN
	   SELECT * FROM XSB
	   SELECT * FROM KCB
   END
```

BEGIN…END可以嵌套使用。

### 5.4.2  条件语句

语法格式：

     IF   条件表达式	  
         语句或语句块 /*条件表达式为真时执行*/
     [ ELSE
         语句或语句块 ] /*条件表达式为假时执行*/


### 5.4.3  CASE语句

CASE语句在4.2.1小节介绍选择列的时候已经涉及过。这里介绍CASE语句在流程控制中的用法，与之前略有不同。
语法格式：

```sql
CASE 表达式 
   WHEN 表达式值 THEN  结果表达式1 
   [ ...n ] 
   [ ELSE  结果表达式n+1  ] 
END 
```

或者：

```sql
CASE
   WHEN 布尔表达式 THEN  结果表达式1 
   [ ...n ] 
   [  ELSE  结果表达式n+1  ] 
END
```

```sql
例 ：declare @性别 bit,@xb char(2)
    select @性别=性别 from xsb where 学号='081102' #赋值
    select @xb=
    CASE 
	   WHEN @性别=1 THEN '男'#非赋值语句
	   WHEN @性别=0 THEN '女'
    END
    print @xb
或：#####################################################
     declare @性别 bit,@xb char(2)
     select @性别=性别 from xsb where 学号='081102'    
     select @xb=
     CASE @性别
	    WHEN 1 THEN '男'
	    WHEN 0 THEN '女'
     END
     print @xb
```

### 5.4.5  循环语句

```sql
【例 5.18】 将学号为081101的学生的总学分使用循环修改到大于等于60，每次只加2，并判断循环了多少次。
DECLARE @num INT
SET @num=0
WHILE (SELECT 总学分 FROM XSB WHERE 学号='081101')<60
BEGIN
	UPDATE XSB SET 总学分=总学分+2 WHERE 学号= '081101'
	SET @num=@num+1
END
SELECT @num AS 循环次数
```

```sql
【例 5.19】 判断是否存在学号为081128的学生，如果存在则返回，不存在则插入081128的学生信息。
IF EXISTS(SELECT * FROM XSB WHERE 学号='081128')
	RETURN
ELSE
	INSERT INTO XSB VALUES('081128', '张可', 1, '1990-08-12', '计算机',52, NULL)
```



## 5.5  系统内置函数

### 一．行集函数（本部分从略）

### 二．聚合函数

第4章已有介绍。

### 三．标量函数

**1、数学函数（最常用的）**
 *abs(数值)*            求绝对值
 *pi()*                 3.1415926.........
 *rand([整数])*           随机数产生器
 *round(数值,小数位数)*    按“小数位数”规定的精度四舍五入
 *sqrt(数值)*             平方根
 …

**2、字符转换函数**
（1） *ASCII()*：返回字符表达式最左端字符的ASCII 码值。

（2） *CHAR()将ASCII 码转换为字符*。输入0 ~ 255 之间的ASCII 码值。否则 返回NULL 。

（3） *LOWER()和UPPER()* 将字符串全部转为小写、大写。

（4） *STR()* 把数值型数据转换为字符型数据。

**3、字符串处理函数（最常用的）**

 （1） *LTRIM()* 去掉字符串左部空格。

 （2） *RTRIM()* 去掉字符串右部空格。

 （3） *LEFT* (`<character_expression>， <integer_expression>`)
 返回character_expression 左起 integer_expression 个字符。

 （4） *RIGHT* (`<character_expression>， <integer_expression>`)
 返回character_expression 右起 integer_expression 个字符。

 （5） *SUBSTRING* (`<expression>， <starting_ position>， length`)
 返回从字符串左边第starting_ position 个字符起length个字符的部分。 

**4、数据类型转换函数：CAST和CONVERT**
    常用的类型转换有：*日期型→字符型、字符型→日期型、数值型→字符型*等。
语法格式：
    

```sql
 CAST (表达式 AS  新类型) 
     CONVERT ( 新类型 ,表达式 [, style])
```

​    新类型不能为用户自定义类型。对于不同的表达式类型转换，参数style的取值不同。style的常用取值及其作用参阅教材表5.13～表5.15所示。

```sql
例 如：select * from xsb where CONVERT( char(10),总学分) like '5%'
```

**5、日期时间函数 (最常用部分)**
  附录A中列出了大多数的日期时间函数。
*（1）GETDATE函数。*

​    语法格式：

  `GETDATE ()`

​    `返回当前系统日期和时间`。返回值类型为datetime。
*（2）YEAR、MONTH、DAY函数。*
​    这三个函数分别返回指定日期的年、月、天部分，返回值都为整数。
​    语法格式：
​    `YEAR(date)`
​    `MONTH(date)`
​    `DAY(date)`
*（3） DATEDIFF()*

语法格式： 

```sql
DATEDIFF (<datepart>， <date1>， <date2>)   
```

返回两个指定日期在datepart 方面date2 超过date1的差距值，其结果值是一个带有正负号的整数值。    如：

```sql
select DATEDIFF(month'2013-01-31','2014-01-02')  
--返回12
```

6.游标(略)

**7．元数据函数**
    元数据函数用于返回有关数据库和数据库对象的信息。
**（1）DB_ID函数**
    语法格式：`DB_ID ( [ 'database_name' ] )` 
    *根据数据库名，返回数据库标识（ID）号。*
    如果不指定database_name ，则返回当前数据库ID，返回值类型为smallint。

```sql
       例 如： if  db_id('练习')   is  not  null
                         drop   database   练习
                   go
                   CREATE   DATABASE   练习
```

**（2）DB_NAME函数**
    语法格式：`DB_NAME ( database_id )` 
    *根据数据库ID，返回数据库名。*
    如果没有指定数据库ID，则返回当前数据库名。返回值类型为nvarchar(128)。

**（3）OBJECT_ID** 
语法格式：`OBJECT_ID ( 'object_name' [ ,'object_type' ] )`
*返回数据库中对象的ID号* ，返回值类型为smallint。
       例 如：

```sql
USE 练习; 
GO
IF OBJECT_ID ('dbo.XSB')  IS  NOT  NULL 
     DROP TABLE dbo.XSB; 
GO 
```

### 5.6.1  用户函数的定义与调用

#### **1．标量函数**

（1）标量函数的定义。
语法格式：

```sql
   CREATE FUNCTION [架构名.] 函数名
       ( 参数1 类型1 [ = 默认值 ] ) [ ,...参数n 类型n [ = 默认值 ] ] ] ) 
   RETURNS 返回值类型
   [ WITH 选项 ] 
   [ AS ]
   BEGIN
	函数体
	RETURN 标量表达式
   END
```

其中：

```sql
 <选项 >::= 
   {
      [ ENCRYPTION ]
      | [ SCHEMABINDING ]
      | [ RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT ]
      | [ <EXECUTE_AS_Clause> ]
    }
```



```sql
【例 5.31】 创建用户定义函数，计算给定课程号的平均成绩。
CREATE FUNCTION average(@cnum char(20)) 
RETURNS int
	AS
	BEGIN
		DECLARE @aver int
		SELECT @aver=avg(成绩) 	FROM CJB  WHERE  课程号=@cnum
		RETURN @aver
	END
GO
```

或者

```sql
CREATE FUNCTION average(@cnum char(20)) 
RETURNS int
	AS
	BEGIN
		RETURN SELECT @aver=avg(成绩) 	FROM CJB  WHERE  课程号=@cnum
	END
GO
```

**（2）标量函数的调用。** *当调用用户定义的标量函数时，必须提供至少由两部分组成的名称（架构名.函数名）。*
可用以下方式调用标量函数：
在SELECT语句中调用
调用形式：`架构名.函数名(实参1,…,实参n)`
实参可为已赋值的局部变量或表达式。

```sql
【例 5.32】 调用例  5.31定义的函数average。
select  dbo.average('101')   #显示101号课程的平均成绩(DBO不可省略)
select  学号,课程号,成绩,dbo.average(课程号) as 平均成绩 from cjb 
```

利用EXEC语句执行
    调用形式：
        `EXEC @变量名=架构名.函数名 实参1,…,实参n` 
    或：
        `EXEC @变量名=架构名.函数名 形参名1=实参1,…, 形参名n=实参n`

```sql
【例 5.33】 EXEC调用例 5.31中计算平均成绩的函数。
     DECLARE @平均成绩 int
     EXEC @平均成绩= dbo.average @cnum ='101' 	 /*@cnum为定义函数时的形式参数*/
     SELECT @平均成绩 AS '101课程的平均成绩'
```

```sql
【例 5.34】 建立一个course表，并将一个字段定义为计算列。
CREATE TABLE course
(
	课程号	 int,        	/*课程号*/
	课程	 char(20),   	/*课程名*/
	学分        int,         	/*学分*/
	平均成绩   AS  (dbo.average(课程号)) /*此列为计算列*/
)
go
insert   course(课程号,课程,学分)   values('101','计算机基础',5)
select  *  from  course
```

#### **2．内嵌表值函数**

返回值的类型为表。可用于实现参数化视图。
例 如：有如下视图：

```sql
CREATE VIEW View1 AS  SELECT 学号, 姓名  FROM  XSB  WHERE  专业= '计算机'
```

而视图**不支持**在WHERE子句中指**定变量参数**，因此可定义内嵌表值函数： 

```sql
CREATE FUNCTION uf_View1( @Para nvarchar(30) )
RETURNS TABLE
AS  RETURN
(
   SELECT 学号, 姓名  FROM  XSB   WHERE  专业= @para
)
GO
/*内嵌函数的调用*/
SELECT  *  FROM uf_View1('计算机')
```

**（1）内嵌表值函数的定义。**
 语法格式：

```sql
  CREATE FUNCTION   函数名( [@参数名  参数类型[ = 缺省值] [ ,...n ] ])	 /*定义参数部分*/
  RETURNS TABLE			       /*返回值为表类型*/
     [ AS ]
     RETURN  SELECT语句
```

**（2）内嵌表值函数的调用。**
        *内嵌表值函数只能通过SELECT语句调用。*
        内嵌表值函数调用时，可以仅使用函数名。

#### **3．多语句表值函数**

它的返回值也是一个表，但它和标量型函数一样有一个用BEGIN-END 语句括起来的函数体，返回表中的数据是由函数体中的语句插入的。
例 ：

```sql
CREATE FUNCTION xsqk(@专业 char(6)) 
RETURNS  @学生情况表  TABLE (学号 char(6),  姓名 char(8),  专业 char(12) ) 
AS 
BEGIN
     INSERT @学生情况表  SELECT 学号,姓名,专业  FROM XSB       WHERE 专业=@专业 
     RETURN 
END

go
select  * from  xsqk('计算机') 
```



# 第6章  索引与数据完整性

## 6.1  索引

### 6.1.1  索引的分类

#### 1．聚簇索引 (又叫聚集索引)

聚簇索引的顺序就是数据的物理存储顺序。每个表只有一个聚簇索引。
SQL Server 2005是按B树（BTREE）方式组织聚簇索引的。聚簇索引的叶节点就是数据节点。由于数据记录按聚簇索引键的次序存储，因此查找效率高。
除非在创建主键时特别指定，否则创建主键时会自动创建聚簇索引。

```sql
create table aa
(
  a1  char(10)  not  null  primary key nonclustered –主键列上未创建聚簇索引
 )
```

#### 2．非聚簇索引

索引顺序与数据物理顺序无关 。
非聚簇索引也是按B树方式组织的，但非聚簇索引B树的叶节点不存放数据页信息，而是存放非聚集索引的键值，并且每个键值项都有指针指向包含该键值的数据行。
一个表中可有多个非聚集索引。创建索引时，可指定是按升序还是降序。
可参考：http://www.cnblogs.com/zhenyulu/articles/25794.html

### 6.1.2  索引的创建

#### 利用SQL命令建立索引

使用CREATE INDEX命令可以为表创建索引（亦可为视图创建索引）。
语法格式：

```sql
【例6.1】 为KCB表的课程名列创建索引。
CREATE INDEX  kc_name_ind 
	ON KCB(课程名)
```

```sql
【例6.2】 根据KCB表的课程号列创建唯一聚集索引，因为指定了CLUSTERED，所以该索引将对磁盘上的数据进行物理排序（注：本例必须先删除原有主键）。 
CREATE UNIQUE CLUSTERED INDEX kc_id_ind 
 	ON  KCB(课程号)
```

### 6.1.3  重建索引

索引使用一段时间后，可能需要重新创建，这时可以使用ALTER INDEX语句来重新生成原来的索引(从略)。

#### 通过SQL命令删除索引

语法格式：
DROP INDEX  表名或视图名.索引名

```
【例6.3】 ： 删除【例6.1】 创建的索引kc_name_ind 
      DROP INDEX  KCB.kc_name_ind 
```

## 6.2  默认值约束及默认值对象

### 6.2.1  在表中定义及删除默认值约束

#### 1．默认值约束DEFAULT的定义

定义一个字段的默认值约束的方法参见第3章，这里不再赘述，仅举例如下：

```sql
【例6.8】 在定义表时定义一个字段的默认值约束。
CREATE TABLE XSB2
(   …
   入学日期 datetime DEFAULT getdate() 	/*定义默认值约束*/
) 
或者
CREATE TABLE XSB2
(   …
   入学日期 datetime CONSTRAINT datedflt DEFAULT getdate() /*定义默认值约束*/
 ) 

```

#### 2．默认值约束的删除

图形界面方式删除（从略）。
使用ALTER TABLE语句删除：需要已知约束名 。

```
【例6.10】 删除例6.9定义的默认值约束。
ALTER TABLE XSB2
	DROP CONSTRAINT AddDateDflt
```

AddDateDflt为约束名。

### 6.2.2  默认值对象的定义、使用与删除

#### 1．定义和绑定DEFAULT默认值对象

也可将默认值定义成一个对象，然后将该对象绑定到表的字段。
*（1）定义默认值对象。*
语法格式：

```sql
CREATE DEFAULT  默认值对象名
```

​	AS 常量表达式 
*（2）绑定默认值对象。*
常用格式：

```sql
sp_bindefault [ @defname = ] '默认值对象名 ' ,
	[ @objname = ] ‘表名.列名 ’
```

```sql
【例6.11】 首先定义表book及名为 today 的默认值，然后将其绑定到 book表的hire_date列。
1)定义表
CREATE TABLE book
(
	book_id  		char(6),
	name   		varchar(20)  NOT NULL,
	hire_date   	datetime  NOT NULL
)
2)定义名为 today 的默认值
CREATE DEFAULT today  AS getdate()  --'CREATE DEFAULT' 必须是批查询中的第一条语句。
3)将默认值对象绑定到 book表的hire_date列
EXEC sp_bindefault 'today', 'book.hire_date'
```

#### 2．默认值对象的删除

分为两步：
*（1）解除绑定。*

```sql
sp_unbindefault [@objname =] ‘表名.列名 ’
```

*（2）删除默认值对象。*
DROP DEFAULT { default } [ ,...n ]

```sql
【例6.12】 解除默认值对象today与表book的hire_date列的绑定关系，然后删除该对象。
EXEC sp_unbindefault 'book.hire_date'
GO
DROP DEFAULT today 
```

## 6.3  数据完整性

### 6.3.1  数据完整性的分类

包括实体完整性、参照完整性、域完整性、用户自定义的完整性。
实体完整性: **要求每一个表中的主键字段都不能为空或者重复的值。**
参照完整性是由外码（外键） 实现的完整性，指一个表中的字段的值或者为空，或者来自另一个表的主码（主键）。
域完整性又称为列完整性，指给定列输入的有效性。如：限制数据类型、CHECK约束、DEFALUT、NOT NULL和规则等。
注：有些资料对域完整性和用户定义的完整性不加区分，因此将完整性定义为3种。

### 6.3.2  实体完整性的实现

#### 利用“T-SQL命令”创建及删除PRIMARY KEY约束或UNIQUE约束

​    利用T-SQL命令可以使用两种方式定义约束：作为列的约束或作为表的约束。
*（1）创建表的同时创建PRIMARY KEY约束或UNIQUE约束。*

```sql
   【例6.14】 ：
    CREATE TABLE  XSB1
        (学号 char(6)  not  null  PRIMARY KEY,
         姓名 char(8)  UNIQUE,
         性别 bit null default 1,--1男0女
         出生时间 datetime null, 
         专业 char(12) null,
         总学分 int null default 0 check(总学分>=0 and 总学分<160),
         备注 varchar(500) null,
        )
       go
       insert XSB values('081101','王林',1,'1990-2-10','计算机',50,null)
       insert XSBvalues('081102','王林'  ,1,'1991-2-1'  ,'计算机',50,null)
```

​       将会提示违反了 UNIQUE KEY 约束 错误

*（2）通过ALTER TABLE创建或删除PRIMARY KEY或UNIQUE约束。*
语法格式参见第3章中ALTER TABLE语句的ADD子句。

```sql
【例6.16】 修改例6.14中的XSB1表，添加“身份证号码”字段并定义UNIQUE约束。对“出生时间”字段定义UNIQUE约束。
ALTER TABLE  XSB1    
	ADD    身份证号码 char(20) 
	CONSTRAINT UK_sfzhm   UNIQUE NONCLUSTERED(身份证号码)  – NONCLUSTERED可选
GO
ALTER TABLE  XSB1    
	ADD    CONSTRAINT CJSJ_UK  UNIQUE (出生时间)
```

```sql
【例6.17】 删除例6.16中创建的UK_sfzhm  UNIQUE约束。
ALTER TABLE  XSB1 
	DROP    CONSTRAINT UK_sfzhm 
```

### 6.3.3  域完整性的实现

#### 1．CHECK约束的定义与删除

*利用SQL语句在创建表时创建CHECK约束*

语法如下：

```sql
CHECK [ NOT FOR REPLICATION ] ( logical_expression )
```

NOT FOR REPLICATION：当复制代理执行插入、更新或删除操作时，不执行此约束。
logical_expression：称为CHECK约束表达式，为条件表达式。

```sql
【例6.18】 创建一个表student，性别只能为男或女，出生日期必须晚于1993年1月1日。
     CREATE  TABLE  student
      (	
      学号 char(6) NOT NULL,
      性别 char(1) NOT NULL CHECK(性别 IN ('男', '女')) , --列级约束
      出生日期 datetime  NOT NULL,
      CONSTRAINT  DF_student CHECK(出生日期>‘1980-01-01’)  --表级约束
      )
```

```sql
【例6.20】 创建表student2，有学号、最好成绩和平均成绩三列，要求最好成绩必须大于平均成绩。
CREATE  TABLE  student2
 (	
	学号 char(6)  NOT NULL,
 	最好成绩 INT  NOT NULL,
	平均成绩 INT  NOT NULL,
 	CHECK(最好成绩>平均成绩)
)
```

 以下定义错误：

```sql
CREATE  TABLE  student2
 (	
学号 char(6)   NOT NULL,
最好成绩 INT  NOT NULL,
平均成绩 INT  NOT NULL  CHECK(最好成绩>平均成绩) –不可为行级约束
)
```

*利用ALTER TABLE创建、删除CHECK约束*
    ALTER TABLE语句的语法格式参见第3章。

```sql
   【例6.21】 通过修改PXSCJ数据库的CJB表，增加成绩字段的CHECK约束。
     ALTER TABLE CJB     
	ADD CONSTRAINT cj_constraint  CHECK  (成绩>=0 AND 成绩<=100) 
```

```sql
 【例6.22】 删除CJB表成绩字段的CHECK约束。
 ALTER TABLE CJB     
DROP CONSTRAINT cj_constraint
```

#### 2．规则对象的定义、使用与删除

规则是一组使用T-SQL语句组成的条件语句，是实现域完整性与用户定义完整性的一种方法。
与默认值对象的使用步骤类似，需要先定义规则对象，再将规则对象绑定到列或用户自定义类型。
**（1）规则对象的定义。**
语法格式：

```sql
CREATE RULE [ schema_name.] rule_name 
	AS condition_expression
```

**（2）规则对象的绑定**
使用系统存储过程sp_bindrule。
语法格式：

```sql
sp_bindrule [ @rulename = ] 'rule' , 
   [ @objname = ] 'object_name' 
```

**（3）应用举例。**

```sql
【例6.23】 如下程序创建一个规则，并绑定到表KCB的课程号列，用于限制课程号的输入范围。 
CREATE RULE  kc_rule
	AS @range like '[1-5][0-9][0-9]'  -- @range相当于形式参数 
GO
EXEC sp_bindrule 'kc_rule', 'KCB.课程号'
GO
```

```sql
【例6.24】 创建一个规则，用以限制课程名的输入。
CREATE RULE list_rule
	AS @list IN ('C语言', '离散数学', '微机原理')
GO
EXEC sp_bindrule list_rule, 'KCB.课程名'
GO
```

**（4）规则对象的删除。**
需要先解除绑定，再删除。
*解除绑定：*

```sql
sp_unbindrule [@objname =] ‘object_name’--object_name为“表名.列名”或用户定义数据类型 
	[, [@futureonly =] ‘futureonly_flag’] –本选项只用于用户定义数据类型 
```

删除规则：

```sql
DROP RULE { [ schema_name . ] rule_name } [ ,...n ] 
```

```sql
【例6.26】 解除规则kc_rule与列或用户定义类型的的绑定关系，并删除规则对象kc_rule。
EXEC sp_unbindrule 'KCB.课程号'
GO
DROP RULE kc_rule
GO
```

### 6.3.4  参照完整性的实现

#### 利用“T-SQL命令”定义表间的参照关系

可在创建表的同时定义外键约束。或通过ALTER TABLE添加外键

```sql
【例6.28】 
create table CJB
(
学号	char(6) not null  REFERENCES  XSB(学号),
课程号	char(3) not null,
成绩	int
constraint pk_CJB primary key(学号,课程号)
)
```

```sql
【例6.29】 
ALTER  TABLE CJB
  ADD CONSTRAINT fk_xh  FOREIGN  KEY(学号)  REFERENCES  XSB(学号)
```

#### 利用ALTER TABLE删除表间的参照关系

语法格式与删除其他约束的格式类似。

```sql
【例6.30】 删除上例对CJB表的课程号字段定义的外键约束。
ALTER TABLE CJB  
	DROP CONSTRAINT fk_xh 
```



# 第7章  存储过程和触发器

## 7.1  存储过程

存储过程（Stored Procedure）是一组完成特定功能的SQL语句集，经编译后存储在数据库的服务器电脑中。

**使用存储过程的优点如下：**

1.在数据库服务器中只有首次对存储过程中的命令进行编译，*以后直接调用无需编译*，加快执行速度。

2.存储过程可以用于*降低网络流量*，存储过程代码直接存储于数据库中，所以不会产生大量sql语句的代码流量。

3.*维护性高*，更新存储过程通常比更改、测试以及重新部署程序集需要较少的时间和精力。 

4.*自动完成需要预先执行的任务*（存储过程可以在SQL Server启动时自动执行）。

### 7.1.1  存储过程的类型

在 SQL Server 2005 中有下列几种类型存储过程：
（1）**系统存储过程**。系统预定义的存储过程，可以在任何一个数据库中作为命令执行。系统存储过程定义在系统数据库master中，其前缀是“sp_”。
例 如，sp_help  --显示系统对象信息

<img src="https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111221346644.png" alt="image-20211122134456830" style="zoom:50%;" />

~~（2）**扩展存储过程**。是指在SQL Server2005环境之外，使用编程语言（例 如C++语言）创建的外部例 程形成的动态链接库（DLL）。~~
~~例 如：EXEC xp_cmdshell  'dir c:\'     --显示目录信息~~
（3）**用户存储过程**。可以使用T-SQL语言编写，也可以使用CLR方式编写。在本书中存储过程一般是指用T-SQL语言编写的存储过程，而使用CLR方式编写的存储过程称为CLR存储过程。
 CLR存储过程就是使用Microsoft Visual Studio 2005环境下的语言作为脚本编写的、可以对Microsoft .NET Framework公共语言运行时（CLR）方法进行引用的存储过程。  

**WARRNING**:

存储过程的执行要注意下列几点：

(1) 如果存储过程名的前三个字符为 sp_，SQL Server 会在 Master 数据库中寻找该过程。如果没能找到，SQL Server 会寻找所有者名称为 dbo 的过程。

(2) 参数可以通过 常量 或 @变量 提供。 

(3) 执行存储过程时，若语句是批处理中的第一个语句（go之后的第一个语句），则EXECUTE 可省略。

### 7.1.2  存储过程的创建与执行

#### （1）不带参数的存储过程

```SQL
【例 7.1】 返回081101号学生的成绩情况。该存储过程不使用任何参数。
CREATE PROCEDURE student081101_info
	AS
     SELECT *	FROM CJB	WHERE 学号= '081101'
GO
```

执行存储过程：`EXECUTE student_info`

#### （2）带输入参数的存储过程

```sql
【例7.2】 查询指定的学生姓名和课程名的学号、姓名、课程名、成绩和学分。
      CREATE PROCEDURE student_info1 @name char(8), @cname char(16) 
      #CREATE PROCEDURE student_info1 (@name char(8), @cname char(16))√
      AS 
	SELECT XSB.学号, 姓名, 课程名, 成绩, KCB.学分
	FROM XSB JOIN CJB JOIN  KCB
          ON CJB.课程号= KCB.课程号
          ON XSB.学号= CJB.学号
	WHERE XSB.姓名=@name and KCB.课程名=@cname
```

执行存储过程：

`EXECUTE student_info1 '王林', '计算机基础‘`

或：

`EXECUTE student_info1 @name=‘王林’, @cname=‘计算机基础’`  

或

`EXECUTE student_info1 @cname='计算机基础', @name='王林‘`

如下执行方式不能得到预期结果：

~~EXECUTE student_info1 '计算机基础', '王林'~~

#### （3）带OUTPUT输出参数的存储过程

```sql
【例7.3】计算指定学生所选课程的总学分。
CREATE PROCEDURE totalcredit 
 @num  varchar(40), #形参，输入参数
 @total  int  OUTPUT #形参，输出参数
AS
SELECT @total= SUM(学分)	FROM XSB,CJB,KCB
	WHERE 姓名=@num AND XSB.学号= CJB.学号 AND CJB.课程号= KCB.课程号
    	GROUP BY XSB.学号
```

执行：

```sql
DECLARE  @总学分   decimal(4,1)/*有效位数,小数*/
EXEC  totalcredit  '王林' ,@总学分 OUTPUT  /*取得王林总学分*/
select @总学分  as  '总学分'   /*显示王林的总学分*/
```

#### （4）输入参数带有通配符。

```sql
【例7.4】 使用存储过程查询指定学生的选课情况（包括学号、姓名、所选课程名称），如果执行过程时未提供参数，则查询所有学生的选课情况。
CREATE PROCEDURE st_info @name varchar(30) = '%'
	AS 
	SELECT a.学号,a.姓名,c.课程名
		FROM  XSB a  INNER JOIN  CJB  b
		ON a.学号 =b.学号 INNER JOIN KCB c
		ON c.课程号= b.课程号 
		WHERE 姓名 LIKE @name
GO 
```

执行存储过程：

```sql
EXECUTE st_info         /*参数使用默认值，返回所有学生的选课情况*/
或者：
EXECUTE st_info  '王%'   /*传递给@name 的实参为'王%'*/
```

#### （6）使用**WITH ENCRYPTION**选项对用户隐藏存储过程的文本。

```sql
【例7.6】 创建加密过程
Create proc up_insertcj @学号 char(20),@课程号 char(20),@成绩  decimal
with encryption
as
begin tran
insert cjB values(@学号,@课程号,@成绩)
if @@error=0#全局变量
   commit
else
   begin
     rollback
     print '温馨提示：数据插入失败'
   end
go
exec up_insertcj '081241','206',90
```

使用 `EXEC sp_helptext up_insertcj` 查看效果。

使用**ALTER PROCEDURE**命令可修改已存在的存储过程并保留以前赋予的许可。

- **不需要重新授权**,一般都是删掉重建

## 7.2  触发器



### 7.2.1  触发器的类型

#### （1）DML触发器。

执行*INSERT、 DELETE 、UPDATE*语句时触发。
DML触发器实现数据的完整性、多个表间数据的一致性等。比如实现外键的功能：当向CJB中插入记录时，保证学号是XSB表中已存在的；再如：*可通过对XSB表定义DELETE触发器，实现在XSB表中删除一个学生时，同时删除CJB表中所有该学生的记录。*

#### ~~（2）DDL触发器。~~

~~是SQL Server 2005新增的功能，也是由相应的事件触发，但DDL触发器在执行*CREATE、ALTER、DROP*等语句时触发。~~
~~DDL触发器只由**T-SQL语句触发**。~~

#### 1．创建DML触发器

```sql
语法格式：
CREATE TRIGGER 触发器名 
	ON  表或视图名  			/*指定需创建触发器的表或视图*/
		[ WITH  ENCRYPTION ]		/*是否加密*/
	{ FOR |AFTER | INSTEAD OF } 
		{ [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] } 
	[ NOT FOR REPLICATION ] 		/*说明该触发器不用于复制*/
AS {  sql语句块 }
```

<!--instead of触发器表示并不执行其定义的操作（insert、update、delete）而仅是执行触发器本身的内容。-->

<!--Update 可以看作：插入新的，删除旧的。-->
<!--两个特殊的虚拟表Inserted 和Deleted：-->
<!--Inserted表存放新增的记录， Deleted存放被删除的记录-->
<!--Update 操作时：新的记录存入Inserted表，旧的记录存入Deleted表-->

```sql
【例7.10】 创建一个表table1，其中只有一列a。在表上创建一个触发器，每次插入操作时，将变量@str的值设为“插入了一条记录”并显示之。
CREATE TABLE table1(a int)
GO
CREATE TRIGGER table1_insert
	ON table1 AFTER INSERT
	AS
	BEGIN
		DECLARE @str char(50)
		SET @str=‘插入了一条记录'
		PRINT @str
	END
```

向table1中插入一行数据：INSERT INTO table1 VALUES(10)
执行结果如下所示：

![image-20211129134820225](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111291348359.png)

```sql
【例7.11】 创建触发器，当向CJB表中插入一个学生的成绩时，将XSB表中该学生的总学分加上添加的课程的学分。
      CREATE TRIGGER cjb_insert
	ON CJB AFTER INSERT
	AS
	BEGIN
		DECLARE @num char(6),@kc_num char(3),@xf int
		SELECT @num=学号, @kc_num=课程号from inserted#学号和课程号都在inserted表中,取出给num/kc_num赋值
		#set @num=(SELECT 学号, @kc_num=课程号from inserted)
		#select @num=(SELECT 学号, @kc_num=课程号from inserted)
		SELECT @xf=学分FROM KCB WHERE 课程号=@kc_num
		UPDATE XSB SET 总学分=总学分+@xf  WHERE 学号=@num
		PRINT '修改成功'
	END
```

```sql
思考1：
select * from xsb where 学号='081101'  --查看总学分
select * from kcb 
where 课程号 in ('208','209')--查看'208','209'课程的学分
对于例7.11触发器，执行如下语句是增加4学分学分还是8学分
INSERT INTO cjb 
select '081101','208',60
union all
select '081101','209',60
答案:4学分
```

```sql
思考2：
如下sql实现了什么功能？
create view v_zxf
as
SELECT 学号,sum(KCB.学分) as 总学分from cjb join KCB on cjb.课程号=KCB.课程号group by 学号

UPDATE XSB SET 总学分=(select v_zxf.总学分from v_zxf WHERE XSB.学号=v_zxf.学号)
```

### 7.2.2  触发器的创建

```sql
【例7.12】 创建触发器，当修改XSB表中的学号时，同时也要将CJB表中的学号修改成相应的学号（假设XSB表和CJB表之间没有定义外键约束）。
CREATE TRIGGER xsb_update
	ON XSB AFTER UPDATE
	AS
	BEGIN
		DECLARE @old_num char(6), @new_num char(6)
		SELECT @old_num=学号 FROM deleted
		SELECT @new_num=学号 FROM inserted
		UPDATE CJB SET 学号=@new_num WHERE 学号=@old_num
	END
修改XSB表中的一行数据，查看触发器执行结果：
UPDATE XSB SET 学号='081120' WHERE 学号='081101'
GO
SELECT *  FROM CJB WHERE 学号='081120'
执行结果如下：
```

```sql
【例7.13】 在删除XSB表中的一条学生记录时将CJB表中该学生的相应记录也删除。
CREATE TRIGGER xsb_delete
	ON XSB AFTER DELETE
	AS
	BEGIN
	    DELETE  FROM  CJB  WHERE 学号 IN(SELECT 学号 FROM deleted)
	END
```

```sql
【例7.14】 在KCB表中创建UPDATE和DELETE触发器，当修改或删除KCB表中的课程号时，同时修改或删除CJB表中的该课程号(本例应保证每次只修改一条记录)。
CREATE TRIGGER kcb_trig
	ON KCB AFTER UPDATE, DELETE
	AS
	BEGIN
	  IF (UPDATE(课程号))
	     UPDATE CJB SET 课程号=(SELECT 课程号 FROM inserted)
		WHERE 课程号=(SELECT 课程号 FROM deleted) --应保证每次只修改一条记录
	  ELSE
	     DELETE FROM CJB WHERE 课程号 IN(SELECT 课程号 FROM deleted)
	END
```

**instead of捣乱**

```sql
【例7.15】 理解INSTEAD OF INSERT触发器。创建表table2，只包含一列a，在表中创建INSTEAD OF INSERT触发器，当向表中插入记录时显示相应消息。
CREATE TABLE table2(a int)
GO
CREATE TRIGGER table2_insert
		ON table2 INSTEAD OF INSERT
	AS
		PRINT 'INSTEAD OF TRIGGER IS WORKING'
向表中插入一行数据：
INSERT INTO table2 VALUES(10)
执行结果如下所示：
```

![image-20211129144501423](https://gitee.com/yonaspigeon/giteepicstore/raw/master/img/202111291445666.png)

```sql
【例7.16】 创建视图stu_view，包含学生学号、姓名、专业、课程号、成绩。该视图依赖于表XSB和CJB两个表，因此是不可更新视图。本例通过在视图上创建INSTEAD OF触发器，将插入视图中的数据分别插入到XSB和CJB，从而实现向视图插入数据的功能。
首先创建视图：
        CREATE VIEW stu_view
        AS 
        SELECT XSB.学号, 姓名,专业,课程号,成绩
            FROM XSB,CJB
            WHERE XSB.学号=CJB.学号
            
创建INSTEAD OF触发器：
CREATE TRIGGER InsteadTrig
	ON stu_view INSTEAD OF INSERT
	AS
	BEGIN
	   DECLARE @XH char(6), @XM char(8),@ZY char(12), @KCH char(3), @CJ int
	   SELECT @XH=学号, @XM=姓名,@ZY=专业, @KCH=课程号, @CJ=成绩  FROM inserted
	   INSERT INTO XSB(学号, 姓名, 专业) VALUES(@XH, @XM, @ZY)
	   INSERT INTO CJB VALUES(@XH, @KCH, @CJ)
	END
GO


```

#### 2．创建DDL触发器

语法格式：
CREATE TRIGGER 触发器名  ON { ALL SERVER | DATABASE } 
	[ WITH ENCRYPTION ]
	{ FOR | AFTER } { 事件类型 } [ ,...n ]
AS { sql语句块 }

```sqlite
【例7.17】 创建数据库作用域的DDL触发器，当删除一个表时，提示禁止该操作，然后回滚删除表的操作。
DROP TRIGGER  safety ON DATABASE  --删除触发器的语法不同于普通的触发器
go
CREATE TRIGGER  safety
	ON DATABASE   --无须给出数据库，会在当前数据库上创建本触发器
	AFTER DROP_TABLE
	AS
		PRINT '不能删除该表'
		ROLLBACK TRANSACTION  --必须回滚
假设数据中存在table1，则：
DROP TABLE table1
执行结果如下图，所创建的触发器如右图：
```

```sqlite
【例7.18】 创建服务器作用域的DDL触发器，当删除一个数据库时，提示禁止该操作并回滚删除数据库的操作。
CREATE TRIGGER safety_server
ON ALL SERVER
AFTER DROP_DATABASE
AS
	PRINT '不能删除该数据库'
	ROLLBACK TRANSACTION

说明：1）可在任意数据库执行上述语句。
      2）所创建的服务器级触发器如图。
```



## 7.3  ADO.NET存储技术.NET构架下CLR集成

